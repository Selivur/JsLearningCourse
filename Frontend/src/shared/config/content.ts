import { ContentSection } from "../types/domain";

const content: ContentSection[] = [
  {
    id: 1,
    title: "АЛГОРИТМИ  І  ОБЧИСЛЕННЯ",
    sections: [
      {
        id: 1,
        title: "Виконавець",
        topics: [
          {
            id: 1,
            title: "Обчислювальні машини",
            content: [
              {
                type: "heading",
                text: "Обчислювальні машини"
              },
              {
                type: "paragraph",
                text: "Обчислювальні пристрої зорієнтовані на полегшення і прискорення процесу обрахунку. Мабуть першими спеціальними пристосуваннями для обчислень були лічильні палички, які й наразі використовують учителі для навчання лічбі. З часом ці пристрої вдосконалювалися. Серед різноманіття винаходів ми виділимо абак (рахівниця), механічний арифмометр, електронний комп'ютер."
              },
              {
                type: "paragraph",
                text: "Перша рахівниця абак була винайдена 3000 років до н. е. у Вавилоні. Кількість підрахувань відповідала числу пересунутих кісточок рахівниці. Сучасним варіантом абаку є рахівниця, яка іноді використовується і нині."
              },
              {
                type: "image",
                src: "/images/image018.jpg",
                alt: "Рахівниця"
              },
              {
                type: "paragraph",
                text: "Багато обчислювальних пристроїв використовували зірочки та шестерні для реалізації лічби. Використавши цю ідею Вільгельм Шиккард у 1623 році, розробив механічний для додавання і віднімання шестирозрядних десяткових чисел. У 1642 році Блез Паскаль запропонував перший реально здійснений механічний цифровий обчислювальний пристрій, який міг додавати та віднімати числа з вісьмома десятковими розрядами."
              },
              {
                type: "image",
                src: "/images/image019.jpg",
                alt: "«Паскаліана»"
              },
              {
                type: "paragraph",
                text: "У 1673 році Ґотфрід Вільгельм Лейбніц збудував механічний калькулятор, який вперше використовував двійкову систему числення для реалізації операцій множення, ділення, додавання і віднімання. Двійкова система числення використовується у переважній більшості сучасних комп'ютерів."
              },
              {
                type: "paragraph",
                text: "Жозеф Марі Жаккар у 1801 році вперше застосував обчислювальні пристрої на виробництві, збудувавши ткацький верстат з програмним керуванням. Програма роботи верстату задавалась комплектом перфокарт."
              },
              {
                type: "image",
                src: "/images/image020.jpg",
                alt: "Вигляд перфокарти для в'язальної машини"
              },
              {
                type: "paragraph",
                text: "1820 рік ознаменувався першим промисловим випуском арифмометрів. Першість належить французу Тома де Кальмару. Механічні калькулятори використовувались до 1970-х років, коли були витіснені електронними пристроями."
              },
              {
                type: "paragraph",
                text: "У 1927 році в Массачусетському технологічному інституті була створена аналогова обчислювальна машина. У1938 році Конрад Цузе побудував свою першу повністю механічну програмувальну цифрову машину Z1. Модель була пробною і в практичній роботі не використовувалась.",
              },
              {
                type: "paragraph",
                text: "Калькулятори продовжували розвиватись, але комп'ютери додали найважливіший елемент — умовні команди та більше пам'яті. Комп'ютер (від англ. Computer) називають програмно-керований механічний або електронний пристрій для обробки інформації. Обробка може відбуватися за заздалегідь визначеним алгоритмом дискретно або безперервно. Починаючи приблизно з 1950-х років практично всі комп'ютери є саме електронними.",
              },
              {
                type: "subheading",
                text: "Уточнимо введені поняття"
              },
              {
                type: "paragraph",
                text: "Обчислювальна машина – це спеціалізована лічильна машина, створена для підвищення швидкості різноманітних операцій. Обчислювальні машини можуть бути автоматизованими, цифровими або аналоговими, універсальними або спеціалізованими.",
              },
              {
                type: "paragraph",
                text: "У цифровій машині вхідні дані та інструкція їх обробки (програма) закодовані цифрами, зберігаються в середині системи і в подальшому обробляються. У більшості випадків такі машини є універсальними, тобто, на них можна обчислювати різноманітні програми (алгоритми).",
              },
              {
                type: "paragraph",
                text: "Будь-яка аналогова машина має неперервну основу, дані та результат визначаються фізичними величинами (промінь світла, струм тощо). В основному вони реалізують тільки окремий процес обробки даних, тобто належать до класу спеціальних обчислювачів. Прикладом такої обчислювальної системи може виступати сонячний годинник у якому час доби визначається фіксацією тіні від перешкоди (камінь) на площині (грунті).",
              },
              {
                type: "image",
                src: "/images/image021.png",
                alt: "Ілюстрація дискретності та неперервності"
              },
              {
                type: "paragraph",
                text: "Для ілюстрації основної відмінності між дискретним (цифровим) і аналоговим принципом обробки інформації розглянемо класичний приклад з музичними інструментами. Рояль можна назвати дискретною системою, тому що в ній довільну фіксовану ноту можна або грати, або ні, бо кожна нота (клавіша) фізично (дискретно) відділена від наступної. Скрипка ж буде аналоговою системою, оскільки на скрипці висота тону може змінюватися неперервно, змінюючи положення смичка на струні. Дискретність можна уявити як утворення цегляної стінки будівлі із окремих цеглин, а неперервність характеризує водяний потік.",
              },
              {
                type: "paragraph",
                text: "Відомо, що довільну аналогову машину теоретично можна апроксимувати (змоделювати) деякою цифровою. Проте, на практиці виникають труднощі реалізації. Наприклад, спроба імітації роботи людського мозку призводить до природних обмежень, пов'язаних з кількістю потрібної пам'яті та часу отримання результату.",
              },
              {
                type: "paragraph",
                text: "Цифрові обчислювальні машини (ЦОМ) можна поділити на класи відповідно до організації загальних принципів обчислень. Прикладом подібної класифікації є два великі класи ЦОМ: послідовні та паралельні. Цей поділ використовує такий критерій: ЦОМ можуть виконувати одночасно одну або кілька операцій.",
              },
              {
                type: "image",
                src: "/images/image023.png",
                alt: "Загальна функціональна схема ЦЕОМ"
              },
              {
                type: "paragraph",
                text: "Слід зазначити, що не всі блоки, зображені на рисунку, присутні в усіх типах ЦОМ, але ця схема є узагальненою.",
              },
              {
                type: "paragraph",
                text: "Пам'ять обчислювальної машини зберігає список команд (програму) обробки даних і самі дані (набір цифр), які оброблятимуться цими операціями (командами). У випадку нашого прикладу з пранням білизни це програма (інструкція) прання і білизна.",
              },
              {
                type: "paragraph",
                text: "Керуючий пристрій визначає, які ж команди пересилатимуть дані в арифметичний пристрій для виконання необхідних операцій. Після виконання цих операцій дані повертаються в запам'ятовуючий пристрій. У нашому прикладі з пранням це блок вибору режимів прання.",
              },
              {
                type: "paragraph",
                text: "Команди записуються у пристрій запам'ятовування згідно зі спеціальним форматом використання спеціальних позначень. Формат називають машинним «словом», а спеціальними символами виступають цифри. Тобто, команда кодується деяким числом. Дані, які машина обробляє, мають бути також закодованими цифрами (числами) і розміщені в пам'яті. Інакше кажучи, машинні слова задають команди і дані.",
              },
              {
                type: "paragraph",
                text: "Різні обчислювальні машини можуть використовувати різне кодування для цього. Назва коду визначається кількістю цифр у кодуванні. Так десяткове кодування використовує 10 цифр (0,1,2,3,4,5,6,7,8,9), двійкове – 2 цифри (0,1), вісімкове – (0,1,2,3,4,5,6,7). Детально на цих кодах ми зупинимося в розділі 1.6. Наразі, тільки зазначимо, що довільний символ, число, колір, звук можна закодувати послідовністю двійкового коду 0 і 1.",
              },
              {
                type: "paragraph",
                text: "Для того щоб реалізувати певні дії, які слід застосовувати до даних, що знаходяться в пристрої запам'ятовування (регістрах пам'яті), ми повинні мати можливість вказувати комп'ютеру, які ж конкретні команди (дії, операції) він має виконати над цими даними. Тобто, процесор — це спеціальний пристрій («мозок» комп'ютера), призначений для керування всіма його пристроями та виконання арифметичних і логічних операцій над даними. Мікропроцесор - частина цифрової обчислювальної машини, а також іншої «розумної» цифрової техніки, що реалізує процес переробки інформації і координує роботу периферійних пристроїв. Найбільш поширеними є такі види цифрових процесорів:",
              },
              {
                type: "list",
                items: [
                  "Центральний процесор (CPU)",
                  "Графічний процесор (GPU)",
                  "Звуковий процесор",
                  "Процесор цифрових сигналів (DSP)"
                ]
              },
              {
                type: "paragraph",
                text: "Центральний процесор (англ. Central processing unit, CPU) — функціональна частина комп'ютера, яка призначена для інтерпретації команд обробки даних згідно заданої програми шляхом виконання арифметичних і логічних операцій та програмного керування роботою пристроїв комп'ютера.",
              },
              {
                type: "subheading",
                text: "Нейрокомп'ютер"
              },
              {
                type: "paragraph",
                text: "Є ще один тип обчислювальних пристроїв, який стоїть трішки виокремлено – це нейрокомп'ютер.",
              },
              {
                type: "paragraph",
                text: "З початку створення різноманітних обчислювачів спеціалісти намагалися створити обчислювальний пристрій, який би моделював роботу мозку людини. Оскільки в мозку людини головну роль виконує нейрон, пробували знайти ключ до моделювання розумової діяльності людини в моделюванні роботи нейрону мозку.",
              },
              {
                type: "paragraph",
                text: "Для багатьох цілей нейрон можна розглядати як елемент з певним критичним значенням. Це означає, що він або ж дає на виході деяку постійну величину, якщо сума його входів досягає певного значення (порогу), або ж залишається пасивним в іншому випадку.",
              },
              {
                type: "paragraph",
                text: "Мак-Каллок і Піттс довели, що будь-яку обчислювальну функцію можна реалізувати за допомогою спеціально організованої мережі ідеальних нейронів, логічні властивості яких з високою ймовірністю можна приписати реальному нейрону. Та ця мережа матиме наступні вади.",
              },
              {
                type: "paragraph",
                text: "По-перше, важко знайти якийсь розумний принцип реорганізації мережі, який давав би змогу випадково об'єднаній спочатку групі ідеальних нейронів само організовуватися в «обчислювальний пристрій», здатний розв'язувати довільну задачу.",
              },
              {
                type: "paragraph",
                text: "По-друге, потрібно використовувати велику кількість нейронів. Наприклад, модель роботи мозку мурашки потребує використання близько 20 000 нейронів. А подумайте скільки їх знадобиться для моделювання роботи людського мозку. Вчені кажуть — 100 млрд. нейронів. Тому, в повному обсязі таку модель на практиці реалізувати неможливо.",
              },
              {
                type: "paragraph",
                text: "Нейрокомп'ютер – програмно-технічна система (спеціалізована ЕОМ), що реалізує деяку формальну модель природної мережі нейронів. Про важливість розвитку цього напряму свідчить і те, що в основу побудови обчислювальних пристроїв п'ятого покоління покладено ідею паралельної обробки інформації в нейроноподібних системах. Незважаючи на те, що один електричний процесор працює в тисячі разів швидше, ніж його нейронний еквівалент у мозку, мережі нейронів розв'язують багато задач (особливо нечислових) в тисячі разів швидше, ніж електронний процесор.",
              },
              {
                type: "paragraph",
                text: "Причина цього в наступному:",
              },
              {
                type: "list",
                items: [
                  "характер взаємозв'язків між нейронами дає змогу робити розв'язання багатьох задач, а також реалізацію різних функцій – у паралельний спосіб;",
                  "у нейронній мережі пам'ять не локалізована в одному місці (як в послідовних машинах), а розподілена по всій структурі; у біологічних системах пам'ять реалізується підсиленням або послабленням зв'язків між нейронами, а не зберіганням двійкових символів;",
                  "біологічні мережі реагують не на всі, а тільки на визначені зовнішні подразнення; кожен нейрон виступає як елемент прийняття рішення і елемент зберігання інформації; перевага такої структури – «життєздатність» (вихід з ладу декількох нейронів не спричиняє значної зміни даних, що зберігаються, або руйнування всієї системи);",
                  "можливість адресації за вмістом є ще однією важливою характеристикою систем з розподіленою пам'яттю (кожен елемент відшукують за його вмістом, а не зберігають в комірці пам'яті з визначеним номером)."
                ]
              },
              {
                type: "paragraph",
                text: "В основу зв'язків у нейрокомп'ютерах покладено асоціативний принцип. Асоціативні зв'язки пронизують все мислення людини. Наприклад, результат операції 5 помножити на 2 у нас є в пам'яті, і ми кожного разу його не обчислюємо, на противагу комп'ютеру а дістаємо із нашої пам'яті.",
              },
              {
                type: "paragraph",
                text: "Існує думка, що процеси мислення є не що інше як розповсюдження певного збудження, як деяка ланцюгова реакція. Навіть найпримітивніші процеси навчання принципово залежать від послідовності подій у часі. Це й закладено в природу нейронних систем. Тому їм притаманне реагування тільки на жорстко визначене зовнішнє подразнення. Наприклад, домашні тварини «навчаються» ігнорувати повторні несуттєві зовнішні подразнення («цокання» годинника), але посилюють сприйняття подразнень, які можуть мати серйозні наслідки (звук гальм автомобіля).",
              },
              {
                type: "paragraph",
                text: "Тому майбутнє – за комп'ютерами, які ґрунтуються на аналізі зв'язків, а не обробці символів. М. Мінський говорив, якщо комп'ютер має діяти подібно до мозку, тоді і його конструкція має бути також подібною до мозку.",
              },
              {
                type: "subheading",
                text: "Мови програмування"
              },
              {
                type: "paragraph",
                text: "Мови програмування полегшують запис алгоритму розв'язання задачі у формі зрозумілій комп'ютером. Ця форма дістала назву програми. Для того щоб програма була сприйнята і виконана на конкретній машині, цю програму слід перевести в мову автокоду (мову операцій) цієї машини. Процес переводу виконують спеціальні програми, які називають інтерпретаторами, асемблерами і компіляторами.",
              },
              {
                type: "paragraph",
                text: "Робота інтерпретатора ґрунтується на тому, що для задання кожної операції в машині використовують окремий символ, так що увесь набір операцій програми можна задати простими символами. Вони інтерпретуються і послідовно обробляються машиною.",
              },
              {
                type: "paragraph",
                text: "Асемблер застосовують до мов програмування, які дуже близькі до мови автокоду. Програму повністю перекладають з асемблерної мови в мову автокоду, а потім засилають на виконання.",
              },
              {
                type: "paragraph",
                text: "Компілятори відрізняються від асемблерів тільки тим, що одне слово може позначати набір операцій мови машинних команд. На відміну від інтерпретатора, який обробляє програму по-командно (переводить команду в мову машини і засилає на виконання) компілятор аналізує всю програму, переводячи всю програму в мову машини, і засилає її на виконання.",
              },
              {
                type: "image",
                src: "/images/image024.png",
                alt: "Ілюстрація відмінності інтерпретатора і компілятора"
              },
              {
                type: "paragraph",
                text: "Слово комп'ютер походить від англійського слова to compute, яке означає «здійснювати обчислення». Інша назва комп'ютерів – електронні обчислювальні машини. Вона підкреслює два ключових аспекти. По-перше, комп'ютер – це сукупність апаратних засобів, призначених для обчислень і перетворення інформації. По-друге, основними елементами комп'ютерів є електронні прилади.",
              },
              {
                type: "paragraph",
                text: "Комп'ютер здійснює обчислення та інші інформаційні перетворення за допомогою програм, тобто певних послідовностей інструкцій. Можна вважати, що за допомогою програм здійснюється керування апаратними засобами комп'ютера.",
              },
              {
                type: "paragraph",
                text: "Найпростіші засоби для виконання простих арифметичних операцій були відомі людям у глибоку давнину. Перші механічні пристрої (арифмометри) створено в середині ХVII ст. Паскалем і Лейбніцом. У XIX ст. Чарльз Беббідж уперше сформулював ідею створення універсальної обчислювальної машини. Він розробив детальний проект, який не був закінчений через відсутність необхідної технічної бази.",
              },
              {
                type: "paragraph",
                text: "Значний внесок у розробку принципів функціонування комп'ютерів зробив Алан Тьюринг, який у 1937 р. описав гіпотетичну машину з універсальними можливостями. Ця машина Тьюринга, яку можна розглядати як одну з можливих формалізацій поняття «алгоритм», стала теоретичною основою сучасних комп'ютерів. Перша електронно-обчислювальна машина ENIAC створена у 1943–46 рр. Дж. У. Моклі та Дж. П. Екертом з Пенсільванського університету.",
              },
              {
                type: "image",
                src: "/images/image025.png",
                alt: "Фрагмент ЕОМ UNIVAC"
              },
              {
                type: "paragraph",
                text: "Початок серійного виробництва ЕОМ пов'язують зі створенням у 1951 р. ЕОМ UNIVAC. Вона мала величезний розмір.",
              },
              {
                type: "paragraph",
                text: "Роботи над створенням першої вітчизняної ЕОМ МЕЛМ (малої електронної лічильної машини) були розпочаті в Інституті електротехніки АН УРСР (Київ) у 1947–1948 рр. групою науковців під керівництвом С. О. Лебєдєва. У 1951 р. машину було прийнято до експлуатації.",
              },
              {
                type: "image",
                src: "/images/image026.png",
                alt: "МЕЛМ"
              },
              {
                type: "paragraph",
                text: "Як подальші віхи в розвитку обчислювальної техніки можна відзначити такі: поява операційних систем; виникнення мов програмування високого рівня; розвиток мережних технологій і масове розповсюдження персональних комп'ютерів.",
              },
              {
                type: "paragraph",
                text: "Комп'ютери бувають спеціалізовані, призначені для виконання окремих задач, і універсальні. Універсальний обчислювач можна визначити як машину, що в принципі може розв'язувати будь-яку задачу, для якої існує алгоритм виконання, або як машину, здатну реалізувати будь-який алгоритм. Надалі розглядатимемо лише цифрові універсальні машини, і якщо не буде явно вказано інше, під словом комп'ютер ми розумітимемо саме такі машини.",
              },
              {
                type: "paragraph",
                text: "Інформація, яку обробляє комп'ютер, зберігається в його пам'яті у вигляді послідовності нулів та одиниць. Пам'ять складається з електронних схем, кожна з яких може перебувати в одному з двох стійких станів, один з них беруть за 0, а інший – за 1. Мінімальною одиницею інформації є біт. Біт – один двійковий розряд, за допомогою якого можна закодувати одне з двох можливих значень: 0 або 1.",
              },
              {
                type: "paragraph",
                text: "Зрозуміло, що для виконання обчислень цифровий комп'ютер повинен мати у своєму складі засоби, що дають змогу виконувати операції над двійковими розрядами, тобто реалізовувати булеві функції. Булевою називається функція, аргументи і результат якої можуть набувати одне з двох можливих значень: 0 (хибність) або 1 (істина).",
              },
              {
                type: "subheading",
                text: "Класифікація комп'ютерів за потужністю"
              },
              {
                type: "paragraph",
                text: "Цифрові універсальні комп'ютери можна класифікувати за потужністю. Виділяють такі основні групи цих комп'ютерів.",
              },
              {
                type: "paragraph",
                text: "Суперкомп'ютери. Для них характерна наявність великої (десятки, сотні або тисячі) кількості процесорів, які спільно розв'язують ту чи іншу задачу, тим чи іншим способом взаємодіючи між собою; у цьому разі забезпечується дуже висока сумарна потужність. Типове призначення суперкомпів – виконання надскладних розрахунків. Найпростіші суперкомп'ютери можна використовувати як корпоративні мережні сервери. У цьому разі їх називають майнфреймами. Як приклади суперкомп'ютерів можна навести IBM System/390, T/9000, RS/6000. Ще більшу потужність забезпечують суперкомп'ютери фірм Intel, Fujitsu, Hitachi, Cray-SGI. Одна із останніх розробок Intel об'єднує 9200 процесорів Pentium Pro, займає площу 160 м2 і має масу 40 т. Пристрій для охолодження важить 272 т. Оперативна пам'ять становить 573 ГБ, швидкодія – понад трильйон операцій за секунду.",
              },
              {
                type: "image",
                src: "/images/image027.png",
                alt: "Вигляд суперкомп'ютера."
              },
              {
                type: "paragraph",
                text: "Найчастіше обчислювальна потужність вимірюється в Флопс (кількості операцій над числом яку може виконати процесор в секунду), а також похідними від цієї величини. Зараз до суперкомп'ютерів відносять системи з обчислювальною потужністю більше 10 терафлопс (1012 або десять трильйонів флопс). Це величезна швидкодія, яку можна відчути, згадавши що середньостатистичний персональний комп'ютер 2010 року має продуктивність порядку 0.1 терафлопс. Найпотужніша з існуючих комп'ютерних систем — японський K computer — має продуктивність, що перевищує 10,5 петафлопс.",
              },
              {
                type: "paragraph",
                text: "ЕОМ класу міні займають проміжне положення між великими ЕОМ і персональними комп'ютерами. Мають невелику кількість процесорів (від 1 до 8–12) та порівняно невеликі розміри і невисоку ціну. Використовуються як професійні робочі станції або як корпоративні мережні сервери.",
              },
              {
                type: "paragraph",
                text: "Персональні комп'ютери. Їх можна визначити як комп'ютери, призначені для індивідуального користування. Поділяють їх на настільні та портативні. Останнім часом з'явився новий клас – персональні помічники, такі як Psion виробництва комп'ютеранії Sharp, Newton Messag Pad фірми Apple Computer, Omni Go фірми Hewlett-Packard. Це мобільні комп'ютери, мініатюрні за розміром (300–4000 г), з порівняно невеликою оперативною пам'яттю (1–2 МБ) та малою тактовою частотою (7–9 МГц).",
              }
            ]
          },
          {
            id: 2,
            title: "Основи фон-нейманівської архітектури",
            content: [
              {
                type: "heading",
                text: "Основи фон-нейманівської архітектури",
              },
              {
                type: "paragraph",
                text: "Значна частина сучасних комп'ютерів функціонує за принципами, сформульованими в середині 1940-х рр. Дж. фон Нейманом. Він виділив пристрої, які мають входити до комп'ютера: керуючий; арифметико-логічний; оперативну пам'ять; зовнішню пам'ять (зовнішні запам'ятовуючі пристрої, зовнішні носії інформації); введення; виведення (рис.1.6.)."
              },
              {
                type: "image",
                src: "/images/image028.png",
                alt: "Рис.1.6. Архітектура фон-нейманівської ЕОМ"
              },
              {
                type: "paragraph",
                text: "Роботу універсальної фон-нейманівської ЕОМ у найзагальніших рисах можна описати так. Програми та дані, що зберігаються на зовнішніх носіях, вводять за допомогою пристроїв введення і пересилають до оперативної пам'яті. Обчислення здійснюють арифметико-логічним пристроєм. Інформацію, що є в оперативній пам'яті, за потреби передають до арифметико-логічного пристрою для обробки; проміжні результати обчислень знову передають в оперативну пам'ять. Результати роботи обчислювальної машини виводять на зовнішні носії за допомогою пристроїв виведення. Всі операції в ЕОМ здійснюють під управлінням керуючого пристрою."
              },
              {
                type: "paragraph",
                text: "Можна також виділити такі характерні риси фон-нейманівської архітектури: двійкова система кодування інформації; лінійна організація пам'яті, тобто пам'ять фон-нейманівського комп'ютера складається з послідовності однотипних комірок; будь-яка програма має вільний доступ до пам'яті за адресою; програма є послідовністю елементарних команд. Елементарна команда — це команда, яку розуміє процесор і яку він може виконати безпосередньо. Після реалізації певної команди він починає виконувати наступну. У сучасних комп'ютерах арифметико-логічний і керуючий пристрої об'єднані в один. Його й називають центральним процесором."
              },
              {
                type: "paragraph",
                text: "Фон-нейманівська архітектура має багато «вузьких місць». Уже наприкінці 1950-х рр. намітилися тенденції відходу від цієї архітектури. Зокрема, тенденції були пов'язані з розвитком багатопроцесорних систем. Нині можна вважати, що класична фон-нейманівська архітектура в основному вичерпала свої можливості."
              },
              {
                type: "paragraph",
                text: "Типовий центральний процесор фон-нейманівського комп'ютера має таку будову. В основному він складається із спеціальних регістрів які використовують для тимчасового зберігання даних. В одному регістрі можна зберігати 2–4 байти інформації. Кількість розрядів, або бітів, в одному регістрі називають його розрядністю. Регістр адреси пам'яті містить адресу комірки пам'яті, з якої або до якої слід переслати дані. Регістр даних пам'яті містить дані, що мають бути зчитані в оперативну пам'ять. Регістр програмного лічильника містить адресу комірки пам'яті, в якій зберігається команда, що виконується. Регістр команд містить команду, яку слід виконувати."
              },
              {
                type: "paragraph",
                text: "Процес обробки програми є ітераційним виконанням окремих команд (інструкцій, операторів) програми. На кожному кроці ітерації виконуються три дії: вибірка чергової команди програми, її декодування (розпізнання типу обробки) та безпосереднього виконання (реалізація обробки). Обробка починається із першої команди (команда початку програми) і закінчується останньою командою (команда закінчення програми)."
              },
              {
                type: "paragraph",
                text: "Спочатку в регістр програмного лічильника заноситься адреса команди початку програми, яка ініціює ітераційний процес обробки програми. Цей процес складається із наступних дій. Після виконання чергової команди обраховується адреса наступної команди обробки програми і заноситься в програмний лічильник.  Цю адресу пересилають до регістра адреси, а керуючий пристрій надсилає до оперативної пам'яті сигнал зчитування. Інформацію, зчитану з оперативної пам'яті, пересилають   в регістр даних пам'яті, а звідти – в регістр команд. Виконується обробка команди. По досягненню останньої команди програми ітераційний процес обробки програми закінчується. Аналогічним способом зчитують операнди команди."
              },
              {
                type: "paragraph",
                text: "Декодування полягає в перетворенні двійкових кодів команд та операндів (даних) на послідовність електричних імпульсів, необхідних для виконання команд апаратними засобами. Типовим є мікропрограмне декодування, у разі якого процес декодування визначається мікрокодом. Мікрокод представляє собою сукупність правил, що визначають, яка послідовність імпульсів потрібна для виконання тієї чи іншої команди процесора. Він зберігається безпосередньо в процесорі. Його можна розглядати як програму, але програму ще більш низького рівня, ніж машинний код. Він є недоступним ні для користувачів, ні для програмістів, і є прерогативою розробників процесорів. Нарешті, на етапі безпосереднього виконання декодована команда реалізується апаратними засобами."
              },
              {
                type: "paragraph",
                text: "Робота усіх складових частин процесора синхронізується за допомогою електричних тактових імпульсів, що з певною частотою генерує керуючий пристрій. Час між двома імпульсами називають тактом. Одну команду можна виконати за один або декілька тактів. Тактовою частотою називають кількість тактів, що генеруються за 1 с. Від цієї характеристики істотно залежить швидкодія процесора."
              },
              {
                type: "paragraph",
                text: "Обмін даними між процесором та оперативною пам'яттю здійснюється через шину пам'яті. Фізично шина складається з певної кількості провідників. Через один провідник можна одночасно передати один біт інформації. Кількість таких провідників називають розрядністю шини. Один провідник інколи називають лінією. Шина пам'яті складається з двох частин: шина даних, адресна шина. Шину даних використовують для передачі даних, а адресну шину – для передачі адреси."
              },
              {
                type: "paragraph",
                text: "Важливим для сучасних процесорів є поняття переривання. Перериванням називають спеціальний сигнал, який надходить від якогось пристрою та змушує центральний процесор призупинити виконання програми і зайнятися обробкою переривання (відшуканням причини аварійного призупинення обробки програми)."
              }
            ]
          },
          {
            id: 3,
            title: "Фізичні складові комп'ютера",
            content: [
              {
                type: "heading",
                text: "Фізичні складові комп'ютера",
              },
              {
                type: "paragraph",
                text: "Розглянемо основні апаратні складові комп'ютера (рис.1.7). До його базових компонент входить системний блок, монітор, клавіатуру, мишку та інше периферійне (додаткове) обладнання (аудіо колонки)."
              },
              {
                type: "image",
                src: "/images/image029.png",
                alt: "Рис.1.7. Основні складові комп'ютера"
              },
              {
                type: "paragraph",
                text: "Головною частиною комп'ютера є системний блок (computer case). В ньому розміщені основні складові виконавця-обчислювача (рис.1.8)."
              },
              {
                type: "image",
                src: "/images/image030.jpg",
                alt: "Рис.1.8. Системний блок"
              },
              {
                type: "paragraph",
                text: "Здебільшого, металевий або пластмасовий корпус системного блоку захищає внутрішні компоненти комп'ютера від бруду та механічних пошкоджень, забезпечує необхідний температурний режим, екранує електромагнітні випромінення. У системному блоці проходять всі основні обчислювальні процеси. Решта обладнання забезпечує введення і виведення інформації в різній формі та керування комп'ютером. В основному вони спрямовані на покращення людино-комп'ютерної взаємодії. Наприклад, можна керувати комп'ютерною грою і за допомоги клавіатури, та насолоду від гри значно підвищить мишка або «джойсик»."
              },
              {
                type: "paragraph",
                text: "Основним елементом системного блоку є материнська плата (motherboard) – плата, до якої приєднуються основні компоненти виконавця: центральний процесор, оперативна пам'ять, відеокарта, жорсткий диск, оптичний привід та інші (рис.1.9). Вона містить USB та інші роз'єми для під'єднання периферійного обладнання та змушує всі компоненти обчислювача і відображення результатів обчислення працювати як єдине ціле."
              },
              {
                type: "image",
                src: "/images/image031.png",
                alt: "Рис.1.9. Материнська плата"
              },
              {
                type: "paragraph",
                text: "Процесор (центральний процесор, CPU) виконує функції – подібні до функцій мозку людини. Він сприймає та розпізнає всі команди користувача і управляє процесом фізичної реалізації обчислення. Процесор під'єднується до материнки використовуючи спеціальний роз'єм, який ще називають сокетом (socket). Для кожного типу процесору потрібний свій тип сокета. Основою процесора є мікросхема (рис.1.10)."
              },
              {
                type: "image",
                src: "/images/image032.png",
                alt: "Рис.1.10. Мікросхема"
              },
              {
                type: "paragraph",
                text: "Зростання потужності процесора забезпечується збільшенням кількості транзисторів на мікросхемі. Відомий закон Мура проголошує «що кожні 18 місяців кількість транзисторів на мікросхемі збільшується у 2 рази». Але вже досягає верхньої межі. Причиною тут стає проблема збереження температурного режиму. Тому, поверх процесора на материнку встановлюється спеціальне обладнання для охолодження, невеликий радіатор з вентилятором (куллером) для розсіювання тепла (див. рис.1.11)."
              },
              {
                type: "image",
                src: "/images/image033.png",
                alt: "Рис.1.11. Охолоджувач"
              },
              {
                type: "paragraph",
                text: "Важливою компонентою обробки інформації виконавцем поряд із центральним процесором є оперативна пам'ять – модулі оперативного запам'ятовуючого пристрою (Рис.1.12). Швидкість доступу до інформації, яка знаходиться в оперативній пам'яті, у сотні разів перевищує швидкість доступу до жорсткого диска. Це дає можливість процесору оперувати потрібною інформацією, отримуючи до неї практично миттєвий доступ. В оперативну пам'ять процесор записує і зчитує з неї дані, необхідні для прискорення здійснення спеціалізованих операцій обробки. Швидкість пам'яті визначається частотою її шини, яка залежить від типу пам'яті (SDR SDRAM (тактова частота шини 66 - 133 МГц, DDR3 SDRAM (800 - 2400 МГц). Потік команд обробляється конвеєрним чином. При запиті до даних на зчитування пам'ять реагує з деяким запізненням. Головною особливістю цього конвеєра є те, що при надходженні до запам'ятовуючого пристрою команди зчитування, дані на виході з'являються із запізненням на певну кількість тактів шини. Цю затримку називають – таймінгом пам'яті (англ. - SDRAM latency). Зрозуміло, що від розміру затримки залежить продуктивність пам'яті."
              },
              {
                type: "image",
                src: "/images/image034.png",
                alt: "Рис.1.12. Модулі ОЗП"
              },
              {
                type: "paragraph",
                text: "Різні типи модулів ОЗП істотно відрізняються також і зовні (роз'ємом, кількістю контактів і т.п.). Крім швидкості роботи, важливою характеристикою оперативної пам'яті є також її об'єм, який повинен бути зорієнтований на тип задач, що будуть вирішуватись, і програмне забезпечення яке буде використовуватись при цьому. Вартість оперативної пам'яті значна."
              },
              {
                type: "paragraph",
                text: "Жорсткий диск (вінчестер, див. рис.1.13) – запам'ятовуючий пристрій, на якому зберігається вся інформація, що є в комп'ютері. Він приєднуються до материнської плати через інтерфейс SATA."
              },
              {
                type: "image",
                src: "/images/image035.png",
                alt: "Рис.1.13. Вінчестер"
              },
              {
                type: "paragraph",
                text: "На сьогодні використовуються два основних типи запам'ятовуючих пристроїв – це жорсткі диски і SSD."
              },
              {
                type: "paragraph",
                text: "Накопичувач на жорстких магнітних дисках («вінчестер», англ. - hard disk drive (HDD)) – пристрій для зберігання інформації, в якому використовується принцип магнітного запису на одну або більше пластин, що швидко обертаються на одній осі. Обертання створює своєрідний шар повітря, завдяки якому зчитувальні головки не торкаються поверхні пластин, хоч і знаходяться дуже близько від них (всього кілька нанометрів). При зупинці пластин головки переміщуються за межі їх поверхні, тому механічний контакт між головками та пластинами практично виключений. Така конструкція забезпечує довговічність запам'ятовуючих пристроїв цього типу та надійність обробки інформації."
              },
              {
                type: "paragraph",
                text: "HDD складається із накопичувача, приводу і блоку електроніки."
              },
              {
                type: "image",
                src: "/images/image036.png",
                alt: "Рис.1.14. Твердотільний накопичувач"
              },
              {
                type: "paragraph",
                text: "Твердотільний накопичувач SSD (solid state-drive) – запам'ятовуючий пристрій відносно нового типу, який працює на основі використання мікросхем пам'яті і на відміну від HDD не містить рухомих частин (рис.1.14.). Останнє забезпечує SSD ряд суттєвих переваг: відсутність вібрації і шуму, низьке енергоспоживання, більш високу швидкість, невеликий розмір, стійкість до температурних коливань і механічного впливу й ін."
              },
              {
                type: "paragraph",
                text: "Значними недоліками SSD є їх висока вартість і швидкість зношування (зазвичай, близько 10 тис. циклів перезапису, у більш дорогих виробах - до 100 тис.)."
              },
              {
                type: "paragraph",
                text: "Основними характеристиками HDD та SSD є ємкість (кількість даних збереження), інтерфейс – сукупність ліній зв'язку, якими запам'ятовуючий пристрій підключається до материнки), форм-фактор (кажучи фізичний розмір пристрою, вимірюється в дюймах), час довільного доступу (RAT, random access time – середній проміжок часу, за який пристрій здійснює позиціонування головки на потрібну ділянку магнітної пластини), швидкість обертання шпинделя (кількість обертів магнітних пластин жорсткого диска за 1 хвилину), об'єм буфера (спеціальна внутрішня швидка пам'ять диска, що використовується для тимчасового зберігання даних з метою згладжування перебоїв при зчитуванні та записі інформації на носій і її передачі по інтерфейсу)."
              },
              {
                type: "paragraph",
                text: "Потужна відеокарта для геймера бажаніша ніж високопродуктивний центральний процесор. Процесор середнього рівня і середня відеокарта в іграх залишать далеко позаду найсучасніший процесор з інтегрованим відеоадаптером. Але надто слабкий процесор не дасть можливості хорошій відеокарті розкрити весь свій потенціал."
              },
              {
                type: "paragraph",
                text: "Відеокарта (відеоадаптер, графічна плата, графічний адаптер, графічна карта) є спеціалізованим комп'ютером, що складається з власного процесора, оперативної пам'яті, BIOS та інших компонентів, які пристосовані для максимально ефективного вирішення обробки і формування графічних даних та їх виведення на монітор."
              },
              {
                type: "paragraph",
                text: "Процес обробки різних графічних даних з метою отримання кінцевого зображення, що відображається на моніторі (наприклад, в комп'ютерних іграх) передбачає здійснення величезної кількості точних розрахунків, створення піксельних блоків, операції освітлення, затінення, текстурування. Динаміка змін на картинці потребує високої швидкодії розрахунків."
              },
              {
                type: "image",
                src: "/images/image037.png",
                alt: "Рис 1.15. Відеокарта"
              },
              {
                type: "paragraph",
                text: "Комп'ютер не використовує окрему відеокарту (рис 1.15), якщо він має графічний процесор, інтегрований в системну логіку материнської плати (північний міст чипсета) або є частиною центрального процесора (наприклад, Intel i7). Такі компи дозволяють обробку нескладної графіки."
              },
              {
                type: "paragraph",
                text: "Чипсе́т (англ. chipset) — набір мікросхем, спроектованих для спільної роботи для забезпечення виконання певного набору заданих функцій."
              },
              {
                type: "paragraph",
                text: "Чипсет материнської плати забезпечує взаємодію центрального процесору (ЦП) з різними типами пам'яті, пристроями введення-виведення, контроллерами за допомоги багаторівневої шини. Чипсет визначає функціональність системної плати. Він включає в себе інтерфейс шини процесора і фактично визначає швидкодію процесору."
              },
              {
                type: "paragraph",
                text: "Сучасна графічна карта складається з наступних частин: графічний процесор (займається розрахунками та формуванням графічної інформації, що виводиться на монітор), відеопам'ять (тимчасове розміщення зображень), відеоконтролер (відповідає за правильне формування і передачу потрібної інформації з відеопам'яті на RAMDAC), цифро-аналоговий перетворювач (RAMDAC (Random Access Memory Digital-to-Analog Converter) пристрій перетворення цифрових результатів роботи відеокарти в аналоговий сигнал, який відображається на моніторі), відео-ПЗУ (Video ROM - мікросхема, що містить в сукупність правил і алгоритмів, визначених виробником, за яким складові частини відеокарти працюють і взаємодіють між собою, система охолодження."
              },
              {
                type: "paragraph",
                text: "На материнській платі, як правило, вмонтовані мережева та звукова карти, а також роз'єми для підключення оптичного (для запису/зчитування CD та DVD) і інших приводів. Для розширення можливостей комп'ютера в роз'єми РCI можливо встановлювати кілька типів пристроїв (модеми, ТВ-тюнери, Wi-Fi-адаптери, мережеві та звукові карти тощо)."
              },
              {
                type: "paragraph",
                text: "Звичайно, що для роботи всього обладнання материнки потрібен блок живлення."
              },
              {
                type: "paragraph",
                text: "Коротко охарактеризуємо додаткове зовнішнє обладнання комп'ютера."
              },
              {
                type: "paragraph",
                text: "Для роботи з текстовою інформацією, введення і редагування даних, а також керування виконанням окремих операцій використовується клавіатура (keyboard), зображена на рис.1.16."
              },
              {
                type: "image",
                src: "/images/image038.png",
                alt: "Рис.1.16. Клавіатура"
              },
              {
                type: "paragraph",
                text: "Маніпулятор типу «миша» (рис. 1.17) забезпечує візуальний інтерфейс управління обробкою виконавцем за використання спеціального маркера. Марер відображається на екрані монітора (дисплея)."
              },
              {
                type: "image",
                src: "/images/image040.png",
                alt: "Рис. 1.17. Маніпулятор типу «миша»"
              },
              {
                type: "paragraph",
                text: "Монітор – електронний пристрій візуального відображення інформації (рис 1.18)."
              },
              {
                type: "image",
                src: "/images/image041.png",
                alt: "Рис 1.18. Монітори"
              },
              {
                type: "paragraph",
                text: "Традиційно, акустичну систему для відтворення обробки звукової інформації забезпечують звукові динаміки (колонки). Принтер (рис. 1.19) використовується для друку на папері."
              },
              {
                type: "image",
                src: "/images/image042.png",
                alt: "Рис. 1.19. Принтер"
              }
            ]
          },
          {
            id: 4,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "Охарактеризуйте основні відмінності між дискретним (цифровим) і аналоговим принципом обробки інформації.",
                  "Приведіть класифікації та основні характеристики обчислювальних машин.",
                  "Загальна структура і принципи роботи цифрових обчислювальних машин.",
                  "Визначення та принципи роботи нейрокомп'ютера.",
                  "Функціональне призначення основних компонент апаратної частини комп'ютера."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 2,
        title: "Комп'ютерна мережа",
        topics: [
          {
            id: 1,
            title: "Комп'ютерні мережі та Інтернет",
            content: [
              {
                type: "heading",
                text: "Комп'ютерні мережі та Інтернет",
              },
              {
                type: "paragraph",
                text: "Комп'ютерна мережа це комп'ютери, з'єднані між собою лініями зв'язку. Зв'язок (комунікація) може бути дротовий, бездротовий, Bluetooth-ний, Wi-Fi-ний. Серед різних класифікацій комп'ютерних мереж виділяється поділ на локальні мережі та глобальні. У локальні мережі об'єднують комп'ютери, розміщені територіально не віддалено (в одному будинку чи одній організації). Декілька з'єднаних між собою локальних мереж утворюють глобальну мережу. Глобальні мережі зв'язують абонентів у межах країни, материку чи планети."
              },
              {
                type: "image",
                src: "/images/image043.png",
                alt: "Структура комп'ютерної мережі"
              },
              {
                type: "image",
                src: "/images/image045.png",
                alt: "Схема інтернет-мережі та карта підводних кабелів всесвітньої мережі"
              },
              {
                type: "paragraph",
                text: "Всесвітню систему сполучених комп'ютерних мереж, що базуються на комплекті спеціальних ІР-протоколів і передачі (маршрутизації) пакетів даних називають Інтернетом або мережею мереж. Інтернет складається з безлічі локальних і глобальних приватних, публічних, академічних, ділових і урядових мереж, пов'язаних між собою за допомоги різноманітних технологій комунікації. Він є фізичною основою для розміщення величезної кількості інформаційних ресурсів і послуг, таких наприклад як взаємопов'язані гіпертекстові документи Всесвітньої павутини (World Wide Web – WWW)."
              },
              {
                type: "paragraph",
                text: "Планетарна мережа WWW – найбільше світове багатомовне сховище інформації в електронному вигляді: десятки мільйонів пов'язаних між собою документів, що розташовані на комп'ютерах, розміщених по всій земній кулі. Вона вважається найпопулярнішою і найцікавішою службою мережі Інтернет, яка дозволяє отримувати доступ до інформації незалежно від місця її розташування. WWW– гіпертекстова, гіпермедійна, розподілена, інтегруюча, глобальна інформаційна система, якій не можна дати конкретного визначення."
              },
              {
                type: "image",
                src: "/images/image047.png",
                alt: "Логотип всесвітньої мережі"
              },
              {
                type: "paragraph",
                text: "WWW працює за принципом клієнт-сервер. Клієнтом може бути довільний комп'ютер користувача, а сервер – більш потужний виконавець. «Клієнт – сервер» (англ. client–server) позначає спеціальну обчислювальну або мережну архітектуру об'єднання обчислювальних засобів, в якій завдання та мережне навантаження розподілені між постачальниками послуг, які називаються серверами і замовниками послуг – клієнтами."
              },
              {
                type: "image",
                src: "/images/image048.png",
                alt: "Схема клієнт-серверної взаємодії"
              },
              {
                type: "paragraph",
                text: "Усі інформаційні ресурси в Internet однозначно адресуються за допомоги універсального вказівника на ресурс URL (uniform resource locator). До ресурсів Internet можна отримувати доступ і за IP-адресою певного комп'ютера. Через цю адресу та відповідне посилання обраного протоколу ми й доступаємося документу або сервісу. Допомагають нам це зробити спеціалізовані веб переглядачі – браузери."
              },
              {
                type: "paragraph",
                text: "Бра́узер (англ. browser) – програмне забезпечення для комп'ютера або іншого електронного пристрою, як правило, під'єднаного до Інтернету, що надає користувачеві можливість взаємодіяти з текстом, малюнками або іншою інформацією на гіпертекстовій веб-сторінці. Традиційно полегшує цю взаємодію мова розмітки гіпертексту HTML (hyper text markup language). HTML – це формат гіпермедійних документів для опису вмісту документу, його структури, а також зв'язків з іншими документами."
              },
              {
                type: "paragraph",
                text: "Гіпермедійність означає, що документ може містити текст, звук, графічне зображення, анімацію з можливістю переходу між фрагментами документу за спеціальними посиланнями. Зовнішній вигляд документа на екрані користувача визначається браузером. Імена файлів у форматі html, як правило, закінчуються на html (або мають розширення html у випадку, якщо сервер працює під Windows). Тобто, браузер є спеціальною програмою, яка розуміє і завантажує HTML-теги, показуючи результат обробки у власному вікні веб-сторінки."
              },
              {
                type: "paragraph",
                text: "Передачу гіпермедійного тексту між клієнтом і сервером забезпечує протокол HTTP (hypertext transfer protocol). Основною компонентою HTML є теги. Вони управляють вмістом сторінки – шрифтом тексту, фоном, їх кольором, визначенням посилань, вставкою графіки, аудіо та відео матеріалів. Власне, самих тегів при відображенні сторінки не видно – на екрані з'являється лише результати їх дій."
              },
              {
                type: "paragraph",
                text: "Гіпертекст (англ. Hypertext) – термін, який позначає принцип організації інформаційних одиниць, за якого окремі елементи (записи, документи і т. п.) зв'язані між собою асоціативними відносинами («гіперзв'язки» чи «гіперпосилання»), що забезпечують швидкий пошук інформації і/або перегляд даних, взаємопов'язаних зазначеними відносинами, активувавши посилання. Тобто, гіпертекст – це текстовий документ, який містить гіперпосилання (зв'язок слова з іншим ресурсом). Такі «пов'язані» слова документа виділяються із загального тексту за допомогою підкреслення лінією (в основному при наведенні на неї мишею). Особливо популярною ідея гіпертексту виявилася при об'єднанні цифрових даних на серверах усього світу."
              },
              {
                type: "image",
                src: "/images/image049.jpg",
                alt: "Концепція гіпертексту"
              },
              {
                type: "paragraph",
                text: "Доступний через WWW матеріал називають веб-сторінкою, а групи сторінок – веб-сайтами. Головну сторінку, яку користувач бачить при зверненні на який-небудь ресурс, називають стартовою або домашньою сторінкою (home page)."
              },
              {
                type: "paragraph",
                text: "Наразі кількість WWW-серверів невідома, оцінити її точно неможливо, а кількість же веб-сторінок, знайдених за допомогою пошукових сервісів вже давно перевищила за 1 мільярд. Найменшою одиницею гіпертекстових даних є веб-сторінка. Вона є мінімальним фрагментом гіпертексту, який можна завантажити і прочитати за один раз. Веб-сторінки містять безліч контенту від тексту і посилань на інші веб-сторінки до графіки та аудіовізуальних матеріалів. Для забезпечення знаходження і перегляду сторінки використовується URL. У ньому зберігається інформація: методи роботи з клієнтом і сервером; ім'я сервера, де розташована сторінка; шлях на якому знаходиться сторінка; ім'я сторінки."
              },
              {
                type: "image",
                src: "/images/image050.png",
                alt: "Структура адреси доступу"
              },
              {
                type: "paragraph",
                text: "Перший у світі веб-сайт був розміщений Бернерсом-Лі 6 серпня 1991 року на першому веб-сервері, що був доступний за адресою http://info.cern.ch/. Ресурс визначав основні поняття WWW, містив інструкції із встановлення веб-сервера, використання браузера тощо. Сайт був і першим у світі інтернет-каталогом, тому що там був розміщений і підтримувався список посилань на інші сайти."
              }
            ]
          },
          {
            id: 2,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "Дайте загальну характеристику комп'ютерної мережі.",
                  "Визначте основні компоненти мережі WWW.",
                  "Охарактеризуйте веб переглядачі – браузери.",
                  "Сформулюйте основні функції гіпертексту.",
                  "Приведіть ознаки веб-сторінки і веб-сайту."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 3,
        title: "Алгоритми",
        topics: [
          {
            id: 1,
            title: "Алгоритми",
            content: [
              {
                type: "heading",
                text: "Алгоритми"
              },
              {
                type: "paragraph",
                text: "Бурхливий розвиток науки і техніки в останні століття, спроби філософів найточніше описати різноманітні аспекти людського буття дали світові науку наук – логіку розвитку, яка породжувала задачі, що стимулювали появу нових ідей і методів їх розв'язання. Потреби суспільства в узагальненні багатьох підходів до розв'язання різноманітних задач зумовили створення спеціальної науки – теорії алгоритмів."
              },
              {
                type: "paragraph",
                text: "Складність і великий об'єм обчислень зумовили створення спеціалізованих обчислювальних пристроїв. Вони пройшли складний шлях розвитку. Серед них можна виділити один із найпотужніших класів – це електронно-обчислювальні машини (ЕОМ). Проникнення ЕОМ у різні сфери практичної діяльності людей значно вплинуло на еволюцію теорії алгоритмів, на вибір нових напрямів її застосування. Ця теорія перетворилась у певну школу мислення й аналізу для широкого кола програмістів, дала основу мові алгоритмів, яка об'єднує різні напрями досліджень у програмуванні, полегшує розповсюдження ідей вирішення проблем."
              },
              {
                type: "paragraph",
                text: "Слово алгоритм прийшло з Персії. Запропонував його автор книги з математики Abu Jafar Mohammed ibn Musa al Khowarizmi. Він визначав його як деяку спеціальну послідовність дій вирішення поставленої проблеми."
              },
              {
                type: "paragraph",
                text: "Поняття алгоритму належить до найскладніших концепцій природознавства. Воно пройшло складний історичний шлях розвитку, починаючи з інтуїтивного розуміння і стихійного застосування на перших кроках розвитку людського суспільства та закінчуючи усвідомленням закономірностей природних явищ, застосуванням у сучасних ЕОМ. Багато авторів визначають розвиток науки як безперервний процес уточнення алгоритмів і побудови відповідних моделей [4-7]."
              },
              {
                type: "paragraph",
                text: "Умовно можна виділити три основні етапи розвитку теорії алгоритмів."
              },
              {
                type: "paragraph",
                text: "На першому етапі відбувалося накопичення фактів людиною, що засвоювала знання про природу і стихійно формувала та закріплювала власні алгоритми поведінки."
              },
              {
                type: "paragraph",
                text: "Другий етап становлення алгоритмічного апарату пов'язаний з розвитком математичних наук. Для нього є характерним чітка побудова математичних алгоритмів розв'язання різних прикладних задач і опис значних алгоритмічних проблем, що не піддавались розв'язанню традиційними методами."
              },
              {
                type: "paragraph",
                text: "Третій період бере відлік з початку ХХ століття і продовжує розвиватися зараз. Він визначає побудову класичної теорії алгоритмів, яка за допомоги спеціальних формалізацій уточнювала можливості теоретичного обчислення для практичного застосування в кібернетиці й програмуванні."
              },
              {
                type: "paragraph",
                text: "Теорію алгоритмів можна поділити на класичну і прикладну. У класичній теорії алгоритмів існує безліч формалізацій для опису алгоритмів, прикладна – зорієнтована на вирішення конкретних задач у різноманітних предметних сферах."
              },
              {
                type: "paragraph",
                text: "З середини двадцятого століття почала бурхливо розвиватися інформатика. Інформатика – це наука про методи подання, накопичення, передачі і обробки інформації за допомогою електронно-обчислювальних машин (ЕОМ). Та, що ж це таке інформація?"
              },
              {
                type: "paragraph",
                text: "Незважаючи на те, що поняття інформації є основним поняттям всієї науки про обчислювальну техніку, на це питання не можливо дати однозначну відповідь. Поняття «інформація» в інформатиці схоже з поняттям «точка», «пряма» і «площина» в геометрії – все це невизначені терміни, про які можуть бути зроблені деякі твердження і висновки, але які не можуть бути пояснені в термінах більш елементарних понять."
              },
              {
                type: "paragraph",
                text: "Вважається, що інформація - це поняття, що передбачає наявність матеріального носія інформації, джерела і передавача інформації, приймача і каналу зв'язку між джерелом і приймачем інформації."
              },
              {
                type: "paragraph",
                text: "У загальній інформатиці досліджуються постановки задач, формалізації та уточнення їх розв'язку і проблеми програмування."
              },
              {
                type: "paragraph",
                text: "Основними в загальній інформатиці є три поняття: задача, алгоритм, програма. Відповідно, маємо три етапи в розв'язуванні задач: постановка задачі, побудова і обґрунтування алгоритму, складання і налагодження програми. Тобто, з точки зору інформатики розв'яззання задачі полягає у створенні програми для ЕОМ, яка реалізує алгоритм її розв'язку."
              },
              {
                type: "paragraph",
                text: "Оскільки програма – об'єкт гранично формальний, а тому точний, (можливо не завжди прозорий, навантажений неістотними із змістовної точки зору деталями, але недвозначний) то пов'язані з нею об'єкти також повинні бути точними. Алгоритм містить чіткий і ясний спосіб побудови результату за точно вказаній в постановці задачі залежності від наявних аргументів (вхідних даних)."
              },
              {
                type: "paragraph",
                text: "Спочатку з'ясуємо, що ми розуміємо під постановкою задачі."
              },
              {
                type: "paragraph",
                text: "Задачею можна назвати задання мети, якої потрібно досягнути. Ця мета може сформулюватися у вигляді доручення, завдання, питання, яке потрібно вирішити на базі певних знань і роздумів. Задачі класифікують (розподіляють) за різними ознаками, наприклад, математичні, ігрові, логічні, письмові."
              },
              {
                type: "paragraph",
                text: "В українській мові задання мети розв'язку має чіткий поділ на завдання і задачі. Завдання це наперед визначений обсяг робіт; якесь доручення; те, що хочуть здійснити, тощо. Задача – питання переважно математичного характеру, яке розв'язується шляхом обчислень за визначеною умовою методами математики."
              },
              {
                type: "paragraph",
                text: "Більшість математичних задач прийшли з реального світу але є і абстрактні, тобто сформульовані в межах самої математики. Для перетворення задачі реального світу в математичну, необхідно побудувати її математичну модель (описати предметну область цього світу математичними формалізаціями), а отриманий розв'язок витлумачити, тобто перевести з мови математики на мову відповідної області реального життя або природничої науки."
              },
              {
                type: "paragraph",
                text: "Приклади такого поділу приведені в таблиці 1.1."
              },
              {
                type: "image",
                src: "/images/image051.png",
                alt: "Таблиця 1.1. Приклади поділу на задачі та завдання"
              },
              {
                type: "paragraph",
                text: "Для розв'язання задач і завдань завжди потрібно щось зробити, тобто виконати якісь конкретні дії по досягненню мети згідно певної послідовності. Цю послідовність дій часто називають процесом."
              },
              {
                type: "paragraph",
                text: "Розв'язувати математичні задачі можна за використання певних методів, яких нас навчають відповідні підручники. Для вирішення завдань ми використовуємо здоровий глузд (просте завдання) або життєвий досвід (складне завдання), описаний у вигляді правил, інструкцій, меню. В них написано, що саме і в якому порядку треба зробити (опис дій), щоб розв'язати задачу чи завдання. Цей опис дій, які треба виконати, називається алгоритмом. Людина записує алгоритм, як правило, для однозначного подання її знань про розв'язання задачі чи вирішення завдання, тобто, для того, щоб подібні дії зміг виконати хтось інший."
              },
              {
                type: "paragraph",
                text: "Подібні описи обчислювальних процесів алгоритмічного характеру (арифметичні дії над цілими числами, знаходження найбільшого спільного дільника двох чисел тощо) відомі людству з глибокої давнини. Необхідність уточнення поняття алгоритму постала після усвідомлення неможливості знайти єдиний спосіб розв'язання для низки проблем. Для доведення відсутності алгоритму, дослідження узагальнених його властивостей потрібно більше зусиль. Це привело до виникнення теорії алгоритмів як окремого розділу математики."
              },
              {
                type: "paragraph",
                text: "Ще в XVII столітті вчені намагалися побудувати загальний алгоритм розв'язання будь-яких математичних задач. Побудувати такі алгоритми не вдавалося, і математики висунули припущення: а раптом для того чи іншого класу задач в принципі неможливо побудувати алгоритм рішення? На основі цього припущення з'явилося поняття алгоритмічно нерозв'язної задачі – задачі, для якої неможливо побудувати процедуру вирішення. Наприклад, людство і зараз не знає алгоритму точного визначення площі круга радіуса r. Багато з читачів скаже – потрібно застосувати формулу: S = πr2. Та пригадайте, чому рівне значення π (π = 3,141592 ...). Ми обираємо якесь обмеження кількості знаків у його представлені. Це і зумовлює наближене визначення площі круга."
              },
              {
                type: "paragraph",
                text: "Але виникає природнє запитання. Взагалі не існує розв'язку задачі (проблеми) або людство наразі ще не знайшло такого розв'язку. У першому випадку ми зазначаємо, що людство не знає відповідного алгоритму, не тільки зараз а його не можливо принципово знайти ніколи."
              },
              {
                type: "paragraph",
                text: "В теорії алгоритмів доведено існування таких класів задач, для розв'язання яких немає і не може бути єдиного універсального прийому. Проблеми розв'язання подібних задач називають алгоритмічно нерозв'язними проблемами. Однак для окремої, конкретної задачі із цього класу розв'язок може існувати. Сутність полягає у неможливості знаходження вирішення всіх завдань даного класу одним і тим самим прийомом. Знання про існування алгоритмічно нерозв'язних задач для програміста можна порівняти із потребою знання фізика про неможливість побудови вічного двигуна."
              },
              {
                type: "paragraph",
                text: "Отже, ми отримаємо вирішення алгоритмічної проблеми, якщо або знайдемо шуканий алгоритм, або доведем, що такого алгоритму не існує. Першою фундаментальною теоретичною працею, пов'язаною з доведенням алгоритмічної нерозв'язності, було дослідження (теорема) Курта Геделя про неповноту символічних логік. Гедель сформулював список таких проблем. Наразі перелік алгоритмічно нерозв'язних проблем значно розширений, а для доведення їх алгоритмічної нерозв'язності застосовувався принцип звідності до класичної задачі - «задачі зупину машини Т'юрінга». Тобто, фундаментально алгоритмічну нерозв'язність пов'язують з нескінченністю виконуваних алгоритмом дій, тобто неможливістю передбачити, що для будь-яких вихідних даних розв'язок буде отриманий за кінцеву кількість кроків."
              },
              {
                type: "paragraph",
                text: "Класичним прикладом нероз'язної проблеми є десята проблема Гільберта."
              },
              {
                type: "paragraph",
                text: "Нехай задано многочлен n-го ступеня з цілими коефіцієнтами й цілими показниками степенів – P (x1, x2,…, xn). Потрібно встановити існування алгоритму, який визначає, чи існує розв'язок рівняння P (x1, x2,…, xn) = 0 в цілих числах."
              },
              {
                type: "paragraph",
                text: "Тобто, маємо знайти універсальний метод цілочислового розв'язання довільного алгебраїчного діофантового рівняння. Доведення Ю. В. Матіясевичем алгоритмічної нерозв'язності цієї задачі зайняло близько двадцяти років."
              },
              {
                type: "paragraph",
                text: "Далі під алгоритмом ми будемо розуміти сукупність правил функціонування, що описують поведінку деякої системи, керуючись якими вона досягає кінцевого результату."
              },
              {
                type: "paragraph",
                text: "Алгоритм має скінченну множину кроків, кожен з яких може виконати одну або більше операцій. Операції мають бути однозначними та ефективними. Кожен крок слід виконувати за скінченний, у межах розумного, час. Алгоритм повинен мати хоча б один вихід і нуль або більше зовнішніх входів та закінчуватись після скінченного числа операцій."
              },
              {
                type: "paragraph",
                text: "Відомо, що всі визначення алгоритму еквівалентні щодо можливості моделювання обчислень. Форма задання алгоритму особливої ролі не відіграє, важливим є тільки вибір мінімальних засобів для задання і перетворення інформації."
              },
              {
                type: "paragraph",
                text: "Прикладна теорія алгоритмів спрямована на дослідження моделей алгоритмів. Тут під алгоритмом розуміють довільне перетворення обчислювальної інформації, яке може бути виражене за допомогою деякої алгоритмічної мови. Алгоритмічна мова буває різного типу складності. У зв'язку з обчислюванням алгоритмів на комп'ютерах виберемо як форму запису алгоритму мову JavaScript."
              },
              {
                type: "paragraph",
                text: "Отже, алгоритм – точне формальне розпорядження, яке однозначно визначає зміст і послідовність операцій, що переводять задану сукупність початкових даних в шуканий результат або можна також сказати, що алгоритм - це скінена послідовність загальнозрозумілих розпоряджень, формальне виконання яких дозволяє за кінцевий час отримати рішення деякої задачі або будь-якої задачі з деякого класу задач."
              },
              {
                type: "paragraph",
                text: "Розглянемо відому задачу про людину з човном (позначимо Л), вовком (позначимо В), козою (позначимо Кз) і капустою (позначимо Кп). Нехай, фермеру потрібно одного берега річки на іншій перевезти човном вовка, козу і капусту. Човен витримує лише човняра і одного з кандидатів на перевезення. Із зрозумілих причин, одночасно не можна залишати разом на березі вовка і козу (вовк може з'їсти козу), козу і капусту (коза з'їсть капусту). Але можна робити скількох завгодно перевезень – рейсів човна між берегами."
              },
              {
                type: "paragraph",
                text: "Алгоритм її розв'язування можна формалізувати (представити) таким чином:"
              },
              {
                type: "list",
                items: [
                  "початковий стан, який характеризує знаходження на березі людини, вовка і капусти, позначимо так: { Л, В, Кз, Кп → };",
                  "1-й крок, вказує на те, що фермер має взяти у човен козу і капусту та попливти на другий берег, залишивши вовка. Позначимо цю дію так {В → Л, Кз, Кп};",
                  "2-й крок, говорить про те, що фермер має, перемістивши капусту на берег, залишити козу в човні і плисти за вовком. Позначимо цю дію так: { В, Л, Кз ← Кп };",
                  "3-й крок, каже про те що фермер має залишити козу на березі, забрати в човен вовка і перевезти вовка на другий берег та залишити його там. Позначимо цю дію так: { Кз → Л, В, Кп };",
                  "4-й крок, вказує на те що фермер повертається за козою. Позначимо цю дію так: { Л, Кз ← В, Кп };",
                  "5-й, останній крок, рекомендує фермеру забирати козу і переправляти її на другий берег. Позначимо його так: {→ Л, В, Кз, Кп }."
                ]
              },
              {
                type: "paragraph",
                text: "Тобто, скорочено алгоритм можна записати так:"
              },
              {
                type: "list",
                items: [
                  "Вхід: { Л, В, Кз, Кп → };",
                  "1-й крок. { В → Л, Кз, Кп };",
                  "2-й крок. { В, Л, Кз ← Кп };",
                  "3-й крок. { Кз → Л, В, Кп };",
                  "4-й крок. { Л, Кз ← В, Кп };",
                  "Вихід: { → Л, В, Кз, Кп }."
                ]
              },
              {
                type: "paragraph",
                text: "Для наочності запису, уточнення розуміння визначення наступного кроку виконання алгоритму елементарні кроки алгоритму можливо об'єднати. Зрозуміло, що такими композиціями (алгоритмічними конструкціями) є конструкції послідовного виконання, розгалуження на гілки виконання, циклічне (повторне виконання), та допоміжні алгоритми. У середині шістдесятих років минулого століття було доведено, що для запису алгоритму довільної складності достатнім є використання лише трьох алгоритмічних конструкцій задання управління: послідовне, розгалуження і циклічна."
              },
              {
                type: "paragraph",
                text: "Кажуть, що деякий набір кроків алгоритму об'єднаний в послідовну алгоритмічну конструкцію (крок за кроком послідовно), якщо кожен крок з цього набору виконується один раз, причому після кожного i-го кроку виконується (i + 1)-й крок, якщо i-й крок – не кінець набору. Таке управління обробкою кроків ще називають лінійним. Зрозуміло, що ця конструкція може задавати і весь алгоритм. Прикладом лінійного алгоритму є наш алгоритм про перевезення вовка, кози і капусти."
              },
              {
                type: "image",
                src: "/images/image052.png",
                alt: "Рис.1.24. Графічна ілюстрація конструкції послідовного виконання"
              },
              {
                type: "paragraph",
                text: "Кажуть, що деякий набір кроків алгоритму об'єднаний в алгоритмічну конструкцію розгалуження, якщо вибір наступного кроку виконання визначається даними алгоритму доступними (обчисленими в алгоритмі) на момент вибору наступного кроку виконання алгоритму. Розгалуження задає виконання або однієї, або іншої групи операторів в залежності від виконання певної умови (в залежності від істинності чи хибності умови, яка накладається на певні доступні дані алгоритму). Потім виконання алгоритму виходить на загальне продовження. Для конкретних вхідних даних конструкція розгалуження вироджується в конструкцію послідовного виконання, тому що виконується тільки одна із гілок розгалуження. Розгалуження буває повним і неповним. У разі неповного розгалуження при невиконанні умови ніякі дії не виконуються, а управління передається на обробку наступного оператора."
              },
              {
                type: "paragraph",
                text: "Для прикладу повного розгалуження розглянемо такий фрагмент алгоритму. Нехай на деякому кроці алгоритму, який маніпулює з двома різними цілими числами. Для зручності маніпулювання та розуміння сутності об'єктів маніпулювання позначимо їх відповідно іменами (змінними) Ч1 і Ч2. Програмісту потрібно описати фрагмент алгоритму знаходження більшого серед них (позначимо це число іменем (змінною) МАХ. Уведення змінних дозволяє використовувати цей фрагмент алгоритму для знаходження максимального елементу для довільних двох сисел. Фрагмент реалізується такою конструкцією розгалуження:"
              },
              {
                type: "paragraph",
                text: "«Якщо Ч1 більше (>) Ч2 тоді МАХ стане рівним (:=) Ч1 інакше МАХ стане рівним (:=) Ч2»."
              },
              {
                type: "image",
                src: "/images/image053.png",
                alt: "Графічна ілюстрація конструкції повного та неповного розгалуження "
              },
              {
                type: "paragraph",
                text: "Якщо ж якусь дію потрібно виконати за виконання якоїсь умови, тоді користуються неповним оператором. Наприклад, нехай в попередньому алгоритмі потрібно після визначення більшого числа у випадку коли значення МАХ менше 100, зробити МАХ рівним 200. Цей фрагмент алгоритму реалізується такою конструкцією розгалуження:"
              },
              {
                type: "paragraph",
                text: "«Якщо МАХ менше (<) 100 тоді МАХ стане рівним (:=) 200»."
              },
              {
                type: "paragraph",
                text: "Кажуть, що деякий набір кроків алгоритму об'єднаний у циклічну алгоритмічну конструкцію (повторення), якщо якусь послідовну конструкцію (групу кроків) або один крок алгоритму, потрібно виконати кілька разів. Кількість повторень або фіксована, або залежить від доступних у цій точці управління даних алгоритму. Сутність циклічної конструкції полягає в наступному. Після чергового виконання (називається кроком циклу, або ітерацією) послідовної групи кроків, які входять в цикл (ця група називається тілом циклу), перевіряється деяка умова відносно значень параметра циклу, що формується в процесі обчислень. Залежно від значення цієї умови цикл або завершується, або починається виконання наступного кроку циклу."
              },
              {
                type: "paragraph",
                text: "Як приклад використання алгоритму з циклічною конструкцією припустимо, що далі в нашому алгоритмі потрібно значення позначене МАХ збільшити на значення рівне цілому числу, позначеному змінною Ч1, стільки раз поки МАХ не стане більшим 1000."
              },
              {
                type: "paragraph",
                text: "Таку послідовність дій буде описувати така циклічна конструкція:"
              },
              {
                type: "paragraph",
                text: "«Цикл (якщо МАХ менше (<) 1000) тоді МАХ зробить рівним (:=) МАХ + Ч1»."
              },
              {
                type: "image",
                src: "/images/image054.png",
                alt: "Графічна ілюстрація циклічної конструкції"
              },
              {
                type: "paragraph",
                text: "Конструкції слідування, розгалуження і циклу називають базовими конструкціями структурного програмування. Їх характерною особливістю є наявність тільки одного входу і одного виходу. Це дає змогу простого вкладення однієї конструкції в іншу для опису різноманітного управління обробкою окремих кроків у алгоритмі."
              },
              {
                type: "paragraph",
                text: "Як бачимо, алгоритм по формі задання можна уявляти як певний абстрактний (уявний) об'єкт. Тому він вимагає абстрактного (уявного) виконавця. Визначення цього виконавця з уточненням базових дій (операцій), які може виконувати виконавець по суті дає операційну семантику (сутність) алгоритмічної мови (мови запису алгоритму). Модифікація алгоритмічної мови, очевидно, вимагає відповідної зміни іншого математичного об'єкта - виконавця."
              },
              {
                type: "paragraph",
                text: "Отже, виконавцем ми будемо називати пристрій, здатний виконувати дії із заданого набору дій. Команду на виконання окремої дії звичайно називають оператором або інструкцією. Приклади виконавців: пральна машина, телефон, мікрокалькулятор, магнітофон, комп'ютер тощо. Приклади інструкцій: набрати воду, перемотати плівку, встановити з'єднання із заданим номером, знайти суму двох чисел і т.п."
              },
              {
                type: "paragraph",
                text: "Відзначимо особливості виконавців."
              },
              {
                type: "list",
                items: [
                  "По-перше, людина далеко не єдиний виконавець алгоритмів.",
                  "По-друге, будь-який виконавець складається з пристрою управління і «робочого інструмента виконання».",
                  "По-третє, кожний виконавець алгоритмів володіє обмеженим набором допустимих дій (описати виконавця - значить указати його допустимі дії). Кожний виконавець може розуміти і виконувати якесь порівняно невелике число різних елементарних команд. З цих команд складаються алгоритми. З цього невеликого числа команд можна скласти невелику учбову програму, а можна і складну програму з тисяч команд.",
                  "По-четверте, для рішення одних і тих же задач виконавці з «біднішим» набором допустимих дій вимагають складніших і докладних алгоритмів.",
                  "По-п'яте, різні класи задач вимагають різних наборів допустимих дій, різних виконавців."
                ]
              },
              {
                type: "paragraph",
                text: "Розглянемо приклад найпростішого виконавця, який назвемо «Обчислювач». Він уміє: множити число на 2 (позначатимемо «*2»); збільшувати число на 1 (позначатимемо «+1»). Потрібно скласти алгоритм отримання числа 100 з одиниці. Скільки дій у самому короткому з таких алгоритмів?"
              },
              {
                type: "paragraph",
                text: "Розглянемо простішу задачу отримання з одиниці числа 4. Для її рішення можна використати алгоритм, що містить таку послідовність операцій « +1 (+1) (+1) (+1)» або алгоритм « +1 (*2) (*2)». Очевидно, що другий алгоритм коротший. Тут початкове « +1 » позначає збільшення нуля на одиницю."
              },
              {
                type: "paragraph",
                text: "Повернемося до початкової задачі. Для отримання найкоротшого алгоритму перетворюємо число 100 у 1 використовуючи ділення на 2 і віднімання 1. Маємо:"
              },
              {
                type: "paragraph",
                text: "100 -> 50 -> 25 -> 24 -> 12 -> 6 -> 3 -> 2 -> 1."
              },
              {
                type: "paragraph",
                text: "Отже, для нашого виконавця алгоритм « 1 (*2) (+1) (*2) (*2) (*2) (+1) (*2) (*2)» буде найбільш коротким і містить 8 дій."
              },
              {
                type: "paragraph",
                text: "Для запису алгоритмів в залежності від орієнтації на виконавця та типу задачі розв'язання вживають різні форми запису: природну мову спілкування розробника (-ів), блок-схему, програму на обраній алгоритмічній мові, математичний формалізм (алгебра, машина Тьюринга і ін.)."
              },
              {
                type: "paragraph",
                text: "Для уточнення форм запису алгоритму для виконавця «Людина» за допомоги «природної» української мови розглянемо наступний приклад."
              },
              {
                type: "paragraph",
                text: "Маленькому Андрійку потрібно розв'язати задачу про пірамідку. Постановку задачі можна сформулювати таким чином. Нехай сестричка перевернула пірамідку з трьох кілець різного розміру. Андрійку потрібно відновити піраміду, розмістивши кільця так, щоб кільце більшого розміру не лежало зверху кільця меншого розміру і всі кільця були розміщені."
              },
              {
                type: "image",
                src: "/images/image056.png",
                alt: "Кільця, стрижень і пірамідка"
              },
              {
                type: "paragraph",
                text: "Виконавець «Андрійко» вміє робити чотири допустимі дії: знаходити кільця і стрижень, порівнювати кільця за розміром, насаджувати кільце на стрижень, показувати пірамідку батькам. Спробуємо допомогти Андрійку, надавши йому настанову (інструкцію) у вигляді алгоритму розміщення кілець, описаного природною (українською) мовою за допомогою такої послідовності дій:"
              },
              {
                type: "list",
                items: [
                  "Ввести до розгляду 3 кільця різного розміру і стрижень піраміди (знайти кільця і стрижень).",
                  "Вибрати з 3 кілець найбільше і перемістити на стрижень.",
                  "Вибрати з 2 кілець що залишилися більше і перемістити його на стрижень.",
                  "Перемістити на стрижень кільце, що залишилося.",
                  "Вивести на друк розсипані кільця і наповнений стрижень (показати пірамідку батькам).",
                  "Кінець алгоритму."
                ]
              },
              {
                type: "paragraph",
                text: "Та назвати це алгоритмом ще не можна. Не виконується умова чіткої визначеності (однозначності розуміння) окремих інструкцій. Давайте спробуємо їх уточнити."
              },
              {
                type: "paragraph",
                text: "Почнемо з: Ввести до розгляду 3 кільця різного розміру і стрижень піраміди."
              },
              {
                type: "paragraph",
                text: "Найперше потрібно звернути увагу на те, що нам потрібно якось розрізняти звертання до кожного з них окремо. Для цього перше кільце позначимо ім'ям К1, друге – К2, третє – К3, а позиції стрижня піраміди іменами – С1 (перша позиція стрижня), С2 (друга позиція стрижня), С3 – відповідно третя."
              },
              {
                type: "paragraph",
                text: "Далі уточнимо, як відмітити різний розмір кілець. Для позначення величини розміру давайте використаємо цілі числа. Більший розмір кільця визначатиме більше число. Наприклад, це можна позначити так: К1:=3, К2:=7, К3:=5, де позначення «:=» читатимемо як «присвоїти (покласти рівним)»."
              },
              {
                type: "paragraph",
                text: "Тоді інструкція: Ввести до розгляду 3 кільця різного розміру і стрижень піраміди. Прийме вигляд:"
              },
              {
                type: "paragraph",
                text: "(Ввести до розгляду 3 кільця різного розміру) К1:=3, К2:=7, К3:=5 (і позначити рівні стрижня піраміди) С1,С2,С3."
              },
              {
                type: "paragraph",
                text: "Аналогічно уточнимо інструкції, що реалізують підалгоритм вибору найбільшого кільця спочатку з трьох кілець а потім більшого з двох кілець:"
              },
              {
                type: "list",
                items: [
                  "Вибрати з 3 кілець найбільше і перемістити на стрижень.",
                  "Вибрати з 2 кілець що залишилися більше і перемістити його на стрижень.",
                  "Перемістити на стрижень кільце, що залишилося."
                ]
              },
              {
                type: "paragraph",
                text: "Тоді, враховуючи наші позначення та здоровий глузд, наш підалгоритм прийме вигляд:"
              },
              {
                type: "code",
                language: "",
                code: "Початок\nЯкщо К1 більше (>) К2 тоді\n  Якщо К1 більше (>) К3 тоді\n           Початок\n                На третій рівень стрижня перенести К1:  C3:=K1;\n                К1 присвоїти значення K3 для вибору із двох кілець,\n                що залишилися:     К1:=K3;\n        Кінець\n      Інакше\n                На третій рівень стрижня перенести К3:  C3:=K3;\n     Інакше (це випадок коли К1 менше К2)\n          Якщо    K2 більше (>) K3 тоді\n                  Початок\n                    На третій рівень стрижня перенести К2:  C3:=K2;\n                    К2 присвоїти значення K3 для вибору із двох кілець,\n                    що залишилися:     К2:=K3;\n                   Кінець\n               Інакше\nНа третій рівень стрижня перенести К3:  C3:=K3;\n\n    Якщо    K1 (>) K2 тоді\n          Початок\n                    На другий рівень стрижня перемістити К2: C2=K2;\n                    На перший рівень стрижня перемістити К1: C1=K1\n          Кінець\n     Інакше\n       Початок\n                    На другий рівень стрижня перемістити К1: C2=K1;\n                    На перший рівень стрижня перемістити К2: C1=K2\n                   Кінець\n    Кінець"
              },
              {
                type: "paragraph",
                text: "Нарешті, уточнимо інструкцію:"
              },
              {
                type: "paragraph",
                text: "4.Вивести на друк розсипані кільця і наповнений стрижень (відновлену піраміду)."
              },
              {
                type: "paragraph",
                text: "Вона перетвориться в послідовність дій:"
              },
              {
                type: "list",
                items: [
                  "Вивести на друк К1;",
                  "Вивести на друк К2;",
                  "Вивести на друк К3;",
                  "Вивести на друк С3;",
                  "Вивести на друк С2;",
                  "Вивести на друк С1;"
                ]
              },
              {
                type: "paragraph",
                text: "Крок Кінець алгоритму зрозумілий – залишимо без уточнень."
              },
              {
                type: "paragraph",
                text: "Тоді наш алгоритм прийме вигляд."
              },
              {
                type: "code",
                language: "",
                code: "Вхід. (Ввести до розгляду 3 кільця різного розміру) К1=3, К2=7, К3=5 (і позначити рівні стрижня піраміди) С1,С2,С3.\nПочаток\nЯкщо К1 більше (>) К2 тоді\n  Якщо К1 більше (>) К3 тоді\n           Початок\n               На третій рівень стрижня перенести К1:  C3:=K1;\n               К1 присвоїти значення K3 для вибору із двох кілець,\n               що залишилися:     К1:=K3;\n        Кінець\n      Інакше\n                На третій рівень стрижня перенести К3:  C3:=K3;\n     Інакше (це випадок коли К1 менше К2)\n          Якщо    K2 більше (>) K3 тоді\n                  Початок\n                    На третій рівень стрижня перенести К2:  C3:=K2;\n                    К2 присвоїти значення K3 для вибору із двох кілець,\n                    що залишилися:     К2:=K3;\n                   Кінець\n               Інакше\nНа третій рівень стрижня перенести К3:  C3:=K3;\n\n    Якщо    K1 (>) K2тоді\n          Початок\n                    На другий рівень стрижня перемістити К2: C2=K2;\n                    На перший рівень стрижня перемістити К1: C1=K1\n          Кінець\n     Інакше\n       Початок\n                    На другий рівень стрижня перемістити К1: C2=K1;\n                    На перший рівень стрижня перемістити К2: C1=K2\n                   Кінець\n\nВивести на друк К1;\nВивести на друк К2;\nВивести на друк К3;\nВивести на друк С3;\nВивести на друк С2;\nВивести на друк С1;\nКінець алгоритму."
              },
              {
                type: "paragraph",
                text: "Якщо уважно подивитися на таке задання алгоритму, то можна виділити основні недоліки такого опису – громіздкість і погана наочність. Для їх усунення використовують спеціалізовані формалізми: блок-схеми, мови програмування тощо."
              },
              {
                type: "paragraph",
                text: "Блок-схема алгоритму - це графічний опис алгоритму у вигляді послідовності дій, які реалізуються відповідними функціональними блоками схеми. Порядок виконання дій вказується стрілками."
              },
              {
                type: "paragraph",
                text: "У схемі алгоритму кожному типу дій відповідає окремий тип геометричної фігури. Фігури з'єднуються лініями переходів, що визначають передачу управління від блоку до блоку. Для фіксації початку і кінця алгоритму використовують еліпси, між якими знаходяться функціональні блоки, з'єднаних лініями із стрілками. Команда, що реалізує якусь дію обробки поміщається в прямокутник. Умовний вираз що задає умову розгалуження управління розміщується в ромбі. З ромба завжди виходять дві стрілки – одна означає подальший шлях у разі позитивного задоволення умови (позначається зазвичай словом \"так\" або \"+\"), інша – невиконання (слово \"ні\" або \"-\"). Введення з клавіатури даних або виведення значення результату на екран розміщується в паралелограм."
              },
              {
                type: "paragraph",
                text: "Наприклад, наш алгоритм поновлення башти кільцями можна описати блок-схемою, яку зображено на рис. 1.28."
              },
              {
                type: "image",
                src: "/images/image059.png",
                alt: "Рис. 1.28. Блок-схема алгоритму"
              },
              {
                type: "paragraph",
                text: "Тобто, блок-схема є зв'язним орієнтованим графом, вузли якого мо-жуть бути блоками чотирьох типів: блок ініціалізації (косий чотирикут-ник), функціональні блоки (прямокутники),   блоки умов (ромби) і блок початку або  закінчення обробки інформації (косий чотирикутник)."
              },
              {
                type: "paragraph",
                text: "Кожен блок належить певному шляху з початкового блоку в кін-цевий. Передачу керування між блоками визначають напрямленими стрілками. Умовний блок використовують для розгалуження керування (умовної передачі керування). Він функціонує так: якщо умова, що сто-їть в середині ромба, справджується (набуває значення «істина», поз-начається «+»), то керування передається правому блоку, якщо ж умо-ва не справджується (набуває значення «хибність», позначається «-»), тоді керування передається лівому блоку."
              },
              {
                type: "paragraph",
                text: "Мови програмування (англ. programming language) — це штучна мова, створена для опису алгоритмів, зручна для переведення інструк-цій алгоритмів у команди виконавця (обчислювача), зокре-ма комп'ютерам.  Тобто, це система позначень, певна штучна формаль-на система, засобами якої можна виражати алгоритми. Як і довільну мову, її визначає фіксований на-бір лексичних, синтаксичних і семантичних правил, що задають зовні-шній вигляд програми і дії, які виконує виконавець (комп'ютер) під її управлінням. Наразі існує   понад дві з половиною тисячі мов програ-мування. Серед них виділяють широко розповсюджені і використову-вані тисячами а то й   мільйонами  користувачів і вузько-спеціалізовані, які використовують десятки або сотні користувачів. Більшість мов про-грамування зорієнтовані на спеціальні сфери застосування. Але існу-ють і універсальні мови програмування."
              },
              {
                type: "subheading",
                text: "Висновки"
              },
              {
                type: "list",
                items: [
                  "Виконання алгоритму розбивається на послідовність скінчен-них дій-кроків. Тільки виконавши одну дію (команду), можна присту-пати до виконання наступної. Цю властивість алгоритму називають дискретністю.",
                  "Зрозумілість – алгоритм не повинен містити неоднозначних приписів, які б викликали  у виконавця   потребу в ухваленні будь-яких власних рішень.",
                  "Детермінованість – кожна команда алгоритму визначає одно-значно дію виконавця, а виконавець  має  однозначно визначати насту-пний крок виконання.",
                  "Результативність - виконання алгоритму має закінчитися за кі-нцеве число кроків. Отриманий результат рішення задачі може бути і повідомленням про те, що задача  рішень не має.",
                  "Застосовність – алгоритм придатний для розв'язання  задачі на будь-яких даних із  області визначення вхідних даних задачі."
                ]
              },
              {
                type: "paragraph",
                text: "Далі ми будемо дотримуватися такого визначення."
              },
              {
                type: "paragraph",
                text: "Алгоритм – зрозуміле і точне розпорядження виконавцю на ви-конання  скінченної послідовності дій, які  призводять від вхідних да-них до шуканого результату."
              }
            ]
          },
          {
            id: 2,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "subheading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "Приведіть три основні етапи розвитку теорії алгоритмів",
                  "Що таке «інформація» в інформатиці.",
                  "Охарактеризуйте поділ на завдання і задачі.",
                  "Як визначається розв'язок математичної задачі.",
                  "Приведіть різні визначення алгоритму.",
                  "Охарактеризуйте особливості виконавців.",
                  "Модифікуйте (підправте, допишіть) алгоритм складання піраміди з трьох кілець для вирішення задачі про можливість побудови трикутника із трьох відрізків. Умова можливості побудови така. Сума довжин двох відрізків більша за довжину найбільшого відрізка.",
                  "Задайте алгоритм визначення можливості побудови трикутника із трьох відрізків за допомоги блок-схеми."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 4,
        title: "Програми",
        topics: [
          {
            id: 1,
            title: "Основи програмування",
            content: [
              {
                type: "heading",
                text: "Основи програмування"
              },
              {
                type: "paragraph",
                text: "Запис алгоритму у словесній формі і у вигляді блок-схеми до-зволяє певну свободу при відображенні окремих дій, яка не може одно-значно трактуватись виконавцем. Тому алгоритм, призначений для окремого типу виконавця, повинен бути записаний «зрозумілою» для нього мовою, яка може трансформуватись у мову команд виконавця і не залишає місця для довільного тлумачення їх виконавцем. Отже, мо-ва для запису алгоритмів має бути максимально формалізована."
              },
              {
                type: "paragraph",
                text: "Як ми зазначали, рецепти приготування страв, нотні записи му-зичних творів, і опис того, як обчислити траєкторію польоту космічно-го корабля на Місяць, – усе це алгоритми. Тих, хто створює алгорит-ми, у широкому розумінні, називають програмістами, а тих, хто вико-нує дії – виконавцями. Отже, програмістами можна вважати і компози-тора, і автора рецептів приготування борщу. Відповідно музиканти, що виконують музикальні твори за нотним записом, господарки, що готують борщ за рецептом, і комп’ютер , що обчислює траєкторію по-льоту космічного корабля– виконавці."
              },
              {
                type: "paragraph",
                text: "Як влучно помітив А.П. Єршов, «програміст повинен володіти здатністю першокласного математика до абстракції і логічного мис-лення в поєднанні з едісонівським талантом до створення чого-небудь з нуля і одиниці» (А.П. Єршов \"Людський чинник у програмуванні\")."
              },
              {
                type: "paragraph",
                text: "Важливою складовою цього процесу є взаєморозуміння програ-міста і виконавця. Програміст має дбати щоб виконавець зміг зрозумі-ти і власними засобами виконати зазначені у алгоритмі дії. Систему запису, призначену для передачі якогось змісту, називають мовою. Існує декілька визначень мови. Приведемо декілька з них, скориставшись Ві-кіпедією."
              },
              {
                type: "list",
                items: [
                  "Мо́ва — система звукових і графічних знаків, що виникла на певному рівні розвитку людства, розвивається і має соціальне приз-начення; правила мови нормалізують використання знаків та їх функціонування як засобів людського спілкування.",
                  "У системах обробки інформації мова – природна або штуч-на знакова cистема для передачі інформації.",
                  "Алгоритмічна мова – штучна мова, призначена для напи-сання алгоритмів.",
                  "Командна мова – набір процедурних операндів із встанов-леним синтаксисом, що використовуються для вказівки на функції, які повинні бути виконані операційною системою.",
                  "Машинна мова — мова програмування, призначена для подання програм у формі, що дозволяє виконувати їх безпосередньо технічними засобами обробки даних виконавця."
                ]
              },
              {
                type: "paragraph",
                text: "Тому, алгоритмом можна вважати запис певної послідовності дій, представленим за правилами деякої мови. Запис алгоритму засо-бами цієї мови, призначеного для виконання якимсь виконавцем, нази-вають програмою. Для запису програм у цій книзі ми будемо викори-стовувати мову програмування JavaScript."
              },
              {
                type: "paragraph",
                text: "З далекої давнини людині приходиться створювати описи певної послідовності дій, потрібних для досягнення поставлених цілей. Такі описи можуть бути розраховані на їх виконання людиною або спеціалі-зованим пристроєм. Тексти, написані для людей, як правило, мають деяку міру невизначеності і неформальності. Прикладом може служити фраза із кулінарного рецепту «… покладіть у каструлю дрібку солі…». Використання таких фраз зорієнтовано на певний досвід людини. Він дозволяє уточнити що розуміти під «дрібкою солі»."
              },
              {
                type: "paragraph",
                text: "Тому опис послідовності дій, призначений для автоматичного пристрою, має бути цілком однозначним й заданим за допомоги деякої формальної системи позначень. Дуже часто створення таких описів по-в'язано зі значними технологічними і принциповими труднощами. Ця проблема стала надзвичайно актуальною у зв’язку з поширенням елек-тронних обчислювальних машин (ЕОМ), які використовують в якості універсального виконавця команд."
              },
              {
                type: "paragraph",
                text: "Дамо, ще одне визначення алгоритму. Опис послідовності дій, достатньо визначений для його виконання за допомоги деякого авто-матичного пристрою називають алгоритмом. Традиційно цю послідо-вність записують (кодують) з допомогою деяких формальних позна-чень. При цьому формальну систему, призначену для запису алгорит-мів, називають алгоритмічною мовою, сам текст алгоритму – програ-мою, а процес його створення – програмуванням."
              },
              {
                type: "paragraph",
                text: "Наука програмування (computer science) займається дослідженням властивостей програм і розробкою методів побудови програм. За змі-стом і методикою вона є областю прикладної математики."
              },
              {
                type: "paragraph",
                text: "Перед тим, як перейти безпосередньо до прикладів програм, об-говоримо питання про те, якими якостями повинна володіти хороша програма."
              },
              {
                type: "paragraph",
                text: "Виявляється, що таких властивостей достатньо багато: корект-ність, ефективність, зручність експлуатації, надійність, зручність су-проводу, зрозумілість і т.п. Найголовнішими із них є коректність (пра-вильність), ефективність, наочність і модифікованість."
              },
              {
                type: "paragraph",
                text: "Тому, що програма насамперед є формою запису алгоритму рі-шення визначеної задачі, вона найперше повинна бути правильною, тобто реалізувати вірно алгоритм рішення початкової задачі. Виявля-ється, що не так просто не тільки навчитися писати правильні програ-ми, а навіть просто сформулювати, що це таке."
              },
              {
                type: "paragraph",
                text: "Питання ефективності програми тісно зв’язані з поняттям оп-тимального використання пам’яті та часових затрат отримання ре-зультату. Тобто бажано використовувати швидкі алгоритми. Напри-клад, час роботи швидкої і звичайної програми, що впорядковують за зростанням мільйон цілих чисел, відрізняються в 50000 разів!"
              },
              {
                type: "paragraph",
                text: "Властивості розуміння і модифікації програм пов’язані дуже тіс-но: важко змінити програму, яку не розумієш. Отже текстовий вигляд запису програми має бути легко читабельним і зрозумілим. В реаль-ному житі програміста задачі модифікації вже написаних кимось рані-ше програм зустрічаються практично нарівні з задачами розробки програм з нуля. Тому мова повинна мати зручні засоби модифікації чиєїсь програми."
              },
              {
                type: "paragraph",
                text: "Програмування в цілому є як мистецтвом, так і певним ремеслом, що характеризується визначеними етапами і способами створення програми та формами організації взаємодії між розробниками, які ба-зуються на обраних парадигмах та технологіях."
              },
              {
                type: "paragraph",
                text: "Парадигмою програмування називають деякий взаємопов'язаний набір ідей і рекомендацій, що визначають стиль написання програм і бачення розробника процесу виконання програми. Наразі виділяють декілька основних парадигм: імперативне, процедурне, об'єктно-орієнтоване, логічне і функціональне програмування."
              },
              {
                type: "paragraph",
                text: "Наприклад, в ООП програма розглядається як набір взаємодію-чих об'єктів, тоді як у імперативній парадигмі виконавцю програми чітко вказується послідовність виконуваних дій по зміні станів пам’яті. Успішність застосування обраної парадигми для програмної реалізації для визначеного типу алгоритмів суттєво залежить від вибору мови програмування."
              },
              {
                type: "list",
                items: [
                  "уточнення способів організації даних – потрібних структур і типів даних,",
                  "розробка алгоритму,",
                  "запис алгоритму обраною мовою програмування,",
                  "тестування,",
                  "налагодження,",
                  "документування програми."
                ]
              },
              {
                type: "paragraph",
                text: "Для оптимізації розробки складних програм використовуються спеціальні технології програмування. Документація описує основні складові програми, функціональні зв’язки цих складових, особливості вимог до вхідних даних, вимоги до виконавця та програмного забезпе-чення установленого на виконавці та пояснення вихідних результатів."
              },
              {
                type: "paragraph",
                text: "Налагодження програми - це діяльність, спрямована на виявлен-ня та виправлення помилок в програмі. Виділяють синтаксичні і семан-тичні помилки в програмі. Перший тип помилок пов’язаний із помил-ковим використанням правил запису конструкцій обраної мови про-грамування. Їх виявити допомагають компілятори, транслятори і інте-рпретатори. Семантичні помилки виникають з помилковості алгоритму розв’язку задачі або із невірності використання засобів мови програ-мування при реалізації певних фрагментів цього алгоритму. Другий тип помилок знайти тяжче. В основному для їх виявлення потрібно тес-тувати програму на різних вхідних даних."
              },
              {
                type: "paragraph",
                text: "Розробник отримує повідомлення про помилку, виправляє її і знову повторює спробу виконати програму."
              },
              {
                type: "paragraph",
                text: "Тестування програми - це процес відлагодження програми шля-хом її запуску на деякому наборі даних, для якого заздалегідь відо-мий результат, отриманий іншим чином (не програмно). Цей набір да-них називається тестовим або тестом. Та як зазначав Дейкстра, за до-помоги тестування можна знайти тільки помилки в програмі і немож-ливо довести логічну правильність програми. Для доведення остан-ньої використовуються методи верифікації (доведення) програм. Але тестування програми додає впевненості у правильність програми. Про-вести тестування дозволяють спеціальні програми, які дістали назву «відлагоджувачі». Звичайно їх надає середовище програмування або інтегроване середовище розробки (IDE – integrated development environment)."
              },
              {
                type: "paragraph",
                text: "Традиційно, інтегроване середовище розробки включає: тексто-вий редактор, що дозволяє описувати алгоритм обраною мовою про-грамування; компілятор або інтерпретатор програми на цій мові; від-лагоджувач; спеціальні інструментальні засоби аналізу програм, кон-тролю версій, автоматичного створення коду елементів інтерфейсу і т.п."
              },
              {
                type: "paragraph",
                text: "Розрізняють середовища загального призначення і мовно-орієнтовані середовища."
              }
            ]
          },
          {
            id: 2,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "Дайте визначення алгоритмічної мови.",
                  "Охарактеризуйте поняття «машинна мова».",
                  "Приведіть визначення поняття «програма».",
                  "Сформулюйте основні ознаки гарної програми.",
                  "Що ви розумієте під терміном «правильна програма»?",
                  "Яка програма буде наочною?",
                  "Охарактеризуйте поняття «модифікованість програми»."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 5,
        title: "Комп'ютерні обчислення",
        topics: [
          {
            id: 1,
            title: "Основи комп'ютерних обчислень",
            content: [
              {
                type: "heading",
                text: "Основи комп'ютерних обчислень"
              },
              {
                type: "paragraph",
                text: "Обчислювальний пристрій не може нічого винаходити і робити сам. Він може робити тільки те, що йому визначить програміст за допомогою програми. Комп'ютер «уміє» робити тільки одне – виконувати програми. Як ми зазначали, програма складається з інструкцій які називають командами. Програма описує обробку інформації, що задається (уточнюється) обробкою даних командами. Програма й дані знаходяться в оперативній пам'яті. Центральний процесор, або операційний пристрій, «вибирає» команди програми й дані у вигляді конкретних значень з пам'яті та виконує команди. Згідно з командами він обробляє значення в пам'яті, породжує нові значення й «записує» їх у пам'ять на нове місце або на місце старих значень, «стираючи» старі при цьому."
              },
              {
                type: "paragraph",
                text: "Процесор має власну пам'ять для збереження та обробки значень. Вона утворена спеціальними елементами, регістрами, тому і називається регістровою. Значення регістрової пам'яті обробляються набагато швидше, ніж значення що розміщені в оперативній пам'яті. Тому перед обробкою значення, як правило, зчитуються з оперативної пам'яті в регістри."
              },
              {
                type: "paragraph",
                text: "Дії процесора по обробці значень, описуються машинними командами типу: «прочитай дані з такого-то місця пам'яті в регістр А1», «додай два числа з регістрів А1 і А2 та запиши суму в регістр А3», «запиши число з регістра А1 в таке-то місце пам'яті» або «виконай команду, записану в такому-то місці пам'яті»."
              },
              {
                type: "paragraph",
                text: "Нехай, наприклад, П1, П2 і П3 позначають місця в пам'яті, де записано числа, а А1 і А2 – регістри. Для того, щоб додати два числа з П1 і П2 і записати результат у П3, процесор має виконати дії:"
              },
              {
                type: "list",
                items: [
                  "прочитати з П1 у А1",
                  "прочитати з П2 у А2",
                  "додати числа з А1 і А2 і суму записати в А1",
                  "записати з А1 у П3"
                ]
              },
              {
                type: "paragraph",
                text: "Особливість дії процесора позначається кодом операції. Код використовується в машинних командах, які утворюють програму для комп'ютера (машинну програму). Програми самі записуються в пам'ять і самі є даними. Проте прийнято відрізняти команди програми й дані, що обробляються при їх виконанні. Кажуть, що програма складається з команд і даних."
              },
              {
                type: "paragraph",
                text: "У пам'яті комп'ютера перебувають одночасно декілька програм. Одну з них називають «операційною системою (ОС)», яка представляє набір спеціалізованих програм і даних по загальному управлінню роботою комп'ютера. Наприклад, ОС визначає, команди якої з програм процесору треба виконувати у визначений момент (проміжок) часу. Прикладом відомої ОС може слугувати WINDOWS."
              },
              {
                type: "paragraph",
                text: "У комп'ютері є додаткова зовнішня пам'ять, розміщена на зовнішніх носіях даних, наприклад, магнітних дисках чи флешках. Ця пам'ять повільніша але значно дешевша. Для зв'язку з «зовнішнім світом» комп'ютер використовує спеціальні пристрої обміну даними (пристрої вводу-виведення (ПВВ)): дисководи, монітор, клавіатуру, мишу. Всі вони містять у своєму складі процесори, побудовані набагато простіше, ніж центральний процесор, і виконують зовсім інші спеціальні команди."
              },
              {
                type: "paragraph",
                text: "Процесори пристроїв обміну можуть переносити дані зі зовнішніх носіїв в оперативну пам'ять, виконуючи читання з «зовнішнього світу» або навпаки, записувати дані з оперативної пам'яті в «зовнішній світ». Переміщення значень між процесором і ПВВ відбуваються за допомогою спеціального пристрою – шини. Кожному пристрою обміну виділено свою особливу ділянку оперативної пам'яті – порт."
              },
              {
                type: "paragraph",
                text: "Комп'ютер може мати й інші пристрої обміну даними, наприклад, сканери для читання візуальної інформації, плотери для створення зображень, модеми для підключення до телефонної мережі тощо. Програми, за допомогою яких операційна система керує роботою пристроїв обміну, називаються драйверами."
              },
              {
                type: "paragraph",
                text: "Дані на зовнішніх носіях називаються файлами а системи запису файлів – форматами."
              },
              {
                type: "paragraph",
                text: "Машинна програма теж є прикладом файлу. Текст програми створюється людиною за допомогою спеціальних програм-редакторів (Word) і записується, як правило, на вінчестер або флешку. З часом, для виконання програма переписується звідти в оперативну пам'ять. Цей запис програми в оперативну пам'ять називається завантаженням і виконується згідно спеціальної програми – завантажувача."
              },
              {
                type: "paragraph",
                text: "Кожний тип обчислювача, в тому числі і комп'ютер, має цілком обмежений набір операцій, за допомоги яких він проводить мікро обробку даних (які може виконати ЦП комп'ютера). Оператори, які викликають на обробку бажану операцію, утворюють машинну мову цього типу виконавця. Вони ефективні. Та застосування машинних команд вимагає глибокого знання деталей побудови комп'ютера. Традиційно програма на машинній мові довга. Щоб уникнути цих проблем створено багато мов програмування."
              },
              {
                type: "paragraph",
                text: "Оператор - це елемент мови, що задає повний опис дії, яку необхідно виконати виконавцю. Кожен оператор є закінченою фразою мови програмування і визначає цілком завершений закінчений етап обробки даних. До складу операторів можуть входити службові слова, дані, вирази й інші оператори."
              },
              {
                type: "paragraph",
                text: "Кожен оператор має певний синтаксис і семантику. Під синтаксисом оператора розуміється система правил (граматика), яка визначає його правильний запис за допомогою елементів алфавіту цієї мови, до якого поряд з різними символами входять, наприклад, і службові слова. Під семантикою оператора розуміють його зміст, тобто ті дії, яким відповідає запис того чи іншого оператора."
              },
              {
                type: "paragraph",
                text: "Для обраного типу оператору синтаксис може відрізняться в різних мовах програмування а семантика залишається незмінною."
              },
              {
                type: "paragraph",
                text: "У багатьох мовах програмування «команди-оператори» містять звичні слова природної мови спілкування людей (у більшості випадків англійської мови), за структурою схожі на людські фрази а за змістом об'єднують у собі керування обробкою значень декількох машинних команд. Ці мови мають вищий рівень абстракції опису дій комп'ютера, тому називаються мовами високого рівня (МВР). Відповідно машинні мови називаються мовами низького рівня."
              },
              {
                type: "paragraph",
                text: "Комп'ютер не може напряму «виконувати» програми мов високого рівня. Перед виконанням програму на МВР потрібно перекласти (транслювати) на мову машини. Цей переклад реалізує спеціальна програма – транслятор. Після зчитування програми на МВР із зовнішнього носія, кожна її команда замінюється, як правило, декількома машинними командами, будується машинна програма й записується, як правило, у зовнішню пам'ять. Обидві програми задають ті самі дії виконавця, тільки різними мовами. Машинна програма завантажується в оперативну пам'ять і потім виконується."
              },
              {
                type: "paragraph",
                text: "Інший спосіб зробити програму на МВР «зрозумілою» комп'ютеру називається інтерпретуванням (інтерпретацією). У цьому випадку програму перекладача називають інтерпретатором. Вхідні дані інтерпретатора – це програма на МВР й ті дані, що повинні бути доступними при її виконанні. Інтерпретація програми полягає в тім, що вибирається окрема команда вхідної програми, перекладається на машинну мову та одразу виконується. Машинна програма при цьому не створюється."
              },
              {
                type: "paragraph",
                text: "В усіх операційних системах файли мають імена, які структурно складаються принаймні з двох частин, власне імені файлу та розширення, що відокремлені крапкою. Розширення визначає тип файлу та його призначення. Наприклад файл з позначенням name.exe містить машинну програму з ім'ям name."
              }
            ]
          },
          {
            id: 2,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "Сформулюйте основні етапи виконання програми комп'ютером.",
                  "Визначте базову структуру процесора.",
                  "Визначте призначення центрального процесора.",
                  "Охарактеризуйте поняття «машинна команда».",
                  "Приведіть класифікацію пам'яті комп'ютера.",
                  "Для чого використовується зовнішня пам'ять.",
                  "Розтлумачте поняття «драйвер пристрою».",
                  "Охарактеризуйте поняття «файл».",
                  "Дайте визначення мови виконавця.",
                  "Які мови програмування високого рівня ви знаєте.",
                  "Приведіть приклади мови програмування низького рівня.",
                  "Визначте основні відмінності між компілятором та інтерпретатором."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 6,
        title: "Подання чисел та інших значень у комп'ютері",
        topics: [
          {
            id: 1,
            title: "Загальні принципи подання інформації",
            content: [
              {
                type: "heading",
                text: "Загальні принципи подання інформації",
              },
              {
                type: "paragraph",
                text: "Людина сприймає світ через різні органи сприйняття (слух, зір, сприйняття запаху, смаку і т.п.) у вигляді сигналів певного типу, які обробляє і аналізує мозок, виробляючи відчуття. Відчуття – первинна форма сприйняття і відображення дійсності.",
              },
              {
                type: "paragraph",
                text: "Інформація про зовнішній світ може попасти в головний мозок людини тільки через сенсорну систему, яку називають воротами свідо-мості або вхідним пристроєм мозку. Спеціальна сенсорна клітка моз-ку, яку називають рецептором, перетворює подразнення у короткі ри-тмічні електрохімічні імпульси, що передається нервовими шляхами в різні перемикаючі станції центральної нервової системи. Там ці імпу-льси синтезуються (об’єднуються) і «декодуються» в систему даних про визначення характеру зовнішнього впливу. Весь цей процес тра-диційно називається відчуттям.",
              },
              {
                type: "paragraph",
                text: "Для того, щоб ми усвідомили будь-яке подразнення, треба, щоб енергія, яка виходить від нього (теплова, хімічна, механічна, електрич-на або електромагнітна), передусім була достатньою для збудження якогось із рецепторів людини. Увага кори мозку до подразнення спричиняє, відповідну реакцію інших органів людини, наприклад, руху очей. Це дозволяє глибше і детальніше сприймати і переробляти інфо-рмацію та у разі необхідності підключати інші органи людини для її обробки. Зрештою відбувається усвідомлення подразнень, виявлення їхньої сутності в реальному світі і фіксації цього відчуття у пам’яті. Подальші правила обробки відчуття, закладені в пам’яті людини, призводять до відповідної реакції іншими органами людини. Напри-клад, відчуття голоду, заставить людину шукати і вживати їжу.",
              },
              {
                type: "paragraph",
                text: "Виникає питання. Як нам представити все це різноманіття подіб-них електрохімічних імпульсів задання подразнень у комп’ютері? Тоб-то, як нам представляти всю множину команд і даних у пам’яті комп’ютера. Тут знову на допомогу приходить досвід людини. Істо-рично склалося так, що людство зберігає і передає накопичені знання за допомоги спеціальних знакових систем: печерні малюнки, шумерські таблички, єгипетські папіруси, книги. Серед знакових систем особливе місце займають числові системи.",
              },
              {
                type: "paragraph",
                text: "Число́ є одним з найголовніших об'єктів математики, який вико-ристовується для підрахунку, вимірювання та для маркування. Си-мволи, які використовуються для позначення чисел, називаються циф-рами. Окрім того, що числа використовуються при лічбі та вимірюван-ні, вони використовуються також для маркування (наприклад, як номер телефону). Взагалі, термін число може вказувати на символ, слово або математичну абстракцію. У давньослов'янських мовах під словом «чи-слити» розуміли «значити», «думати», а також «записувати щось за допомогою знаків», «робити певні дії зі знаками».",
              },
              {
                type: "paragraph",
                text: "Давайте розглянемо, як можна числами закодувати символи, сло-ва, речення текстів українською мовою. Знакова система текстової ук-раїнської мови складається із символів алфавіту і спеціальних розпо-дільників. Український алфавіт — сукупність 33 літер, прийнятих в ук-раїнській писемності і розміщених у певному усталеному порядку. Тобто кожній літері можна поставити у відповідність число – порядко-вий номер літери в алфавіті (таблиця 1.2.). Аналогічно можна закоду-вати і роздільники. Наприклад, пропуску приписати код 34, крапці – 35, комі 36 і т.д.",
              },
              {
                type: "image",
                src: "/images/image060.jpg",
                alt: "Таблиця 1.2. Український алфавіт та відповідні порядкові номери"
              },
              {
                type: "paragraph",
                text: "Тоді, домовившись про те, що числа 1 будемо писати 01, 2 – 02,…, 9 – 09 слово «Андрій» можна закодувати «011806211214» а ре-чення «Андрійко пише.» – «011806211214342011290735».",
              },
              {
                type: "paragraph",
                text: "Далі розберемося із різними формами запису чисел.",
              }
            ]
          },
          {
            id: 2,
            title: "Позиційні системи числення",
            content: [
              {
                type: "heading",
                text: "Позиційні системи числення",
              },
              {
                type: "paragraph",
                text: "Сукупність прийомів та правил найменування й позначення чисел називається системою числення. Для більшості людей найбільш знайо-мою є позиційна десяткова система числення. Ми записуємо числа використовуючи спеціальні знаки, які називають цифрами.",
              },
              {
                type: "paragraph",
                text: "Система числення, в якій значення кожної цифри залежить від місця в послідовності цифр у записі числа, називається позиційною. На-приклад, записи 82 і 28 у десятковій системі складаються з однакових цифр (значків «8» і «2»), але позначають різні числа «8×10+2» і «2×10+1».",
              },
              {
                type: "paragraph",
                text: "Основою системи числення називається число, яке означає, у скільки разів одиниця наступного розрядку більше за одиницю поперед-нього.",
              },
              {
                type: "paragraph",
                text: "Загальновживана форма запису числа є насправді не що інше, як скорочена форма запису розкладу за степенями основи системи чис-лення, наприклад:",
              },
              {
                type: "code",
                code: "246037 = 2*10^5 + 4*104 + 6*103 + 0*10^2 + 3*10^1 + 7*10^0.",
              },
              {
                type: "paragraph",
                text: "Тут 10 є основою системи числення, а показник ступеня — це но-мер позиції цифри в записі числа (нумерація ведеться зліва на право, починаючи з нуля). Арифметичні операції у цій системі виконують за правилами, запропонованими ще в середньовіччі. Наприклад, додаючи два багатозначних числа, застосовуємо правило додавання стовпчи-ком. При цьому все зводиться до додавання однозначних чисел, для яких необхідним є знання таблиці додавання.",
              },
              {
                type: "paragraph",
                text: "Цифри десяткової системи 0, 1, 2, … , 9 називаються арабськими, хоча й прийшли з Індії.",
              },
              {
                type: "paragraph",
                text: "У програмуванні широко застосовується шістнадцяткова система, в якій перші 10 цифр арабські, а наступні шість – A, B, C, D, E, F. Бук-ви позначають числа, десятковий запис яких 10, 11, 12, 13, 14, 15 від-повідно.",
              },
              {
                type: "paragraph",
                text: "Запис вигляду (akak-1…a1a0)P позначає в P-ковій системі число, що є значенням полінома",
              },
              {
                type: "code",
                code: "ak*P^k+ak-1*P^(k-1)+… +a1*P+a0.",
              },
              {
                type: "paragraph",
                text: "Наприклад, двійковий запис (10101)2 позначає число, яке в десят-ковому записі має вигляд 1× 2^4+0× 2^3+1× 2^2+0× 2^1+1× 2^0=16+0+4+0+1=21.",
              },
              {
                type: "paragraph",
                text: "16-ковий запис (2АC)16 позначає десяткове 484: 2*16^2 + А*16 + С = 1*16^2 + 10*16 + 12 = 484.",
              },
              {
                type: "paragraph",
                text: "Найправіша цифра в запису числа позначає кількість одиниць і називається молодшою, найлівіша – кількість чисел Pk і називається старшою.",
              },
              {
                type: "paragraph",
                text: "Як ми вже зазначали в комп’ютері числа, як правило, подаються в двійковій системі.",
              },
              {
                type: "paragraph",
                text: "Розглянемо правило, як одержати за натуральним числом N цифри його P-кового подання. Нехай N=(akak-1 … a1a0)P, і кількість цифр k+1 невідомі. Запишемо подання в такому вигляді:",
              },
              {
                type: "paragraph",
                text: "N = akP^k+ak-1P^(k-1)+… +a1 P+a0 = (…(ak P+ak-1) × P+… +a1) × P+a0.",
              },
              {
                type: "paragraph",
                text: "Звідси очевидно, що значенням",
              },
              {
                type: "paragraph",
                text: "a0 є N mod P, де mod – залишок від ділення націло",
              },
              {
                type: "paragraph",
                text: "a1 = (N div P) mod P , де div – результат ділення націло",
              },
              {
                type: "paragraph",
                text: "тощо.",
              },
              {
                type: "paragraph",
                text: "Таким чином, якщо поділити N на P у стовпчик, то остача від ді-лення буде значенням молодшої цифри. Потім можна так само поділи-ти на P частку від першого ділення – остача буде виражати кількість «P-кових десятків» тощо поки остання частка не виявиться менше P. Вона й буде значенням старшої цифри. При P>10 ще треба перетвори-ти числа більше 9 у цифри із спеціальним позначенням.",
              },
              {
                type: "paragraph",
                text: "Наприклад, одержимо цифри 16-кового подання десяткового числа 3127:",
              },
              {
                type: "paragraph",
                text: "3127 mod 16 = 7 (тому 7 найправіша «цифра»)",
              },
              {
                type: "paragraph",
                text: "3127 div 16 = 195 (ділення націло)",
              },
              {
                type: "paragraph",
                text: "195 mod 16 = 3 (перед найправіша «цифра»)",
              },
              {
                type: "paragraph",
                text: "195 div 16 = 12 (найстарша «цифра»).",
              },
              {
                type: "paragraph",
                text: "Виділені 7, 3 і 12 – це кількості 16-кових «одиниць», «десятків» і «сотень» відповідно. Позначимо 12 16-ковою цифрою С та одержимо запис С37.",
              },
              {
                type: "paragraph",
                text: "Найпоширенішою системою подання чисел у пам’яті комп’ютера є двійкова система числення. Вона економічна і проста в реалізації. Представлення двох цифр 0 і 1 забезпечують довільні два стійкі стани певних фізичних елементів. До того ж, таблички додавання й множення в цій системі елементарні:",
              },
              {
                type: "paragraph",
                text: "Оскільки 2^3=8, а 2^4=16, то кожних три двійкових розряди зобра-ження числа утворюють один вісімковий, а кожних чотири двійкових розряди — один шістнадцятковий. Тому для скорочення запису адрес та вмісту оперативної пам’яті комп’ютера використовують шістнадцят-кову й вісімкову системи числення.",
              }
            ]
          },
          {
            id: 3,
            title: "Двійкове кодування даних",
            content: [
              {
                type: "heading",
                text: "Двійкове кодування даних",
              },
              {
                type: "paragraph",
                text: "Враховуючи те, що комп’ютер може обробляти тільки числа, в більшості випадків представлених у двійковій системі числення, дові-льна інформація має бути закодована 0 і 1.",
              },
              {
                type: "paragraph",
                text: "Під інформацією будемо розуміти деяке відображення реального (матеріального) світу у вигляді знаків та сигналів у повідомленні. Об-мінюються інформацію за допомогою повідомлень. Найуживанішими є текстові, звукові повідомлення або скомбіновані у вигляді зобра-жень чи відео. Потрібно враховувати, що інформація може спотворю-ватися або зовсім втрачатися в процесі обробки чи передачі. Тому пот-рібні методи і засоби відновлення інформації.",
              },
              {
                type: "paragraph",
                text: "Кодуванням називають процес заміни знаків одного набору (ал-фавіту) знаками іншого набору при збереженні змісту інформації, яку подають за допомогою цих знаків. Алфавіт – це обмежена сукупність допустимих символів побудови повідомлень.",
              },
              {
                type: "paragraph",
                text: "Як ми вже зазначали не раз, даними називають інформацію представлену на носіях пам’яті комп’ютера. Для автоматизації роботи з різними даними важливо уніфікувати їх форму представлення шля-хом перекодування. Тобто, потрібно звести різноманітні знакові систе-ми до однієї, зручної для обробки комп’ютером, скориставшись при-йомом кодування.",
              },
              {
                type: "paragraph",
                text: "Звичайні різноманітні людські мови можна розглядати як системи кодування ідей та понять для вираження думок за допомогою мовлен-ня. Іншим прикладом загальновживаних систем кодування може бути азбука, як система кодування компонентів мови за допомогою графіч-них символів.",
              },
              {
                type: "paragraph",
                text: "Текстовим повідомленням називають деяке подання інформації засобами певної мови. Двійкове кодування – це перетворення повідом-лення за певними правилами у послідовність 0 і 1.",
              },
              {
                type: "paragraph",
                text: "У записі повідомлення можуть використовуватись різні набори символів. Наприклад, як ми вже зазначали, для запису повідомлення, яке є текстом на українській мові використовуються відповідний алфа-віт і розділові знаки. Для уніфікації такого кодування існують міжна-родні стандарти закріплення числових кодів за текстовими символа-ми. Одним із найрозповсюджених кодів є American Standard Code for Information Interchange (ASCII код).",
              },
              {
                type: "paragraph",
                text: "Та комп’ютер має обробляти ще й звукові та відео повідомлення. Для їх задання та обробки потрібно ввести до розгляду додаткові по-няття: піксель і дискретизація. Пікселем називають елемент зображен-ня на екрані комп’ютера (від англ. picture element – елемент зображен-ня). Дискретизація це подання неперервного сигналу сукупністю його окремих значень (від лат. discretus – розділений, переривчастий), а частоту дискретизації визначає кількість значень, які відповідають три-валості сигналу за одну секунду.",
              },
              {
                type: "paragraph",
                text: "Перші комп’ютери для відображення чисел використовували двійкову систему числення через простоту реалізації двох стійких ста-нів фізичним шляхом, застосовуючи ряд електричних лампочок. Ко-жна з лампочок може або світитися, повідомляючи про реалізацію 1, або бути вимкненою, повідомляючи про реалізацію 0.",
              },
              {
                type: "paragraph",
                text: "Зрозуміло, що всю інформацію можна поділити на великі групи: текстова, звукова, відео. У свою чергу, кожну із цих груп можна і далі ділити на підгрупи за певними ознаками. Наприклад, текстову можна поділити за типом символів: літерні, цифрові, розподільчі, керуючі (символ переходу на новий рядок). Такий поділ можна ще продовжити за потреби. У програмуванні такий поділ даних на окремі групи за пе-вною ознакою називають типізацією даних а правила виділення групи – типом даних.",
              },
              {
                type: "paragraph",
                text: "Зазначений поділ потрібний для оптимізації зберігання даних і їх обробки. Тип даних визначає ще й операції, які ми можемо застосува-ти до цих даних коректно. Наприклад, застосувати традиційні арифме-тичні операції додавання, віднімання, множення і ділення на пряму до текстової інформації (літерного типу) ми не зможемо. Дійсно, нам і на понятійному рівні потрібно ще зазначити, що ми будемо розуміти під діленням одного слова на інше чи діленням одного рядка літер на ін-ший. Та це відноситься не тільки літер. У попередньому параграфі ми вже бачили, що правила додавання чисел у різних позиційних системах числення також суттєво відрізняються.",
              },
              {
                type: "paragraph",
                text: "Тому розглянемо найпоширеніші типи даних та питання, пов’язані з особливістю їх зберігання та обробки, тобто: які операції передбачені зі змінними даного типу і як вони реалізуються? Напри-клад, при роботі з числовими даними маємо враховувати і розрізняти множини допустимих значень числових змінних, зокрема, цілих і дійс-них та формат їх задання (систему числення). Ці відмінності множин допустимих значень природно спричиняють відмінність операцій і фу-нкцій на них.",
              },
              {
                type: "paragraph",
                text: "ЕОМ має справу з обмеженими числовими множинами. Це ви-кликано тим, що в фрагмент пам'яті (машинне слово) можна записати, взагалі кажучи, не будь-яке число. Він має обмежену місткість і тому існують обмеження на розрядність числа, що вміщується в ньому.",
              },
              {
                type: "paragraph",
                text: "Звичайно ніхто не заважає нам використати для зберігання числа не один, а декілька фрагментів, що йдуть підряд, але це припущення може не підтримуватися уміннями виконавця обробляти ці фрагменти напряму, оскільки команди реальних ЕОМ звичайно обмежуються ви-конанням арифметичних операцій над числами, спосіб розміщення яких закріплений у фіксованій ділянці пам’яті яку називають машин-ним словом.",
              },
              {
                type: "paragraph",
                text: "Точніше, машинне слово це машиннозалежна і платформозале-жна величина пам’яті, що вимірюється в бітах або байтах (тритах або трайтах), що дорівнює розрядності регістрів процесора і/або розряд-ності шини даних, яка, зазвичай, є визначеним степенем двійки.",
              },
              {
                type: "paragraph",
                text: "Фіксація розміру і способи обробки пам’яті передбачені устроєм пам’яті конкретної ЕОМ. Коли ми кажемо 8=23, 16=24, 32=25, … роз-рядні ЕОМ, ми наголошуємо на те що у цьому комп’ютері розмір ма-шинного слова яке може оброблятися напряму машинними командами становить 8,16,32 розрядів. Зрозуміло, подібне обмеження можна було б зняти, розширивши уміння виконавця програмами виконання ариф-метичних операцій над числами, представленими яким-небудь іншим способом, наприклад двома машинними словами. Але такі арифметичні операції перестануть бути елементарними діями. Тоді потрібно про-грамісту писати власні процедури їх обробки, що приводить до різних проблем (надійність, переносимість, кодифікованість) з програмами.",
              },
              {
                type: "subheading",
                text: "Кодування числової інформації",
              },
              {
                type: "paragraph",
                text: "Число – основне поняття математики, що використовується для кількісної характеристики, порівняння, нумерації об’єктів та їх частин. Для запису чисел використовують цифри і спеціальні символи. Цифр у нас завжди обмежена кількість а чисел – нескінченна множина. Усі чи-сла можна поділити на певні типи. Найбільш розповсюдженими із них є цілі дійсні числа та їх різновидності.",
              },
              {
                type: "paragraph",
                text: "Для запам'ятовування цілих чисел виділяють певну кількість бай-тів.",
              },
              {
                type: "paragraph",
                text: "Дійсні числа подаються у форматі з фіксованою або рухомою крапкою. У першому варіанті (34.567) перший біт виділяють для за-пам’ятовування знаку числа, а решта розрядів поділені на дві частини: в одну з них заносять код цілої частини, а в іншу – код дробової.",
              },
              {
                type: "paragraph",
                text: "Першим кроком кодування дійсного числа у формі з рухомою крапкою (34567 10^(-3)) є приведення до стандартного нормалізованого вигляду «a×10^b », де a і b – цифри. У цьому випадку m називають мантисою числа, b – порядком числа. Машинне слово такого числа містить два знакових біти один – для знаку мантиси, а другий – для знаку порядку. Решта бітів поділено на дві частини: в одну частину ро-зташовують код порядку, а в іншу – код мантиси.",
              },
              {
                type: "paragraph",
                text: "Кількість бітів, які виділяють для мантиси та порядку, залежить від обчислювача і типу змінної, яка використовується.",
              },
              {
                type: "subheading",
                text: "Кодування текстової інформації",
              },
              {
                type: "paragraph",
                text: "Для кодування одного символу використовують щонайменше 1 байт інформації (8 бітів). Враховуючи те, що в біт можна записати тільки один із двох символів (1 або 0), в одному байті можна закодувати 2^8 = 256 різних символів. Тобто, кожному символу ставиться у відповід-ність унікальний двійковий код від 00000000 до 11111111 (або десят-ковий код від 0 до 255). Відповідність коду задається фіксованою ко-довою таблицею.",
              },
              {
                type: "paragraph",
                text: "Таблиця кодування – це таблиця, в якій всім символам комп’ютерного алфавіту поставлено у відповідність порядкові номери (коди). Важливим тут загальне сприйняття програмістською громадою цієї відповідності. Серед багатьох кодових таблиць виділяють три: ASCII, ANSI і cp1251.",
              },
              {
                type: "paragraph",
                text: "У таблиці ASCII (American Standart Code for Information Interchange) зафіксовано дві таблиці кодування базова, що закріплює значення кодів від 0 до 127, і розширена, що відноситься до символів з номерами від 128 до 255.",
              },
              {
                type: "paragraph",
                text: "Перші 32 коди базової таблиці, починаючи з нульового, закріп-лені за символами керування. Вони використовуються для позначення спеціальних дій по управлінню процесом обробки інших даних, на-приклад процесом уведення-виведення даних. Одним із таких символів є символ «переведення каретки». Їх в основному визначають виробни-ки апаратних засобів.",
              },
              {
                type: "paragraph",
                text: "Починаючи з коду 32 по код 127 розміщені коди символів анг-лійського алфавіту, цифр, розділових знаків, арифметичних дій і де-яких допоміжних символів. Базова таблиця кодування ASCII приведена в таблиці 1.2",
              },
              {
                type: "image",
                src: "/images/image061.png",
                alt: "Таблиця 1.2. Базова таблиця кодування ASCII",
              },
              {
                type: "paragraph",
                text: "У таблиці кодування cp1251 (сode page) останні 128 кодів вико-ристано для кодування кирилиці: білоруської, української. Алфавітний порядок для української абетки зворотній порядку зростання кодів відповідних літер у відповідному алфавіті.",
              },
              {
                type: "paragraph",
                text: "Компанія Microsoft увела своє кодування для символів російсько-го й українського алфавітів, що відоме як кодування Windows 1251 (табл. 1.3.)",
              },
              {
                type: "image",
                src: "/images/image062.png",
                alt: "Таблиця 1.3. Кодування Windows 1251",
              },
              {
                type: "paragraph",
                text: "У принципі це кодування стало стандартом в українському сек-торі World Wide Web.",
              },
              {
                type: "paragraph",
                text: "Зрозуміло, якщо взяти 16-розрядне кодування символів, то мо-жна 65536 (2^16=65536) різних символів закодувати. Таку систему коду-вання назвали універсальною (UNICODE). Вона дозволяє розмістити в одній таблиці символи практично всіх розмовних мов планети. Стан-дарт використано у багатьох новітніх технологіях, наприклад, у XML, мові програмування JavaScript і сучасних операційних системах. На-томість використовують 17 просторів, кожен з яких визначає 65536 ко-дів і дає можливість описати максимум 1114112 різних символів. Осно-вна багатомовна площина (Basic Multilingual Plane) містить майже всі символи, які використовують.",
              },
              {
                type: "paragraph",
                text: "UNICODE має декілька реалізацій, але найпоширенішими є дві: формат перетворення UTF (Unicode Transformation Format) та уні-версальна таблиця символів UCS (Universal Character Set). Число після UTF визначає кількість бітів, виділених під найменшу складову коду (юніт), а число після UCS — кількість виділених байтів. Універсальний набір символів задає однозначну відповідність символів кодам — еле-ментам кодового простору, тобто невід'ємним цілим числам.",
              },
              {
                type: "paragraph",
                text: "Найпоширеніший для інтернаціональних кодувань UTF-8 реалізує подання UNICODE, сумісне з 8-бітовим кодуванням тексту. Текст, складений лише з символів з кодом меншим, ніж 128, при записі в UTF-8 перетворюється на звичайний текст ASCII. І навпаки, в тексті UTF-8 будь-який байт із величиною, меншою ніж 128, подає символ ASCII з тим же кодом. Решта символів UNICODE зображають послідовностями завдовжки від 2 до 6 байтів.",
              },
              {
                type: "subheading",
                text: "Кодування графічної інформації",
              },
              {
                type: "paragraph",
                text: "Графічні зображення формують шляхом підсвічення усіх точок (пік-селів) екрану певними кольорами. Сукупність засобів для подання гра-фічних зображень з використанням пікселів називають растровою гра-фікою. Дрібні точки, які утворюють характерний візерунок, називають растром. Координати й характерні властивості кожної точки (яскра-вість) задають цілими числами, які можна подати в двійковій системі числення. Тому растрове кодування дозволяє використовувати двій-ковий код для представлення графічних даних.",
              },
              {
                type: "paragraph",
                text: "Для передачі тональності чорно-білого зображення використо-вують 256 градацій сірого кольору. Тому що 2^8 = 256 і, то для коду-вання яскравості будь-якої точки досить восьми розрядного двійкового числа.",
              },
              {
                type: "paragraph",
                text: "Для кодування кольорових графічних зображень застосовується принцип декомпозиції довільного кольору на три основні складові: че-рвоний (Red, R), зелений (Green, G) і синій (Blue, B). Відомо, що будь-який колір можна одержати шляхом механічного змішування цих трьох кольорів. Така система кодування називається системою RGB. Таблиця 1.4 ілюструє таке змішування.",
              },
              {
                type: "image",
                src: "/images/image063.png",
                alt: "Таблиця 1.4",
              },
              {
                type: "paragraph",
                text: "Якщо кодувати яскравість основного кольору 256 градаціями, то на кодування кольору одного пікселю потрібно 24 розряди, що за-безпечує однозначне кодування 16 777216 різних кольорів. Таке за-дання кольорової графіки називається повно-кольоровим (True Color). Кодування кольорової графіки 16-розрядними двійковими числами на-зивається режимом High Color (65536 різних кольорів). Залежність якості зображення від використаної кількості бітів для кодування зображена на рисунку 1.29",
              },
              {
                type: "image",
                src: "/images/image064.png",
                alt: "Рис.1.29 Залежність якості зображення від використаної кількості бітів",
              },
              {
                type: "paragraph",
                text: "Код підсвітки кожної точки растра із 256 можливих можна за-нести у спеціальну таблицю кодування яку називають палітрою. Спо-сіб розділення кольорів на складові називають колірною моделлю.",
              },
              {
                type: "subheading",
                text: "Кодування звукової інформації",
              },
              {
                type: "paragraph",
                text: "Звук, який сприймає людина – це звукові коливання в діапазоні 17 Гц до 20 КГц. Цей діапазон розбивається на інтервали сталості ча-стоти звуку. Занумерувавши ці інтервали числовими кодами, отримає-мо модель кодування звукового повідомлення.",
              },
              {
                type: "paragraph",
                text: "Для подання звуку у вигляді дискретних цифрових сигналів (дис-кретизації) використовують спеціальні пристрої — аналого-цифрові перетворювачі. Зворотне перетворення для відтворення звуку, закодо-ваного числовим кодом, виконують цифро-аналогові перетворювачі. Процес перетворення звукового сигналу в цифрову форму називають оцифруванням.",
              },
              {
                type: "paragraph",
                text: "Збереження миттєвої величини звукового сигналу в цифровій фо-рмі в окремий момент часу називають вибіркою. Чим частіше беруть вибірки, тим точніше цифрова копія звуку відповідає оригіналу.",
              },
              {
                type: "paragraph",
                text: "Розрядність звуку – кількість бітів, які використовують для циф-рового подання кожної вибірки. Для запису і відтворення мови достат-ньо 8-розрядного подання, а для музики потрібно 16 розрядів. Кожен звук є складною сумішшю коливань різної частоти, інтенсивності (амплітуди) і фази.",
              }
            ]
          },
          {
            id: 4,
            title: "Особливості задання чисел в пам'яті",
            content: [
              {
                type: "heading",
                text: "Особливості задання чисел в пам'яті",
              },
              {
                type: "paragraph",
                text: "Пам'ять ЕОМ можна уявити як послідовність бітів. 8 бітів утво-рюють байт. Кожний біт може приймати одне з двох значень: визна-чимо їх 0 і 1 (насправді байт містить 9 бітів: біт перевірки на непар-ність). Тоді байт цілком приймає 2^8 = 256 різних значень, які можна вважати натуральними числами від 0 до 255, представленими в пози-ційному записі за основою 2. Таким чином, за допомогою одного байту можна кодувати будь-яке натуральне число з множини N255, чого явно недостатньо. Тому у ЕОМ передбачене об'єднання байтів в групи по два і по чотири, а для деяких типів ЕОМ – по вісім або навіть по шіст-надцять.",
              },
              {
                type: "paragraph",
                text: "У більшості ЕОМ передбачені спеціальні групи команд, які за-безпечують виконання арифметичних операцій для кожного способу кодування, а також команди перетворення чисел з одного представлен-ня в інше. Позначення арифметичних операцій у мовах програмування не залежить від способу кодування чисел, вибір відповідних команд для робочої програми відбувається, виходячи з контексту.",
              },
              {
                type: "paragraph",
                text: "Розглянемо деякі загальноприйняті способи кодування цілих та дійсних чисел.",
              },
              {
                type: "paragraph",
                text: "Стандартним є кодування цілого числа за допомогою двох бай-тів. Один біт використовується для кодування знаку числа, отже, 15 бі-тів, що залишилися в сукупності можуть приймати одне із 2^15 = 32768 значень. Таким чином стандартним обмеженням множини цілих чисел є Z32767.",
              },
              {
                type: "paragraph",
                text: "При здійсненні обчислень, звичайно, доводиться мати справу не тільки з цілими невід’ємними числами, але також з від’ємними і дробо-вими. У програмуванні виділяють два типи чисел: беззнакові та знако-ві.",
              },
              {
                type: "paragraph",
                text: "Всі беззнакові числа вважаються невід’ємними, і всі їх розряди використовуються для задання абсолютної величини числа. Як ми вже зазначали, за допомогою одного байту можна закодувати цілі беззна-кові числа від 0 до 255.",
              },
              {
                type: "paragraph",
                text: "Для представлення ж від’ємних чисел слід виділити один біт для знаку. Як правило, це старший біт (крайній зліва). Якщо один біт у чи-слі виділяється під його знак, таке число називається знаковим. Як пра-вило, 0 у старшому біті відповідає додатнім числам, а 1 - від’ємним.",
              },
              {
                type: "paragraph",
                text: "Представлення від’ємних чисел залежить від кількості байтів, яка відводиться на число. Для визначеності будемо розглядати одно-байтові знакові числа.",
              },
              {
                type: "paragraph",
                text: "Виділяють три основних способи представлення від’ємних чисел:",
              },
              {
                type: "list",
                items: [
                  "прямий код, який утворюється з коду відповідного додат-ного числа шляхом встановлення знакового біта в 1;",
                  "обернений код, який утворюється шляхом заміни значення кожного біта на протилежне;",
                  "додатковий код, який утворюється шляхом додавання 1 до молодшого біта оберненого коду.",
                ],
              },
              {
                type: "paragraph",
                text: "Приклад. Розглянемо число 3. Двійковим еквівалентом відповідного додатного числа 3 є 00000011.",
              },
              {
                type: "paragraph",
                text: "Прямий код. Встановимо знаковий біт в 1 (нагадаємо, що 1 в старшому біті знакового числа сигналізує про його від’ємність). Всі інші біти за-лишаються без змін. В результаті вийде 10000011.",
              },
              {
                type: "paragraph",
                text: "Обернений код. Замінимо кожний біт на протилежний (1 на 0; 0 на 1); результатом буде 11111100.",
              },
              {
                type: "paragraph",
                text: "Додатковий код. Прибавимо 1 у двійковому коді (00000001) до обер-неного коду; в результаті вийде 11111101. Зверніть увагу, що якщо роз-глядати послідовність 11111101 як беззнакове, а не як знакове чис-ло, вона інтерпретується як додатнє число 253.",
              },
              {
                type: "paragraph",
                text: "Для дійсних чисел виділяють два основні формати представлення:",
              },
              {
                type: "list",
                items: [
                  "з фіксованою точкою: положення десяткової точки фіксу-ється програмним шляхом; тоді все, що знаходиться зліва від точки, вважається цілою частиною, а все, що справа - дробовою;",
                  "з плаваючою точкою: цей формат застосовується для опе-рацій з дуже великими або дуже маленькими числами; ґрунтується на поданні у вигляді a*10b; a називається мантисою, а b - порядком. Ман-тиса і порядок зберігаються окремо.",
                ],
              },
              {
                type: "paragraph",
                text: "Одне з стандартних кодувань дійсного числа – чотирибай-тове. Спосіб використання цих чотирьох байтів для різних типів ЕОМ може розрізнюватися.",
              },
              {
                type: "paragraph",
                text: "Для персональних ЕОМ типу IBM PC прийнятий такий спо-сіб кодування. Знак кодується в старшому розряді останнього байта. Мантиса числа займає три молодших байти без одного біта. Вона запи-сана в двійковій системі числення. Отже, b = 2, р = 23. Мантиса завжди нормалізована і має 23 явних розряди і один неявний. Нормалізація виконується так, що старша значуща одиниця коду мантиси завжди ро-зташовується перед позиційною крапкою. Цей розряд у коді мантиси не вказується, але завжди мається на увазі. Отже, мантиса має вигляд f = 1.a1 а2 а3... а23, де аk - двійкова цифра в k-му розряді мантиси (з вагою 2-k ).",
              },
              {
                type: "paragraph",
                text: "Оскільки 2^24 = 16 777 216, то десятковий запис мантиси складається з семи значущих цифр, але гарантовано правильний ре-зультат дають тільки шість. Порядок кодується одним байтом d = 2^8 - 1 при надлишку q = 127. Отже, з урахуванням нової умови нормалізації: min = х = 2^(-127) = 5.9 * 10^(-39), max = х = 2^128 = 3.4 * 10^38.",
              },
            ]
          },
          {
            id: 5,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "Сформулюйте базові принципи сприйняття людиною зовнішнього світу.",
                  "Як можна числами закодувати символи деякого алфавіту?",
                  "Дайте визначення позиційної системи числення.",
                  "Приведіть приклади позиційних систем числення, які використо-вуються у комп’ютерних обчисленнях.",
                  "Сформулюйте правило знаходження за натуральним числом N цифр його P-кового подання.",
                  "Уточніть поняття «кодування інформації».",
                  "Приведіть основну ідею двійкового кодування текстових повідом-лень.",
                  "Які базові принципи кодування звуку і відео.",
                  "Як фізично можна реалізувати два стійкі стани?",
                  "Сформулюйте ваше розуміння типу даних.",
                  "Які формати задання чисел ви знаєте?",
                  "Де використовується таблиця ASCII?",
                  "У чому відмінні таблиці кодування cp1251, Windows 1251, UNICODE?",
                  "Як задаються числа в пам’яті?",
                  "Приведіть стандартне кодування цілого числа.",
                  "Які способи представлення від’ємних чисел ви знаєте?",
                  "Приведіть формати представлення дійсних чисел.",
                ],
              },
            ]
          }
        ]
      }
    ]
  },
  {
    id: 2,
    title: "ПОЧАТКИ ПРОГРАМУВАННЯ",
    sections: [
  {
    id: 1,
    title: "Вступ до JavaScript",
    topics: [
      {
        id: 1,
        title: "Коротка характеристика",
        content: [
          {
            type: "heading",
            text: "Що таке JavaScript?",
          },
          {
            type: "paragraph",
                text: "Мова JavaScript була створена у 1995 році Бренданом Айком винятково для взаємодії з браузером Netscape Navigator, а тепер вона одержала найширше розповсюдження і майже усі браузери її підтри-мують. Це тестовий текст для перевірки відображення."
          },
          {
            type: "paragraph",
            text: "Більшість людей, заходячи на сайт, найперше звертає увагу на загальний вигляд сторінки, на її функціональність, а не на зміст. З ме-тою надання веб-сторінкам привабливого вигляду і створення у відвідувача відчуття взаємодії із сайтом використовують додаткові можливості, доступні при використанні JavaScript. Діапазон застосування мови широкий: зміна вмісту сторінки у відповідь на дію користувача; створення спливаючих підказок; реагування на клацання миші, рух ку-рсору тощо. До того ж, мова JavaScript може бути використана для створення найпростіших ігор, «пожвавлення» представлення інформа-ції."
          },
          {
            type: "paragraph",
            text: "JavaScript спочатку створювався для того, щоб зробити web-сторінки «природними». Програми цією мовою називалися скриптами (сценаріями). У браузері вони підключалися безпосередньо до мови HTML і, як тільки завантажувалася сторінка – тут же виконувалися."
          },
          {
            type: "paragraph",
            text: "Коли створювалася мова, у неї була назва: «LiveScript». Та, враховуючи значну популярність мови Java, маркетологи вирішили, що схожа назва «JavaScript» зробить цю нову мову популярнішою. Планувалося, що JavaScript буде «молодшим братом» Java. Однак, відбулося по-іншому. JavaScript суттєво утвердився, і зараз це абсолю-тно незалежна мова, зі своєю специфікацією, яка називається ECMAScript. Специфікація ECMA-262 визначила стандартну версію ядра мови JavaScript. Остання до Java не має жодного стосунку."
          },
          {
            type: "paragraph",
            text: "Javascript це динамічна інтерпретована мова програмування з об'єктно-орієнтованими можливостями, яка найчастіше використову-ється як частина скриптового коду (сценарію) на веб-сторінках для взаємодії з користувачем і створенні динамічних сторінок. Вона (рис. 2.1) відкрита і крос-платформна (платформо-незалежна)."
          },
          {
            type: "image",
            src: "/images/placeholder-cross-platform.png",
            alt: "Рис. 2.1. Крос-платформність JavaScript",
          },
          {
            type: "paragraph",
            text: "Мова JavaScript зручна для роботи в мережі Інтернет. Вона містить водночас прості та ефективні засоби візуалізації інформації, побудови різноманітних звукових ефектів і анімації. Тобто мова має зручні та ефективні засоби програмування ігор."
          },
          {
            type: "paragraph",
            text: "Окрім, JavaScript містить всі основні елементи, притаманні мо-вам високого рівня. Але основним критерієм нашого вибору було те, що для написання програми, її відлагодження та виконання потрібен лише доступ до Інтернету та якийсь браузер (веб-оглядач типу Internet Explorer, Mozilla Firefox, Google Chrome). Ці браузери містять вмонто-ваний інтерпретатор для перетворення JavaScript-програми у машинну програму."
          },
          {
            type: "heading",
            text: "Переваги використання JavaScript",
          },
          {
            type: "list",
            items: [
              "Незначна (менша) взаємодія з сервером, що економить трафік сервера. Наприклад, користувач може підтвердити введення власних даних перед відправкою сторінки, минаючи сервер.",
              "Безпосередній зворотний зв'язок для відвідувачів.",
              "Збільшення інтерактивності шляхом створення інтерфейсів, які вступають у взаємодію, коли користувач маніпулює з ними за до-помогою миші або активує їх за допомогою клавіатури.",
              "Більш багаті інтерфейси дозволяють включати в себе такі елементи, як компоненти драг-енд-дроп, слайдери і повзунки."
            ]
          },
          {
            type: "paragraph",
            text: "Drag-and-drop (тягни і відпускай) — спосіб оперування елемента-ми в інтерфейсах користувача за допомоги маніпулятора «мишка» або сенсорного екрана. Візуально слайдер сайту є виділеним блоком на сторінці, в межах якого, з визначеною періодичністю, демонстру-ються анонси статей або новин, або зображень. Повзунок це інструмент панорамування та масштабування спеціального вигляду."
          },
          {
            type: "heading",
            text: "Недоліки JavaScript",
          },
          {
            type: "list",
            items: [
              "На стороні клієнта не дозволяється читання або запис фай-лів. Це зумовлено необхідністю забезпечення безпеки.",
              "Мова не має прямого доступу до системних функцій ОС. Такі дії скриптів вимагають підтвердження від користувача.",
              "Реалізована політика однакового початку (Same Origin Policy) - вікна браузера не знають про існування один одного. Правило можна обійти, якщо обидві сторінки погодились надати доступ.",
              "JavaScript легко взаємодіє із сервером, з якого надійшла сторінка. Але він обмежений в доступі до інших доменів, для цього по-трібно оголошувати посилання в заголовках сторінки.",
              "Мова не може бути використана для мережевих додатків.",
              "У ній не має багато потоковості та підтримки багатопроце-сорних можливостей."
            ]
          },
          {
            type: "heading",
            text: "Засоби розробки JavaScript",
          },
          {
            type: "paragraph",
            text: "Як ми вже зазначали, JavaScript дозволяє почати розробку програмного коду з використанням простого текстового редактору, наприклад Word. Враховуючи, що це інтерпретована мова в контексті веб-браузера, вам непотрібно купувати компілятор. Тобто можемо скористатися для виконання програмного коду можливостями веб-браузера, що забезпечує ваш доступ до Інтернету."
          },
          {
            type: "paragraph",
            text: "Та існують і спеціальні інструменти для редагування JavaScript. Microsoft FrontPage популярний редактор HTML з різноманітним ін-струментарієм (різноманітними засобами) допомоги в створенні інте-рактивних веб-сайтів. Редактор Macromedia Dreamweaver MX більше використовується професіоналами веб-розробки. Він зручно інтег-рується з базами даних і відповідає новим стандартам XHTML і XML. Macromedia HomeSite 5 більше використовується для ефективного уп-равління особистими веб-сайтами."
          }
            ]
      },
      {
        id: 2,
        title: "Початок роботи",
        content: [
          {
            type: "heading",
            text: "Початок роботи",
          },
          {
            type: "paragraph",
            text: "Отже для початку під'єднайтесь до Інтернету та встановіть самі або попросіть «спеціаліста» щоб він встановив на вашому комп'ютері один із браузерів. Ми обираємо Google Chrome (http://www.google.com/chrome). На робочому столі при вмиканні комп'ютера буде з'являтись відповідна «іконка». Підведіть маркер курсора на іконку та натисніть ліву клавішу миші. На моніторі з'явиться зображення (рис. 2.2)."
          },
          {
            type: "image",
            src: "/images/browser-interface.png",
            alt: "Рис. 2.2. Зображення інтерфейсу браузера",
          },
          {
            type: "paragraph",
            text: "У вікні набору запиту на пошук інформації (в адресному рядку) наберіть команду about:blank та натисніть клавішу ENTER. Ви отримаєте порожню сторінку (рис. 2.3). Браузер готовий до роботи з вами за допомоги інтерпретатора JavaScript."
          },
          {
            type: "image",
            src: "/images/blank-page.png",
            alt: "Рис. 2.3. Порожня сторінка",
          },
          {
            type: "paragraph",
                text: "Для входу в чарівний палац програмування вам необхідно підібрати вхідний ключ. Їм слугує команда J. Введення команди залежить від ОС:",
          },
          {
            type: "list",
            items: [
              "CTRL/SHIFT/J для Windows Linux і",
              "COMMAND/OPTION/J для Mac OS."
            ]
          },
          {
            type: "paragraph",
            text: "Подібний запис з використанням «/» означає одночасне натискання і тримання клавіш CTRL і SHIFT (COMMAND і OPTION) та натискання клавіші J."
          },
          {
            type: "image",
            src: "/images/javascript-console.png",
            alt: "Рис. 2.4. Консоль JavaScript",
          },
          {
            type: "paragraph",
            text: "За правильного виконання вказаних дій на екрані монітора з'явиться порожня веб-сторінка (рис. 2.4.). У лівому верхньому кутку сторінки блимає курсор (І), якому передує символ « > ». Тут можна починати писати програмний код."
          },
          {
            type: "paragraph",
            text: "Вперед!!! Всі скарби світу програмування перед вами."
          }
            ]
      },
      {
        id: 3,
        title: "Перші кроки",
        content: [
          {
            type: "heading",
            text: "Перші кроки",
          },
          {
            type: "paragraph",
            text: "Пам'ятаючи, що ми маємо справу із інтерпретатором (а ми вже знаємо, що він перекладає команду програми в машинну команду, готову до виконання) спробуємо одразу реалізовувати основні операції калькулятора. Почнемо з операції додавання. Наприклад, ми хочемо дізнатись результат операції «1+2». Для цього давайте виконаємо таку послідовність кроків."
          },
          {
            type: "list",
            items: [
              "Введемо в консоль на місце курсора, що «блимає» таке: 1+2; Зверніть увагу на «;».",
              "Натисніть клавішу ENTER."
            ]
          },
          {
            type: "paragraph",
            text: "Ви побачили на екрані результат 3 у вигляді, який представлено на рис. 2.5."
          },
          {
            type: "image",
            src: "/images/console-operations.png",
            alt: "Рис. 2.5. Відображення дій на консолі",
          },
          {
            type: "paragraph",
            text: "Після кожного можливого виконання дії (операції) інтерпретатор друкує в наступному рядку результат. Символ «;» позначав закінчення введення, а натискання на ENTER викликало обчислення і друк кінцевого результату та перехід до очікування вводу наступної команди (рис. 2.5). Звернемо вашу увагу на різнокольорове забарвлення операндів (синє) і операцій (червоне). Консоль браузера буде забарвлювати текст різними кольорами в залежності від типу інформації вводу-виводу. У тексті книги ми будемо використовувати один колір для всього коду."
          },
          {
            type: "paragraph",
            text: "Спробуйте самостійно порахувати вираз 10+5-2 та побавтесь (випробуйте калькулятор) на власних прикладах."
          },
          {
            type: "paragraph",
            text: "Отже, за відсутності у вас калькулятора ви вже знаєте як допомогти собі в обчисленнях за наявності мобільного пристрою і доступу до Інтернету!!!!"
          },
          {
            type: "paragraph",
            text: "Але ж, як ви вже зрозуміли, програм в один рядок практично не буває. Постає питання як набрати текст програми що містить декілька рядків. Для цього після закінчення чергового рядка маємо натиснути одночасно на клавіші SHIFT/ENTER."
          },
          {
            type: "paragraph",
                text: "Традиційно при вивченні мов програмування однією із перших програм пишуть програму друку вітання із світом. Ми не будемо порушувати традиції. Давайте попросимо комп друкувати на екран повідомлення «Люди, привіт !!!». Для цього потрібно ввести текст такої програми:",
          },
          {
            type: "code",
            code: "// програма вітання\nconsole.log(\"Люди, привіт !!!\");",
            language: "javascript"
          },
          {
            type: "paragraph",
                text: "Після першого рядка вводу не забувайте натиснути SHIFT/ENTER. Закінчимо текст другого рядка написанням ENTER. Якщо, введено вірно запропонований текст програми, тоді на екран (рис.2.6) виведеться текст:",
          },
          {
            type: "image",
            src: "/images/hello-world.png",
            alt: "Рис. 2.6. Приклад виведення інформації",
          },
          {
            type: "paragraph",
                text: "Ми вітаємо вас з першою написаною і відлагодженою ПРОГРАМОЮ. Ви вступили до касти програмістів!!!",
          }
            ]
      },
      {
        id: 4,
        title: "Зауваження щодо синтаксису",
        content: [
          {
            type: "heading",
            text: "Зауваження щодо синтаксису"
          },
          {
            type: "paragraph",
            text: "JavaScript ігнорує пропуски, символи табуляції і нових рядків в тексті програмного коду. Тому ми можемо їх використовувати для форматування тексту, щоб зробити його більш структурованим, читабельним і зрозумілим."
          },
          {
            type: "paragraph",
            text: "Крапка з комою служить розподільником між інструкціями мови та не є обов'язковою. Вона може не ставитись, якщо кожна з цих інструкцій розміщуються в окремому рядку."
          },
          {
            type: "code",
            code: "var x1= 7; var x2 = 3; // синтаксично вірно\nvar x1= 7 // синтаксично вірно\nvar x2 = 3;\nvar x1= 7  var x2 = 3; // помилка",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "JavaScript є чутливим до регістру набору символу на клавіатурі. Тому рядки символів Friends i FRIENDS позначають різні ідентифікатори (є різними іменами двох змінних). Ми постійно маємо про це пам'ятати. У мові є навіть спеціальні домовленості про використання букв великого і малого регістрів. Так імена змінних мають починатися із символу набраного з використанням малого регістру (з маленької букви)."
          },
          {
            type: "paragraph",
            text: "Коментарі в JavaScript ігноруються відносно виконання (пропускаються). Будь-який текст між // і кінцем рядка розглядається як коментар. Будь-який текст між символами /* і */ розглядається як коментар. Він може займати кілька рядків."
              }
            ]
          },
          {
            id: 5,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
            text: "Завдання для самоконтролю"
          },
          {
            type: "list",
            items: [
              "Приведіть загальну характеристику Javascript.",
              "Як підготувати до роботи інтерпретатор JavaScript?",
              "Напишіть програму, яка друкує повідомлення «Мені подобається програмувати».",
              "Сформулюйте правила запису коментарів у програмі.",
              "Приведіть основні ознаки процедурної мови програмування.",
              "Прокоментуйте терміни «синтаксис» і «семантика» програми.",
              "Чим різняться вхідні, проміжні і вихідні дані програми?",
              "Як комп може добратися до потрібних даних (ділянок пам’яті)?",
              "Приведіть приклади використання інструкції var.",
              "Дайте визначення ідентифікатора.",
              "Напишіть та відлагодьте програму що знаходить більше число з двох чисел з використанням конструкції var для оголошення змінної, значення якої ініціалізується визначенням функціонального виразу. Конкретні значення чисел вказуються при виклику функції.",
              "Напишіть та відлагодьте програму реалізації визначення можливості побудови трикутника із трьох відрізків a,b,c. Трикутник можна побудувати якщо довжина найбільшого відрізка с менша суми довжин двох інших відрізків.",
              "Приведіть синтаксичні правила використання розподільників у записі програми.",
              "Сформулюйте ваше розуміння поняття «лексика мови»."
            ]
          }
        ]
      },
        ]
  },
  {
    id: 2,
    title: "Дані",
    topics: [
      {
        id: 1,
        title: "Сталі, змінні та типи даних",
        content: [
          {
            type: "heading",
            text: "Сталі, змінні та типи даних"
          },
          {
            type: "paragraph",
            text: "Комп'ютерні програми отримують результати, обробляючи дані. Як ми вже зазначали, всі дані можна поділити на три великі групи: вхідні, проміжні і вихідні. Досить мало програм працюють без вхідних даних. Традиційно це програми, які займаються різноманітним друком інформації заданої в тексті програми або обробкою якоїсь інформації на основі випадкових даних, що породжуються з використанням датчиків випадкових чисел у тілі програми. У більшості випадків вхідні значення вводяться із зовнішніх носіїв або від людини за допомоги пристроїв вводу-виводу. Найбільш розповсюдженими із таких пристроїв є клавіатура (уведення) і монітор (виведення). На базі вхідних значень і програми комп'ютер обчислює проміжні дані і вихідні значення, які характеризують результат роботи алгоритму. Легкість, з якою виконується цей процес, залежить від того, наскільки точно типи даних відповідають реальній задачі. Отже, дуже важливо, щоб в мові була передбачена підтримка відповідної різноманітності типів і структур даних."
          },
          {
            type: "paragraph",
            text: "Вводити значення елементів з клавіатури не завжди зручно. До того, часто при налагодженні програми нам потрібно установити, що вона працює на довільних даних. Тому потрібно мати механізм задання значень випадковим чином, з використанням вбудованої в мову програмування спеціальної стандартної функції реалізації «датчика псевдовипадкових чисел»."
          },
          {
            type: "paragraph",
            text: "Числа називаються псевдовипадковими, тому що для їх знаходження використовується якась ітераційна послідовність ri = f (ri-1). Будь-яка подібна послідовність має властивість періодичності (тобто, починаючи з якогось моменту, числа почнуть повторюватися в тому ж самому порядку)."
          },
          {
            type: "paragraph",
            text: "У мовах програмування псевдовипадкова послідовність реалізується стандартною функцією з іменем random. Якщо використовувати її без параметрів, то при черговому зверненні вона буде видавати в якості результату деяке псевдовипадкове дійсне число з діапазону [0; 1]. Функція randomize призначена для задання першого значення в послідовності ri. Вона використовує поточне значення комп'ютерного таймера; в результаті чого при різних запусках програми послідовності виходять різними. Для отримання цілих випадкових чисел з діапазону [0; n-1] використовується виклик функції random з параметром n: random(n)."
          },
          {
            type: "paragraph",
            text: "У JavaScript випадкові числа можна генерувати за допомогою спеціального методу Math.random(), який при кожному виклику повертає випадкове число від 0 до 1 (завжди повертає число менше 1). Для отримання більших чисел можна отримане з методу Math.random() значення помножити на відповідний коефіцієнт: 10, 100, 1000, …. Наприклад, якщо потрібно випадкове число від 0 до 100, помножте значення Math.random() на 100. За потреби переведення цих випадкових значень у цілі числа можна скористатися методом Math.floor(), що округляє число-параметр до найближчого знизу цілого значення, відкидаючи всі знаки після коми."
          },
          {
            type: "code",
            code: "<Math.random();\n> 0.69454074576649317\n\n< Math.random() * 100; \n>36.248029329705651\n\n< Math.floor(Math.random() * 10); // може видати 0, 1, 2, …,9\n>7",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Як ми вже зазначали раніше, комп'ютер виконує алгоритм обробки даних, заданий у вигляді програми. Програми складаються із команд, що уточнюють обробку даних, які представлені у вигляді значень, що зберігаються в оперативній пам'яті. Операційний пристрій «вибирає» команди програми й потрібні значення з пам'яті та виконує над ними вказані командою дії. Результат обробки знову заноситься в пам'ять."
          },
          {
            type: "paragraph",
            text: "Крім оперативної пам'яті, у комп'ютері є додаткова зовнішня пам'ять – на зовнішніх носіях даних, наприклад, флешках. Носії розміщуються на спеціальних пристроях обміну даними з «зовнішнім світом», або пристроях уведення-виведення. Дані розміщуються на зовнішніх носіях у файлах. Правила запису даних у файлах називаються форматами. Файли мають імена, що мають принаймні дві частини ім'я та розширення, відокремлені крапкою. Програми на мові JavaScript записуються, як правило, у файли з розширенням .js, наприклад, «p1.js»."
          },
          {
            type: "paragraph",
            text: "Базовим елементом мови є алфавіт – скінченна множина символів. Алфавіт мови JavaScript складають:"
          },
          {
            type: "list",
            items: [
              "Великі й малі латинські букви A, B, ..., Z, a, b, ..., z",
              "Десяткові цифри 0, 1, 2, ..., 9",
              "Інші символи, серед яких + - * / = > < . , ; : ' ( ) [ ] { } ^"
            ]
          },
          {
            type: "paragraph",
            text: "З символів алфавіту утворюються слова мови, базові складові речення (команди). Множина лексем і правил їх запису утворюють лексику мови. Лексеми неподільні й самі по собі позначають деякий зміст. Мова JavaScript має такі лексеми: сталі, імена, знаки операцій, роздільники й коментарі."
          },
          {
            type: "paragraph",
            text: "З деякими правилами їх написання ми вже познайомилися. Наприклад, JavaScript – регістрозалежна мова і потрібно враховувати регістр при найменуванні змінних і функцій. Однорядковий коментар ставиться за допомогою символів «//», багаторядковий – «/*коментар*/»."
          },
          {
            type: "paragraph",
            text: "Мова JavaScript має власні правила комбінування символів і слів для побудови правильних програм, тобто програм які вірно функціонують, роблять те, що бажав програміст. Вони задають синтаксис мови."
          },
          {
            type: "paragraph",
            text: "Сталі – це позначення певних значень, які залишаються незмінними в процесі виконання програми. Імена – це послідовності букв і цифр, що починаються з букви, наприклад, billSIN. Великі й малі букви в іменах різняться. Ім'я завжди позначає якесь значення, ідентифікуючи його серед інших. Деякі імена використовуються спеціальним чином для утворення спеціальних компонент (речень) програми. Їх називають зарезервованими (ключовими, службовими) словами. Деякі з них ми вже використовували (var, function)."
          },
          {
            type: "paragraph",
            text: "Пару (Е,О), де Е – множина елементів, а О – множина операцій над елементами із Е, математики називають типом. Якщо в якості елементів взяти цілі числа і зафіксувати відомі із арифметики операції додавання, віднімання, множення і ділення, то отримаємо тип даних – цілий. Цей тип скалярний, тому що ці значення розглядаються як неподільні."
          },
          {
            type: "paragraph",
            text: "Розглянемо ще один приклад типу даних, який використовується для уточнення істинності якогось твердження і є базовим носієм інформації. Твердження складається із окремих висловлень."
          },
          {
            type: "paragraph",
            text: "Висловленням називають оповідне речення, про яке можна (принаймні в межах певного контексту) сказати, що воно істинне або хибне. Висловлювання характеризують певні властивості або стан якогось об'єкта. За допомогою висловлювань ми встановлюємо взаємозв'язок між об'єктами. Прикладами висловлювань є речення: «Андрій гарний учень», «Учора Андрій грав у футбол», «Андрій живе в Києві». Для об'єкта «Андрій» кожне з них установлює зв'язок відповідно з об'єктами «учень», «футбол» і «Київ»."
          },
          {
            type: "paragraph",
            text: "Висловлення буде істинним, якщо воно адекватно відображає цей зв'язок, в іншому випадку воно помилкове. Однак визначення істинності висловлювання залежить від контексту та конкретних значень (стану) об'єкта. Так, істинність висловлення «Учора Андрій грав у футбол» залежить від того, дійсно грав учора Андрій у футбол чи ні."
          },
          {
            type: "paragraph",
            text: "Визначення істинності наведених висловлювань відсилає проблему визначення висловлювання до проблеми визначення істинності чи хибності даного мовного утворення. Та таке визначення може призвести до парадоксів і суперечностей. Традиційно приводять приклад такого висловлення «Це речення є помилковим». Йому неможливо приписати ніякого значення істинності без того, щоб не отримати суперечність. Дійсно, якщо прийняти, що речення істинне, то це суперечить суті оповіді. Якщо ж прийняти, що речення помилкове, то це означає, що висловлення насправді істинне. Тому такому реченню свідомо не можна приписати якесь значення істинності, і воно не є висловлюванням."
          },
          {
            type: "paragraph",
            text: "Причиною останнього парадоксу є структура речення, а саме, посилання на себе. Тому для усунення подібних парадоксів у висловленнях забороняється посилання на себе."
          },
          {
            type: "paragraph",
            text: "Зрозуміло, що у висловленнях можуть застосовуватися і різноманітні формули та спеціальні знаки. Наприклад, «20 < 10» буде хибним при трактуванні 10 і 20 як позначення цілих чисел, а знак «<» – як позначення твердження «менше»."
          },
          {
            type: "paragraph",
            text: "Однак не всяке таке оповідне речення, виражене формульним записом, є висловлюванням. Наприклад, у реченні «х < 20» не міститься твердження про щось. Питання про його істинність або хибність ми можемо поставити тільки при заміні позначення х будь-яким конкретним числовим значенням."
          },
          {
            type: "paragraph",
            text: "Висловлення називається елементарним, якщо жодна його частина сама не є висловленням. Якщо висловлювання є істинним, то кажуть, що його значення рівне І (істина, true), в іншому випадку (якщо висловлювання є хибним) його значення є Х (хиба, false)."
          },
          {
            type: "paragraph",
            text: "З елементарних висловлювань можна отримувати нові, складніші висловлювання за допомогою логічних операцій. Згадаймо, що в українській мові складніші висловлювання будуються із простих висловлювань за допомоги сполучників (логічних зв'язок) типу: і, або, ні, якщо ... то, і т.п. У цих операціях можуть застосовуватися і логічні змінні."
          },
          {
            type: "paragraph",
            text: "Логічною змінною називається змінна, значенням якої може бути будь-яке, наперед задане висловлювання. Зрозуміло, що логічні змінні можуть приймати тільки значення «істина» або «хиба (хибність)». Ці значення називають логічними."
          },
          {
            type: "image",
            src: "/images/image071.png",
            alt: "Таблиця 2.1. Булеві операції"
          },
          {
            type: "paragraph",
            text: "Нехай множина елементів містить два елементи Е = <«істина», «хибність»>, а множина операцій О містить три операції О = < «and (та)», «or (або)», «not (не)» >, що називаються відповідно булевими операціями множення (кон'юнкція and), додаванням (диз'юнкція or) і заперечення not. Результати застосування цих операцій до булевих значень імен А і В подано в таблиці 2.1. Такий тип даних називають булевим."
          },
          {
            type: "paragraph",
            text: "Увесь природний світ як типізований, так і уніфікований. Серед об’єктів світу можна виділити різні класи (типи) об’єктів, що їх об’єднують за якимись виділеними однаковими ознаками. Наприклад, одним із таких класів є спільнота людей. Та серед цієї спільноти ми не знайдемо двох абсолютно ідентичних людей. Тобто при класифікації ми абстрагуємось певним чином, відкидаючи не суттєві розбіжності."
          },
          {
            type: "paragraph",
            text: "Для розв’язання багатьох задач нам потрібно проводити різноманітні маніпуляції із елементами цих спільнот (проводити виділені операції над елементами). З метою чіткішого опису цих маніпулювань у програмах використовуються вирази. Для уточнення їх побудови маємо сформулювати правила побудови виразів."
          },
          {
            type: "list",
            items: [
              "вираз взятий у дужки,",
              "два вирази об’єднані знаком бінарної операції між ними,",
              "вираз із знаком унарної операції перед ним,",
              "виклик функції з виразом у дужках."
            ]
          },
          {
            type: "paragraph",
            text: "Ось приклади виразів: (-1), true and false, 1-(2+8). Перший і третій вираз називають арифметичним виразом, другий – логічним."
          },
          {
            type: "paragraph",
            text: "Значення, до якого застосовується операція, називається її операндом. Вираз задає послідовність застосування операцій до операндів. Він має подвійний зміст – задає процес обчислення і має значення. Наприклад, логічний вираз 3*2 = 4 задає процес, у якому обчислюється добуток 3*2 і порівнюються два цілі значення 6 і 4. Шість не дорівнює чотирьом, тому результатом виразу становиться значення, рівне «хибність (false)»."
          },
          {
            type: "paragraph",
            text: "Порядок виконання операцій у виразі визначається неявно завдяки фіксації пріоритетів (старшинства) операцій або явно за рахунок використання дужок. Наприклад для арифметичних операцій пріоритет множення (*) і ділення(/, %) рівний між собою і вищий за рівноправні операції додавання (+) і віднімання (-):"
          },
          {
            type: "code",
            code: "16+3*2-5;\n17\n(16 + 3) * (5-2);\n57",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Результати проміжних операцій у процесі обчислення виразу запам'ятовуються як правило, в регістрах процесора для застосування у подальших операціях виразу. Запам’ятовується і результат виразу для подальшого використання. Він може іменуватися, присвоюватися змінним, виводитися."
          },
          {
            type: "paragraph",
            text: "Іменування є співставленням виразу імені, яке після означення можна записувати в програмі замість виразу. У виразах можна використовувати імена вже іменованих виразів, наприклад:"
          },
          {
            type: "code",
            code: "x=1; y=2*x; z=x+y;",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "В результаті виконання «y=2*x» значення з ім'ям «y» прийме значення «y=2*1=2». Тому значення з ім'ям z після виконання останнього виразу «z=x+y;» позначатиме значення числа 3 (z=x+y=1+2=3;). Якщо значення z рівне 3 не змінюється в подальших обчисленнях програми, тоді z називають сталою або константою. В іншому разі z називають змінною. Змінна величина може бути не обов'язково числовою, а мати значення й іншого типу."
          },
          {
            type: "paragraph",
            text: "Як ми вже зазначали раніше, дані і програми розміщуються в пам’яті. Розмір виділеної під них ділянки пам’яті визначається типом даних. Ім'я змінної, записане в JavaScript-програмі, в результаті трансляції зіставляється з адресою деякої вільної ділянки пам'яті програми, в яку може поміститися значення змінної. При виконанні програми ця адреса і є тією змінною, чиє ім'я записано в програмі. Це співставлення в більшості випадків проходить за рахунок оператора присвоювання."
          },
          {
            type: "paragraph",
            text: "Важливе місце у програмуванні займають логічні вирази або логічні формули."
          },
          {
            type: "paragraph",
            text: "Логічною формулою є:"
          },
          {
            type: "list",
            items: [
              "Будь-яка логічна змінна (змінна, що приймає одне з двох значень: істина або хиба), а також кожна з двох логічних констант (постійних) – «істина» і «хиба», є формулою",
              "Якщо A і B – формули, то not(А), А * В і (А * В) – теж формули, де знак '*' означає будь-яку з логічних бінарних операцій, а not – позначає операцію заперечення"
            ]
          },
          {
            type: "paragraph",
            text: "Формулою є, наприклад, такий вираз «not(x and y)». Кожна формула, при заданих значеннях вхідних в неї змінних, приймає одне з двох значень «істина» або «хиба»."
          },
          {
            type: "paragraph",
            text: "Формули А і В, що залежать від одного і того ж списку змінних x1, x2, x3, ..., xn, називають рівносильними, або еквівалентними, якщо на будь-якому наборі значень змінних x1, x2, x3, ..., xn вони приймають однакові значення. Для позначення рівносильності формул використовується знак рівності, наприклад, А = В."
          },
          {
            type: "paragraph",
            text: "Будь-яку формулу можна перетворити до рівносильної їй, в якій використовуються тільки операції and, or і not. Для перетворення формул в рівносильні користуються законами алгебри логіки."
          },
          {
            type: "paragraph",
            text: "Для логічних операцій в одному логічному виразі прийнятий наступний порядок обчислень:"
          },
          {
            type: "list",
            items: [
              "заперечення - перший, найвищий пріоритет;",
              "кон'юнкція – другий пріоритет;",
              "диз'юнкція – третій пріоритет."
            ]
          },
          {
            type: "paragraph",
            text: "Змінити порядок виконання операцій можна за допомогою вживання дужок. В алгебрі логіки диз'юнкція грає роль, аналогічну додаванню в алгебрі дійсних чисел, кон'юнкція – множення, а заперечення (інверсія значення логічної формули) – унарний мінус."
          },
          {
            type: "paragraph",
            text: "Логічною функцією називається функція, аргументи якої і сама функція приймають значення «істина» або «хиба». Логічні функції можуть бути задані таблично (таблицею істинності) або у вигляді відповідних формул. Одна і та ж функція може задаватися різними формулами. Отже можна стверджувати, що будь-який логічний вираз (логічна формула) реалізує логічну функцію на кінцевому наборі різних значень змінних, які входять у вираз. Програмісту при складанні умови алгоритмічної конструкції розгалуження за словесним описом (висловлюванням) логічного виразу (логічної умови) потрібно побудувати його аналітичний вираз. Для правильної побудови логічного виразу спочатку в складному висловлюванні необхідно виділити елементарні висловлювання, а потім, використовуючи семантику мовних зв'язок, побудувати формулу."
          },
          {
            type: "paragraph",
            text: "Наприклад, у програмі про «забудькуватість Андрійка» нам потрібно маніпулювати із забутою книгою і зошитом. Тоді введемо до розгляду два висловлювання x = «Андрій забув книгу» і y = «Андрій забув зошит». Із них ми можемо побудувати складніші висловлення шляхом використання логічних операцій у складнішій формулі:"
          },
          {
            type: "list",
            items: [
              "not(x) – позначатиме висловлення «Андрій не забув книгу»;",
              "x and y – позначатиме висловлення «Андрій забув книгу і зошит»;",
              "x or y – позначатиме висловлення «Андрій забув книгу або зошит»."
            ]
              }
            ]
      },
      {
        id: 2,
        title: "Примітивні типи JavaScript",
        content: [
          {
            type: "heading",
            text: "Примітивні типи JavaScript"
          },
          {
            type: "paragraph",
            text: "Javascript – мова з динамічною типізацією. Це означає, що змінні не мають чітко фіксованого типу, їх тип визначається із контексту запи-су даного, який присвоєно змінній. Більш того, цей тип може неоднора-зово змінюватись під час виконання скрипту."
          },
          {
            type: "paragraph",
            text: "JavaScript дозволяє працювати з трьома примітивними типами даних: числами, рядками і логічними (булевими). Числовий тип даних використовується для роботи із числами. Рядкові текстові дані тради-ційно характеризують сутність якогось повідомлення, наприклад «Лю-ди, привіт!». Логічний тип застосовується для розпізнання істинності якогось твердження, записаного у формі виразу."
          },
          {
            type: "paragraph",
            text: "У мові також використовуються два спеціальних тривіальних типи даних, null і undefined, кожен з яких визначає тільки одне значен-ня. Їх призначення пояснимо далі."
          },
          {
            type: "paragraph",
            text: "Окрім цих примітивних типів даних, мова підтримує складний (структурований) тип даних, відомий як object. Ми розглянемо об'єкти докладно в окремому розділі."
          },
          {
            type: "paragraph",
            text: "Числа використовуються для задання якихось кількісних харак-теристик природного світу. Наприклад, вагу цукерок у коробці «Вечі-рній Київ» визначає число 500 грамів. Це число у нашій мові вигляда-тиме так:"
          },
          {
            type: "code",
            code: "500;",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "JavaScript не розрізняє цілі числові значеннями і числові значен-ня з плаваючою точкою. Всі числа в мові представлені у вигляді зна-чень з плаваючою точкою, використовуючи формат з плаваючою то-чкою в 64-біти."
          },
          {
            type: "paragraph",
            text: "Рядки використовуються для представлення текстової інформації (символьних даних). Так повідомлення про сутність поняття яке харак-теризується нашим числом 500 може бути такий рядок:"
          },
          {
            type: "code",
            code: "\"Вага цукерок у коробці 500 г\";",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Булеві значення використовують для перевірки істинності твер-дження, описаного виразом. Наприклад, чи любите ви їсти зранку шо-коладні конфети?"
          },
          {
            type: "paragraph",
            text: "Як ми зазначали раніше, поряд із розміщенням у пам'яті важли-вими є й ті операції, які можна застосувати до обраного типу даних. В основному операції, що можна застосувати до екземлярів одного типу не можна застосувати вірно до екземлярів іншого типу."
          },
          {
            type: "heading",
            text: "Змінні в JavaScript"
          },
          {
            type: "paragraph",
            text: "Як ми вже зазначали, змінні можна розглядати як специфічні іме-на фрагментів пам'яті (спеціальні засоби доступу до пам'яті) де знахо-дяться або будуть знаходитися дані (значення). Ви можете помістити дані в ці фрагменти, а потім звернутися до даних, просто називаючи фрагмент через відповідну змінну. Але перед використанням змінної в програмі, ми повинні оголосити їх. Змінні оголошуються за допомогою ключового слова var."
          },
          {
            type: "code",
            code: "var x1 = 3;\nvar x2 = 5;\nvar z1;\nz1;\n// undefined\nz1 = x1+x2;\n// 8",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Тут у перших двох стрічках оголошуються та ініціюються змінні з іменами х1 і х2. Потім оголошується змінна z1. Після звернення до неї в наступному рядку інтерпретатор надрукує значення undefined. Тому що згідно команди var z1; в пам'яті лише виділиться місце, поі-меноване z1. Та після присвоєння цій змінній значення операції дода-вання до двох чисел 3 і 5 до яких ми добралися через відповідні імена х1 і х2 (z1 = x1+x2;) інтерпретатор підставить значення «z1 = 3 + 5;» обчислить вираз 3 + 5 і надрукує результат 8."
          },
          {
            type: "code",
            code: "var y1 = \"Вага конфет у коробці 500 г\";\nvar y2 = \" маленька\";\ny1 + y2;\n// \"Вага цукерок у коробці 500 г маленька\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "У цьому випадку у виразі y1 + y2 знак « + » позначає операцію конкатенації (об'єднання, приєднання) двох рядків. Тому інтерпрета-тор підставить відповідні значення рядків у вираз, об'єднає їх і надру-кує результат – рядок \"Вага цукерок у коробці 500 г маленька\"."
          },
          {
            type: "code",
            code: "z1 - y1;\n// NaN",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Але ми мусимо знати – операндами операції мусять бути тільки змінні або значення того виду (типу) для яких застосована ця операція. Якщо далі ми наберемо:"
          },
          {
            type: "code",
            code: "var z2 = \"Вага цукерок у коробці 500 г\".slice(0,4);\nz2;\n// \"Вага\"\nvar z2 = \"Вага цукерок у коробці 500 г\".slice(5,11);\nz2;\n// \"цукерок\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Для змінних типу рядок існують спеціалізовані операції які реалі-зуються вмонтованими функціями. Наприклад, операція вирізає під-рядок із рядка-операнду. Синтаксис операції та семантика (сутність) побудови результату прості та очевидні."
          },
          {
            type: "code",
            code: "z1 > z2;\n// false\n5 > 3;\n// true",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Булеві змінні і значення позначають істинність або хибність виразу. Так,"
          },
          {
            type: "code",
            code: "у1 > x1;\n// VM451:1 Uncaught ReferenceError: у1 is not defined\n//     at <anonymous>:1:1  (anonymous) @ VM451:1",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Невідповідність операндів і операції призводить до друку пові-домлення про помилку обчислення виразу."
          },
          {
            type: "paragraph",
            text: "Уточнимо визначення ідентифікатора, рядка і числа в JavaScript."
          },
          {
            type: "list",
            items: [
              "Імена змінних можуть бути будь-якої довжини, першим символом повинен бути латинський символ, символ підкреслення (_), або значок долара($). Наступні символами можуть бути латинськими символами, цифрами, підкресленнями або доларами.",
              "Рядки – це послідовність символів між одинарними або подвій-ними лапками. Їх можна з'єднати знаком «+».",
              "Числа бувають цілими, дійсними, вісімковими та шістнадцятко-вими. Дійсні записуються у вигляді «мантиса+порядок». Вісімкові по-чинаються з 0, шістнадцяткові – з 0Х."
            ]
          },
          {
            type: "paragraph",
            text: "Маємо деяку особливість роботи і з логічним типом. Булеві дані містять true або false. При обчисленні виразів 0 еквівалентно false, всі інші числа – true."
          },
          {
            type: "code",
            code: "var s1 = \"abcd\";    //рядок\nvar s2 = ' ff ';     //інший рядок\nvar s3 = \"\";        //пустий рядок\nvar a = 7;           //ціле число 7\nvar b = 8.5e2;       //дійсне число 850\nvar c = 0745;        //вісімкове число\nvar d = 0X26fa4b;    //шістнадцяткове число\nvar b1 = true, b2 = false;  //булеве (логічне)",
            language: "javascript"
          },
          {
            type: "heading",
            text: "Основні операції над даними"
          },
          {
            type: "paragraph",
            text: "Нижче представлені операції, які можна проводити з даними в Javascript з їх коротким описом роботи."
          },
          {
            type: "list",
            items: [
              "a + b - Повертає значення суми лівого та правого числових операндів",
              "a - b - Повертає значення різниці лівого та правого числових операндів",
              "a * b - Повертає значення добутку лівого та правого числових операндів",
              "a / b - Повертає значення частки лівого та правого числових операндів",
              "a % b - Повертає значення остачі від ділення лівого числового операнда на правий числовий операнд",
              "a++, ++a - Збільшує числове значення змінної a на 1",
              "a--, --a - Зменшує числове значення змінної а на 1",
              "a && b - Повертає істину, якщо обидва операнди інтерпретуються, як істина",
              "a || b - Повертає істину, якщо хоча б один операнд інтерпретується, як істина",
              "!a - Повертає протилежне булеве значення відносно булевого значення а",
              "a = b - Присвоєння. Лівому операнду присвоюється значення правого",
              "a == b - Повертає істину, якщо лівий операнд дорівнює правому",
              "a != b - Повертає істину, якщо лівий операнд не дорівнює правому",
              "a === b - Повертає істину, якщо лівий операнд дорівнює правому та вони відносяться до одного типу даних",
              "a !== b - Повертає істину, якщо лівий операнд не дорівнює правому або вони відносяться до різних типів даних",
              "a > b - Повертає істину, якщо лівий операнд більший за правого",
              "a < b - Повертає істину, якщо лівий операнд менший за правого",
              "a >= b - Повертає істину, якщо лівий операнд більший за правого або дорівнює йому",
              "a <= b - Повертає істину, якщо лівий операнд менший за правого або дорівнює йому"
            ]
          },
          {
            type: "heading",
            text: "Оператори роботи з числами"
          },
          {
            type: "paragraph",
            text: "Оператори роботи з числами використовуються в мові для скорочення запису програмного коду."
          },
          {
            type: "subheading",
            text: "Інкрементація та декрементація"
          },
          {
            type: "paragraph",
            text: "У програмах часто зустрічається потреба збільшувати або зменшувати на одиницю значення змінної. Для скорочення запису такої дії використовується відповідно операція інкрементування (++) або декрементування (--)."
          },
          {
            type: "paragraph",
            text: "Так послідовність дій описана наступним фрагментом коду рівносильна:"
          },
          {
            type: "code",
            code: "var x = 5;\nx = x + 1;\nvar y = 10;\ny = y - 1;\nconsole.log(\"x = \" + x); // x = 6\nconsole.log(\"y = \" + y); //y = 9",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "такому синтаксису:"
          },
          {
            type: "code",
            code: "var x = 5;\n++x // x = x + 1;\nvar y = 10;\n--y // y = y - 1;\nconsole.log(\"x = \" + x); // x = 6\nconsole.log(\"y = \" + y); //y = 9",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Ці два оператори «++» і «--» можуть застосовуватися і з синтаксисом коли вони стоять після змінної. Наприклад, «х1++» або «х1--» Та суть такого застосування операторів інша. В цьому випадку збільшення або зменшення відповідно проходить на одиницю, але при зверненні до змінної х1 повертається ще попереднє значення змінної х1. Таке використання інкрементування чи декрементування ілюструє наступний код:"
          },
          {
            type: "code",
            code: "var x1 = 10;\nvar y1;\nconsole.log(\" x1 = \", x1++); // x1 = 10\ny1 = x1 + 2;\nconsole.log(\" y1 = \", y1); //y1 = 13",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Тут, як бачимо, хоч у першому виведенні ми виконали збільшення на 1 але виводиться «старе» значення х1 рівне 10. Та все ж значення х1 стало рівним 11. Про це свідчить виведене значення «y1 = 13» після виконання оператора присвоєння  «y1 = x1 + 2»."
          },
          {
            type: "subheading",
            text: "Оператори плюс-дорівнює (+=), мінус-дорівнює (-=), …(*=), …(/=)"
          },
          {
            type: "paragraph",
            text: "Для інтерпретації алгоритмів у програмному коді часто доводиться задавати реалізацію присвоєння змінній нового значення після зміни старого значення цієї змінної шляхом застосування якихось арифметичних операцій до старого значення і числа."
          },
          {
            type: "paragraph",
            text: "Наприклад, нехай Андрійко має 20 яблук. Бабуся дала йому ще 10 яблук. Скільки яблук стало у Андрійка?"
          },
          {
            type: "paragraph",
            text: "Вирішити це завдання можна застосувавши наступний код:"
          },
          {
            type: "code",
            code: "var countAndrApples = 20;\ncountAndrApples = countAndrApples  + 10;\nconsole.log(\" Андрійко має \" + countAndrApples + \" яблук \");\n// Андрійко має 30 яблук",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Тут змінна countAndrApples перекладом на англійську мову складових свого імені характеризує сутність значення яке вона позначає: count – лічильник (кількість), Andr – Анрійко, Apples – яблука. А надрукований результат «Андрійко має 30 яблук» дає відповідь на поставлене питання."
          },
          {
            type: "paragraph",
            text: "Та для скорочення запису оператор присвоєння «countAndrApples = countAndrApples  + 10;» можна замінити на скорочену форму запису з використанням «+=», яка по суті виконує рівносильні дії, «countAndrApples +=  10;»:"
          },
          {
            type: "code",
            code: "var countAndrApples = 20;\ncountAndrApples += 10;\nconsole.log(\" Андрійко має \" + countAndrApples + \" яблук \");\n// Андрійко має 30 яблук",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Синтаксично вірність такого оператору визначає відсутність між знаками «+» і «=» пробілу. Якщо ми вставимо пробіл, то інтерпретатор надрукує повідомлення про помилку:"
          },
          {
            type: "code",
            code: "var countAndrApples = 20;\ncountAndrApples + = 10;\nconsole.log(\" Андрійко має \" + countAndrApples + \" яблук \");\n// Uncaught SyntaxError: Unexpected token =",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Після того, як Андрійко віддав 6 яблук дідусю, він решту поділив порівну між ним, сестричкою, мамою і татусем. Скільки яблук має після розподілу Андрійко?"
          },
          {
            type: "paragraph",
            text: "Зрозуміло, що зміну кількості яблук у Андрійка описує наступний програмний код:"
          },
          {
            type: "code",
            code: "var countAndrApples = 30;\ncountAndrApples -= 6;     // countAndrApples=countAndrApples - 6;\ncountAndrApples /= 4;     //countAndrApples = countAndrApples / 4;\nconsole.log(\" Андрійко має \" + countAndrApples + \" яблук \");\n// Андрійко має 6 яблук",
            language: "javascript"
          },
          {
            type: "heading",
            text: "Рядки"
          },
          {
            type: "paragraph",
            text: "Розглянемо основні можливості маніпулювання із рядковими даними."
          },
          {
            type: "paragraph",
            text: "Для введення рядка потрібно набрати відкриваючі лапки, потім послідовність символів що утворюють тіло рядка і набрати закриваючі лапки. Наприклад, набравши:"
          },
          {
            type: "code",
            code: "\"Привіт Андрійку\";\n// \"Привіт Андрійку\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Інтерпретатор видасть значення \"Привіт Андрійку\"."
          },
          {
            type: "paragraph",
            text: "Значенню рядка можна надати ім'я."
          },
          {
            type: "code",
            code: "var helloAndry = \"Привіт Андрійку\";\nconsole.log(helloAndry);\n// Привіт Андрійку",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Значення рядка можна присвоїти довільній, попередньо ініційованій змінній:"
          },
          {
            type: "code",
            code: "var helloAndry = true;\nhelloAndry = \"Привіт Андрійку\";\nconsole.log(helloAndry);\n// Привіт Андрійку",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Подивимося на особливість застосування оператора «+». У випадку застосування до числових операндів він буде реалізовувати арифметичну операцію додавання, якщо ж хоча б один ореранд буде мати значення типу рядок, тоді оператор «+» реалізує операцію конкатенації (приєднання) рядків. Наприклад:"
          },
          {
            type: "code",
            code: "var number = 3;\nvar string = \"3\";\nnumber += string                 // число + рядок = рядок\nconsole.log(number);\n// 33\nstring += number                  // рядок + число = рядок\nconsole.log(string);\n// 333",
            language: "javascript"
          },
          {
            type: "code",
            code: "var number = 3;\nvar string = \"3\";\nnumber += number                 // число + число = число\nconsole.log(number);\n// 6\nstring += string;                       // рядок + рядок = рядок\nconsole.log(string);\n// 33",
            language: "javascript"
          },
          {
            type: "code",
            code: "var number = 3;\nvar string = \"3\";\nnumber += number                     // число + число = число\nconsole.log(number);\n// 6\nstring += number;                       // рядок + число = рядок\nconsole.log(string);\n// 36",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Зауважимо, що у випадку конкатенації початок другого рядка приєднується до кінця першого рядка без пропуску. За потреби маємо явно вказати пропуск на початку другого рядка:"
          },
          {
            type: "code",
            code: "var str1 = \"Андрій\";\nvar str2= \"Олександра\";\nstr1 += str2;\nconsole.log(str1);\n// АндрійОлександра",
            language: "javascript"
          },
          {
            type: "code",
            code: "var str1 = \"Андрій\";\nvar str2= \"  Олександра\";   //два пробіли перед Олександра\nstr1 += str2;\nconsole.log(str1);\n// Андрій  Олександра",
            language: "javascript"
          },
          {
            type: "subheading",
            text: "Спеціальні оператори роботи з рядками"
          },
          {
            type: "paragraph",
            text: "Для визначення довжини змінної виду рядка або значення рядка використовується оператор «length». Синтаксис запису його такий: «змінна.length» або «значення.length»."
          },
          {
            type: "code",
            code: "var str1 = \"Андрій\";\nstr1.length;\n// 6",
            language: "javascript"
          },
          {
            type: "code",
            code: "var str2= \"Олександра\";\nconsole.log(str2.length);\n// 12",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "У багатьох випадках потрібно вибирати окремі символи із рядка чи змінної виду рядка за порядковим номером символа в рядку. Нумерація символів починається з нуля. Синтаксис оператора такий: «змінна[порядковий номер]» або «значення[порядковий номер]»."
          },
          {
            type: "code",
            code: "var str1 = \"Андрій\";\nstr1[0];\n// \"А\"",
            language: "javascript"
          },
          {
            type: "code",
            code: "var str1 = \"Андрій\";\nstr1[2];\n// \"д\"",
            language: "javascript"
          },
          {
            type: "code",
            code: "\"Олександра\"[0];\n// \"О\"",
            language: "javascript"
          },
          {
            type: "code",
            code: "\"Олександра\"[5];\n// \"а\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Та іноді потрібно вибирати (вирізати) не окремі символи із рядка чи змінної виду рядка а слово за порядковим номером початкового символу слова і номером останнього символу слова в рядку. Нумерація символів починається із нуля. Синтаксис оператору такий: «змінна.slice(порядковий номер cимволу початку слова , порядковий номер cимволу кінця слова)» або «значення.slice(порядковий номер cимволу початку слова , порядковий номер cимволу кінця слова)» або «змінна.slice(порядковий номер cимволу початку слова)» або «значення.slice(порядковий номер cимволу початку слова)»."
          },
          {
            type: "code",
            code: "var str1 = \"Андрій пішов до школи\";\nstr1.slice(0,6);\n// \"Андрій\"",
            language: "javascript"
          },
          {
            type: "code",
            code: "\"Андрій пішов до школи\".slice(7,12);\n// \"пішов\"",
            language: "javascript"
          },
          {
            type: "code",
            code: "var str1 = \"Андрій пішов до школи\";\nstr1.slice(7);\n// \"пішов до школи\"",
            language: "javascript"
          },
          {
            type: "code",
            code: "\"Андрій пішов до школи\".slice(13);\n// \"до школи\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Для маніпулювання із перетворенням регістрів символів (символ нижнього чи верхнього регістру клавіатури) використовують оператори toUpperCase() i toLowerCase(). Cинтаксис використання операторів продемонструємо на прикладах:"
          },
          {
            type: "code",
            code: "console.log(\"Матуся сварить Андрійка\".toUpperCase());\n// \"МАТУСЯ СВАРИТЬ АНДРІЙКА\"\nvar str1 = \"Матуся сварить Андрійка\";\nstr2 = str1.toUpperCase();\nconsole.log(str2);\n// МАТУСЯ СВАРИТЬ АНДРІЙКА \nstr2 = str2.toLowerCase();\nconsole.log(str2);\n// матуся сварить андрійка",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Пряме застосування цих операторів до рядка не завжди коректне. Як бачимо в останньому прикладі порушено синтаксичні правила української мови. Перше слово речення має починатися із великої букви, аналогічне можна сказати і відносно імені хлопчика. Спробуємо виправити наші помилки, скориставшись потрібною комбінацією зазначених операторів роботи з рядками:"
          },
          {
            type: "code",
            code: "var str1 = \"МАТУСЯ СВАРИТЬ АНДРІЙКА\";\nstrBegin = str1[0];                 //виділили і присвоїли 1-й символ\nstr2 = str1.slice(1,14);           //виділили і присвоїли символи  з  1-го по 14\nstr3 = str1[15];                   //виділили і присвоїли 15-й символ\nstr4 = str1.slice(16);             //виділили і присвоїли символи  з  16-го до кінця  \nstr2 = str2.toLowerCase();          //перевести символи до нижнього регістру\nstr4 = str4.toLowerCase();          //перевести символи до нижнього регістру\nconsole.log(strBegin + str2 + str3 + str4);\n// Матуся сваритьАндрійка",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Між словами «сварить» «Андрійка» відсутній пробіл, тому додамо його:"
          },
          {
            type: "code",
            code: "console.log(strBegin + str2 + \" \" + str3 + str4);\n// Матуся сварить Андрійка",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Чому ж нам не вдалося у першому варіанті вивести вірний рядок? Символ пробілу (пропуску) однаково фіксується і друкується на обох кеглях. Тому виконання оператора str2 = str2.toLowerCase(); дасть в результаті рядок \"Матуся сварить\" без пробілів в кінці рядка (не було чого переводити). Після виведення str2 ми додали пробіл «вручну»."
          },
          {
            type: "paragraph",
            text: "Якщо сутність перетворення зрозуміла, то синтаксичний запис цього перетворення можна скоротити, замінивши конкатенацію змінних на їх значення:"
          },
          {
            type: "code",
            code: "var str1 = \"МАТУСЯ СВАРИТЬ АНДРІЙКА\";\nstr1[0] + str1.slice(1,14).toLowerCase() + \" \" + str1[15] + str1.slice(16).toLowerCase(); \n// \"Матуся сварить Андрійка\"",
            language: "javascript"
          },
          {
            type: "heading",
            text: "Булеві змінні у мові JavaScript"
          },
          {
            type: "paragraph",
            text: "Як ми вже зазначали раніше булева змінна має тільки два значення: істина (true) і хибність (false). До булевих змінних застосовуються логічні оператори (кон'юнкція, диз'юнкція, заперечення), утворюючи логічні вирази. Таблиця істинності цих операторів приводилася раніше."
          },
          {
            type: "paragraph",
            text: "У мові JavaScript кон'юнкція (логічне і) позначається «&&», диз'юнкція (логічне або) позначається «||» і заперечення – «!». Результат оператора кон'юнкція набуде значення true тільки у випадку, коли і перший і другий операнди мають значення true. Результат оператора диз'юнкція прийме значення false тільки у випадку, коли і перший і другий операнди мають значення false."
          },
          {
            type: "paragraph",
            text: "Давайте реалізуємо програмно прийняття рішення матусею Вітою про дозвіл Андрійку грати на планшеті. Матуся дозволяє сину грати, коли він зробив шкільні домашні завдання і на вулиці йде дощ."
          },
          {
            type: "code",
            code: "var itRains = true;\nvar lessonsAreDone = true;\nif (itRains && lessonsAreDone) console.log(\"Дозвіл грати\");\n// Дозвіл грати",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itRains = true;\nvar lessonsAreDone = false;\nif (itRains && lessonsAreDone) console.log(\"Дозвіл грати\");\nelse console.log(\"Заборона гри\");\n// Заборона гри",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Комбінувати в логічних виразах булеві змінні з числами заборонено. Таке використання приводить до семантично незрозумілих результатів без повідомлення про помилку:"
          },
          {
            type: "code",
            code: "var itNumber = 10;\nvar lessonsAreDone = false;\nitResuit = itNumber && lessonsAreDone;\n// false",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itNumber = 10;\nvar lessonsAreDone = true;\nitResuit = itNumber && lessonsAreDone;\n// true",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itNumber = 10;\nvar lessonsAreDone = false;\nitResuit = itNumber || lessonsAreDone;\n// 10",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Та як ми вже зазначали раніше, значення булевої змінної приймає довільний арифметичний вираз порівняння чисел."
          },
          {
            type: "code",
            code: "var itNumber1 = 10;\nvar itNumber2 = 5;\nitResuit = itNumber1 > itNumber2;  // перше число більше, тому\n// true",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itNumber1 = 10;\nvar itNumber2 = 5;\nitResuit = itNumber1 < itNumber2; // 1-е число не менше, тому\n// false",
            language: "javascript"
          },
          {
            type: "subheading",
            text: "Рівний до"
          },
          {
            type: "paragraph",
            text: "У мові є і спеціальний оператор порівняння на абсолютний збіг двох значень. Його називають «рівний до» і позначають «===» (три знаки рівності). Тому не сплутайте із оператором присвоєння «=». Оператор «рівний до» – бінарний. Він приймає значення істина (true), коли два його операнди абсолютно однакові (однаковий тип і однакове значення) та хибність (false) – в іншому випадку. Наприклад, число та булеве значення завжди повертатиме значення false. Але цей оператор можна використовувати для порівняння двох булевих значень, двох рядків."
          },
          {
            type: "code",
            code: "var itNumber1 = 10;\nvar itNumber2 = 5;\nitResult = itNumber1 === itNumber2;\n// false",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itNumber1 = 5;\nvar itNumber2 = 5;\nitResult = itNumber1 === itNumber2;\n// true",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itNumber1 = true;\nvar itNumber2 = 5;\nitResult = itNumber1 === itNumber2;\n// false",
            language: "javascript"
          },
          {
            type: "subheading",
            text: "Подвійний знак рівності"
          },
          {
            type: "paragraph",
            text: "Іноді нам потрібно дізнатися про приблизну рівність двох величин, навіть у випадку, коли вони мають різний тип. Наприклад, потрібно порівняти число і рядок. У цьому випадку варто скористатися оператором порівняння, який позначається «==» (подвійне використання знаку «=»)."
          },
          {
            type: "paragraph",
            text: "Давайте порівняємо число 10 і рядок \"10\":"
          },
          {
            type: "code",
            code: "var itNumber1 = 10;\nvar itNumber2 = \"10\";\nitResult1 = itNumber1 === itNumber2;\n// false\nitResult2 = itNumber1 == itNumber2;\n// true",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "У випадку застосування оператору «===» результат присвоєння набуває значення хибність, у другому випадку («==») – результат істина. Це можливо тому, що у випадку використання «==», JavaScript спочатку приводить значення операндів оператора до одного типу а потім їх порівнює. Та тут потрібно бути досить обережним. Давайте подивимося як інтерпретатор буде реагувати на порівняння 0 (нуля) і false, 0 (нуля) і рядка \"false\":"
          },
          {
            type: "code",
            code: "var itNumber1 = 0;\nvar itNumber2 = false;\nitResult1 = itNumber1 == itNumber2;\n// true",
            language: "javascript"
          },
          {
            type: "code",
            code: "var itNumber1 = 0;\nvar itNumber2 = \"false\";\nitResult1 = itNumber1 == itNumber2;\n// false",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "У першому результат порівняння повертає значення істина тому, що при перетворенні логічного значення в число значення false перетворюється в число нуль (true перетворюється на одиницю) і «0 == 0» поверне значення істина. У другому випадку рядок перетвориться у число, що не дорівнює нулю. Тому результат порівняння буде хибність."
          },
          {
            type: "subheading",
            text: "Спеціальні значення"
          },
          {
            type: "paragraph",
            text: "Ми думаємо, що ви вже при помилкових запусках програм отримували повідомлення «undefined» або «null». Ці значення повертала консоль. Вони не належать до жодному типу або виду або формату значень і використовуються для повідомлення про особливу ситуацію, яка склалася в результаті обчислень."
          },
          {
            type: "paragraph",
            text: "Повідомлення «undefined» сигналізує про те, що на момент звернення до змінної її значення ще не визначено."
          },
          {
            type: "code",
            code: "var itResult1;\nitResult1;\n// undefined",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Повідомлення «null» сигналізує про те, що на момент звернення до змінної її значення ще не належить (не дорівнює) одному із якихось визначених значень. Наприклад, Андрійко має трьох товаришів: Миколку, Женю і Олексу. Для опису ситуації, коли він бачив за день одного із друзів (Олексу), ми можемо скористатись таким фрагментом коду."
          },
          {
            type: "code",
            code: "var andrySeeToday;\nandrySeeToday = \"Олексa\";\nandrySeeToday;\n// \"Олексa\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Тоді для позначення ситуації, коли він не бачив жодного із друзів, можна використати значення «null», таким чином:"
          },
          {
            type: "code",
            code: "var andrySeeToday;\nandrySeeToday = null;\nandrySeeToday;\n// null",
            language: "javascript"
              }
            ]
      },
      {
        id: 3,
        title: "Масив",
        content: [
          {
            type: "heading",
            text: "Масив"
          },
          {
            type: "paragraph",
            text: "Поряд із простими видами даних у програмуванні використовуються складені або структуровані дані. Одним із прикладів останніх, який ми розглянули був тип даних – рядок. Але в рядок ми могли об'єднувати тільки символи. У багатьох випадках нам потрібно об'єднувати у групи різнотипні дані. Така структура дозволяє за необхідності працювати з елементами усього об'єднання, а за потреби – і з окремими елементами групи. Такий підхід дозволяє уніфікувати імена елементів групи та скоротити їх запис."
          },
          {
            type: "paragraph",
            text: "Нехай для вирішення якоїсь задачі нам потрібно працювати із даними, які характеризують товаришів Андрійка: Антон, Віктор, Володимир, Данило, Микола, Сергій, Олекса. Тоді в програму їх можна ввести так:"
          },
          {
            type: "code",
            code: "var andryСomr1 = \"Антон\";\nvar andryСomr2 = \"Віктор\";\nvar andryСomr3 = \"Володимир\";\nvar andryСomr4 = \"Данило\";\nvar andryСomr5 = \"Микола\";\nvar andryСomr6 = \"Сергій\";\nvar andryСomr7 = \"Олекса\";",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Та враховуючи, що змістовно всі змінні andryСomr1, … ,andryСomr7 за змістом характеризують одну сутність (одне поняття) – товаришів Андрійка, їх можна об'єднати у масив (групу):"
          },
          {
            type: "code",
            code: "var andryСomrades = [\"Антон\", \"Віктор\", \"Володимир\", \"Данило\", \"Микола\", \"Сергій\", \"Олекса\"];",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Масивом будемо називати впорядкований набір фіксованої кількості елементів, що зберігаються в послідовно розташованих комірках оперативної пам'яті, мають порядковий номер і спільне ім'я, яке надає користувач. Він має розмір – загальна кількість елементів у масиві. У нашому прикладі розмір масиву andryСomrades рівний 7. Масив у нас одновимірний (відсутні вкладені масиви). Доступ до елементів аналогічний доступу до елементів рядка – за індексом (порядковим номером елемента в групі). Початок нумерації починається з нуля. Так, andryСomrades[0] = \"Антон\", andryСomrades[2] = \"Володимир\"."
          },
          {
            type: "paragraph",
            text: "У JavaScript масив (англ. array) — сукупність елементів впорядкованих за індексами, які зазвичай репрезентовані натуральними числами, що визначають положення елемента в масиві. Пустий масив позначається «[ ]». Масив може бути одновимірним (вектором), та багатовимірним (наприклад, двовимірною таблицею), тобто таким, де індексом є не одне число, а кортеж (сукупність) з декількох чисел, кількість яких збігається з розмірністю масиву. У переважній більшості мов програмування масив є стандартною вбудованою структурою даних."
          },
          {
            type: "paragraph",
            text: "Масиви ефективні при звертанні до довільного елементу, яке відбувається за сталий час. Вони переважно використовуються для зберігання даних, до елементів яких відбувається довільний доступ без додавання або видалення нових елементів, тоді як для алгоритмів з інтенсивними операціями додавання та видалення, ефективнішими є інші структури даних."
          },
          {
            type: "paragraph",
            text: "Враховуючи фіксовану довжину масиву, слід дуже обережно ставитись до процедури звертання до елементів за їхнім індексом, тому що намагання звернутись до елементу, індекс якого перевищує розмір такого масиву (наприклад, до елементу з індексом 10 в нашому прикладі), може призвести до непередбачуваних наслідків."
          },
          {
            type: "code",
            code: "var andryСomrades = [\"Антон\", \"Віктор\", \"Володимир\", \"Данило\", \"Микола\", \"Сергій\", \"Олекса\"];\nandryСomrades[2];\n// \"Володимир\"\n\nandryСomrades[10];\n// undefined",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Збереження одновимірного масиву в пам'яті є тривіальним, тому що сама пам'ять комп'ютера є одновимірним масивом."
          },
          {
            type: "paragraph",
            text: "Спробуємо узагальнити розглянутий нами матеріал відносно вжитої термінології складного типу даних. Масивом називається змінна, утворена послідовністю змінних, причому:\n● кожний компонент (елемент масиву) має свій номер у послідовності (індекс) і відрізняється ним від інших елементів;\n● множина індексів (індексова множина) скінченна й зафіксована в означенні масиву;\n● можливість обробки елемента масиву, або його доступність, не залежить від його місця в послідовності (елементи рівнодоступні)."
          },
          {
            type: "paragraph",
            text: "Кількість елементів індексованої множини називається довжиною масиву. Для більшості мов програмування у подібному визначенні масиву присутня вимога однотипності елементів масиву. Динамічна типізація в JavaScript дозволяє не дотримуватися цього обмеження."
          },
          {
            type: "paragraph",
            text: "Наприклад, ми хочемо об'єднати в масив andryPerson п'ять елементів, які характеризують наступні особливості Андрійка: прізвище – у вигляді символьного рядка (\"Глибовець\"), ім'я – у вигляді символьного рядка (\"Андрійко\"), зріст у сантиметрах – у вигляді цілого числа 137), вагу у кілограмах– у вигляді дійсного числа (34.6), кількості друзів – у вигляді цілого числа (7). Визначити такий масив можна двома способами."
          },
          {
            type: "paragraph",
            text: "Перший – явно, задавши значення елементів при описі масиву:"
          },
          {
            type: "code",
            code: "var andryPerson = [\"Глибовець\", \"Андрійко\", 137, 34.6, 7];\nandryPerson[0]; // \"Глибовець\"\nandryPerson[3]; // 34.6",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Другий – з використанням індексів у квадратних дужках для прямого задання значень відповідних елементів масиву:"
          },
          {
            type: "code",
            code: "var andryPerson = [];\nandryPerson[0] = \"Глибовець\";\nandryPerson[1] = \"Андрійко\";\nandryPerson[2] = 137;\nandryPerson[3] = 34.6;\nandryPerson[4] = 7;\n\nandryPerson[1]; // \"Андрійко\"\nandryPerson[3]; // 34.6",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Наголосимо у цьому способі присутнність початкової ініціалізації пустого масиву шляхом використання опису «var andryPerson = [];». Якщо він буде відсутній, то консоль буде видавати повідомлення про помилку:"
          },
          {
            type: "code",
            code: "var andryPerson[0] = \"Глибовець\";\nandryPerson[1] = \"Андрійко\";\nandryPerson[2] = 137;\nandryPerson[3] = 34.6;\nandryPerson[4] = 7;\n// VM187:1 Uncaught SyntaxError: Unexpected token [",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Окрім одномірних масивів нам потрібний механізм, який би дозволяв укрупнити елементи масиву, наприклад у якості елементу масиву задавати масив. Нехай, у попереднє визначення особи Андрійка, ми хочемо зробити таку зміну – п'ятий елемент var andryPerson[4] має визначати не кількість друзів, а імена друзів. Тоді наше визначення матиме вигляд:"
          },
          {
            type: "code",
            code: "var andryPerson = [\"Глибовець\", \"Андрійко\", 137, 34.6, [\"Антон\", \"Віктор\", \"Володимир\", \"Данило\", \"Микола\", \"Сергій\", \"Олекса\"]];\n\nandryPerson[2]; // 137\nandryPerson[4][2]; // \"Володимир\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Тобто, звернення до елементів у цьому випадку різниться. Синтаксис звернення до простого елементу залишається попереднім («andryPerson[2]»), а звернення до складного елементу ускладнюється таким чином. Якщо ми хочемо дістатися до 2-го елементу складного 5-го елементу, тоді маємо написати звернення за допомогою двох квадратних дужок «andryPerson[4][2]» і у відповідь отримаємо «\"Володимир\"»."
          },
          {
            type: "paragraph",
            text: "Наголосимо, що за такого визначення масиву окреме звернення до 5-го елементу як до цілісного елементу виду «andryPerson[4]» також можливо наведе до такого результату (не забуваємо, що нумерація індексів починається із 0, тому 5-й елемент матиме номер 4):"
          },
          {
            type: "code",
            code: "andryPerson[4];\n// (7) [\"Антон\", \"Віктор\", \"Володимир\", \"Данило\", \"Микола\", \"Сергій\", \"Олекса\"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Виведене число 7 характеризує кількість елементів у andryPerson[4]."
          },
          {
            type: "heading",
            text: "Робота з масивами"
          },
          {
            type: "paragraph",
            text: "Для практичної роботи з масивами маємо використовувати означення масиву і методи. Останні застосовуються для зміни і повернення нових значень масиву."
          },
          {
            type: "paragraph",
            text: "Типовим використанням масиву є розв'язання задачі упорядкування елементів у групі за якоюсь ознакою. Наприклад, ми хочемо із довільного списку друзів Андрійка створити упорядкований список цих друзів відносно довжини імені друга (кількості символів у імені). Таке упорядкування (сортування) можна зробити або за зростанням числа символів у імені або за зменшення цього числа відповідно (за спаданням)."
          },
          {
            type: "paragraph",
            text: "Довільність списку друзів можна реалізувати, організувавши введення імен друзів із клавіатури."
          },
          {
            type: "paragraph",
            text: "Повернемося до опису алгоритму розв'язання поставленої задачі упорядкування за зростанням довжини імен. Будемо дотримуватися такої стратегії. Виберемо ім'я з мінімальною довжиною серед імен масиву і зафіксуємо його індекс. Поміняємо місцями цей елемент із першим елементом масиву. Далі повторимо вибір мінімального елементу із решти елементів масиву і міняємо місцями із відповідним елементом масиву (на другому кроці із другим елементом масиву andryСomrades[n-1]). Процес вибору повторюється n-1 раз."
          },
          {
            type: "code",
            code: "Алгоритм 2.1.\n1. Увести значення n – кількості друзів Андрійка та їх імена в масив andryСomrades[n-1]; .\n2. Для всіх і від 0 до n-1 виконати\n\tПочаток\n\t\tminName = andryСomrades[i];\n\t\tДля всіх j від і+1 до n-1 виконати\n\t\t\tПочаток\n\t\t\t\tЯкщо andryСomrades[j].length < minName.length тоді\n\t\t\t\t\tПочаток \n\t\t\t\t\t\tk = j; /*запам’ятати індекс елементу масиву з мінімальною довжиною*/\n\t\t\t\t\t\tminName = andryСomrades[j]; /*запам’ятати елемент масиву з мінімальною довжиною*/\n\t\t\t\t\tкінець\n\t\t\ttempVariable = andryСomrades[і];  /* поміняти місцями елементи масиву*/\n\t\t\t\tandryСomrades[і] = andryСomrades[k];\n\t\t\t\tandryСomrades[k] = tempVariable;\n\t\t\tВивести на друк andryСomrades[і];\nКінець.",
            language: "text"
          },
          {
            type: "paragraph",
            text: "Побудуємо програмну реалізацію алгоритму, уточнивши кроки алгоритму:"
          },
          {
            type: "code",
            code: "// програма впорядкування імен друзів Андрійка\nvar n = prompt(\"Введіть n: \"); //введення кількості друзів\nvar andryСomrades = [ ]; //початкова ініціалізація масиву імен друзів\nfor ( var i = 0; i <= n-1; i++ ) \n { //введення імен і їх виведення для котролю вірності\n 	andryСomrades[i] =  prompt(\"Введіть чергове ім'я: \"); \n 	console.log(andryСomrades[i]+\"  \"+i+\" – й  ел-нт\" );\n   };\nconsole.log(\"Початок роботи і результат обробки\");\nfor ( var i = 0; i <= n-1; i++ ) \n { // визначення і-го мінімального елементу\n   minName = andryСomrades[i]; \n     //початковий мінімальний елемент і-го кроку\n   k=i;         // та його індекс\n    for ( var j = i+1; j <= n-1; j++ ) \n    { //порівнюємо всі наступні елементи з мінімальним\n	  if (andryСomrades[j].length < minName.length)\n              { k = j;\n                 minName = andryСomrades[j];\n                  /* якщо знайшовся менший, тоді він становиться тим  часовим  мінімальним та запам'ятовуємо його індекс*/\n               };\n      }\n   /* найменший елемент серед andryСomrades[j],   andryСomrades[j+1],..., andryСomrades[n-1] знайдено - це andryСomrades[k]. Поміняємо його місцями з andryСomrades[i] */\n   tempVariable = andryСomrades[i];   \n   andryСomrades[i] = andryСomrades[k];\n   andryСomrades[k] = tempVariable;\n// виведемо на друк чергове і-те мінімальне за довжиною ім'я\n console.log(andryСomrades[i] +\"  \"+i+\" – й елемент\" );\n  };",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Запустивши цю програму на виконання, та ввівши вхідні дані, отримаємо:"
          },
          {
            type: "code",
            code: "віктор  0 – й  ел-нт\nпавло  1 – й  ел-нт\nмикола  2 – й  ел-нт\nженя  3 – й  ел-нт\nсаня  4 – й  ел-нт\nандрій  5 – й  ел-нт\ндмитро  6 – й  ел-нт\nПочаток роботи і результат обробки\n--------------------------------------------------\nженя  0 – й елемент\nсаня  1 – й елемент\nпавло  2 – й елемент\nвіктор  3 – й елемент\nмикола  4 – й елемент\nандрій  5 – й елемент\ндмитро  6 – й елемент\nundefined",
            language: "text"
          },
          {
            type: "paragraph",
            text: "Якщо ви звернули увагу, то деякі конструкції ми застосували вперше. Насамперед, це введення даних з клавіатури. У мові є декілька засобів для таких дій. Ми скористалися простою конструкцією var n = prompt(\"Введіть n: \"); вводу даних з клавіатури. Зустрівши цю інструкцію, інтерпретатор виводить на екран вмонтоване вікно з назвою «Повідомлення з цієї сторінки». У віконці буде надруковано текст із нашої команди «Введіть n:» і пустий прямокутник. Інтерпретатор чекає введення значення для нашої змінної «n», вказаній у команді. Якщо ми хочемо присвоїти n значення 7, тоді на клавіатурі набираємо значення 7 та натискаємо Enter. Число 7 відобразиться у прямокутнику і в пам'ять, поіменовану змінною n, заноситься значення цілого числа 7."
          },
          {
            type: "image",
            src: "/images/image073.png",
            alt: "Приклад використання prompt"
          },
          {
            type: "paragraph",
            text: "Ми спеціально ввели в якості параметру довжини масиву змінну, щоб можна було запускати на виконання нашу програму для різної кількості друзів. Так, якщо у Андрія стане 11 друзів, то запустимо той же текст програми на виконання, змінивши лише при вводі значення 7 на 10, тобто ввівши значення 10."
          },
          {
            type: "paragraph",
            text: "Далі командою «var andryСomrades = [ ];» ми оголошуємо масив друзів Андрійка з іменем andryСomrades. Увівши значення n рівне 7, ми зазначили, що будемо мати справу із 7 друзями Андрійка. Тобто довжина (кількість елементів) масиву рівна 7. Отже нам для подальшої обробки потрібно десь взяти і занести в пам’ять компа 7 імен друзів Андрійка. Та ми вже знаємо одну із таких можливостей – це введення даних із клавіатури. Пам’ятаючи те, що нумерація елементів масиву починається із нуля, організуємо циклічне введеня семи імен:"
          },
          {
            type: "code",
            code: "for ( var i = 0; i <= n-1; i++ ) \n { //введення імен і їх виведення для котролю вірності\n \tandryСomrades[i] =  prompt(\"Введіть чергове ім’я: \"); \n \tconsole.log(andryСomrades[i]+\"  \"+i+\" – й  ел-нт\" );\n   };",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Цю конструкцію природно можна проінтерпретувати таким чином. Повторити дії, визначені оператором групування «{ }» «andryСomrades[i] =  prompt(\"Введіть чергове ім’я: \");» і «console.log(andryСomrades[i]+\"  \"+i+\" – й  ел-нт\" );» 7 раз. Кількість повторних дій визначається значенням параметра «і» вказаним у заголовку «( var i = 0; i <= n-1; i++ )» оператора циклу for."
          },
          {
            type: "paragraph",
            text: "Згадаймо як інтерпретується цей заголовок. Для змінної « і » починаючи від «і=1» виконати повторні дії із оператором «{ }» до тих пір, поки «i <= n-1» збільшуючи значення і на одиницю «i++». А n у нас рівне 7. Тому і у нас буде приймати значення 0, 1, 2, 3, 4, 5, 6=n-1=7-1. Тоді перший раз будуть викликатися оператори «andryСomrades[0] = prompt(\"Введіть чергове ім’я: \");» і відповідно «console.log(andryСomrades[0]+\"  \"+i+\" – й  ел-нт\" );». Друга команда тут застосовується для контролю правильності введення імен друзів. Згідно команди «andryСomrades[0] = prompt(\"Введіть чергове ім’я: \");» на екрані з’явиться прямокутник із заголовком «Введіть чергове ім’я:» і ви маєте ввести з клавіатури ім’я першого друга «віктор». У пам’ять поіменовану змінною (елементом масиву) andryСomrades[0]занесеться значення символьного рядка «віктор»."
          },
          {
            type: "paragraph",
            text: "Потім відбудеться друк для перевірки, збільшення параметра циклу на 1 «i++» (і стане рівним 1) і керування буде передано на заголовок циклу. Прийдемо на перевірку можливості виконання тіла циклу «i <= n-1». У нас ця умова матиме вигляд «1 <= 6», Нагадаємо, що n-1=6. Умова виконується. Тому будуть викликатися оператори «andryСomrades[1] = prompt(\"Введіть чергове ім’я: \");» і відповідно «console.log(andryСomrades[1]+\"  \"+i+\" – й  ел-нт\" );». Згідно з командою «andryСomrades[1] = prompt(\"Введіть чергове ім’я: \");» на екрані з’явиться прямокутник із заголовком «Введіть чергове ім’я:» і ви маєте ввести з клавіатури ім’я другого друга «павло». У пам’ять, поіменовану змінною (елементом масиву) andryСomrades[1] занесеться значення символьного рядка «andryСomrades[1]»."
          },
          {
            type: "paragraph",
            text: "Потім відбудеться перевіряючий друк, збільшення параметра циклу на 1 «i++» (і стане рівним 2) і керування передається на заголовок циклу. Прийдемо на перевірку можливості виконання тіла циклу «i <= n-1». У нас ця умова прийме вигляд «2 <= 6». Умова виконується. Тому будуть викликатися оператори «andryСomrades[2] = prompt(\"Введіть чергове ім’я: \");» і відповідно «console.log(andryСomrades[1]+\"  \"+i+\" – й  ел-нт\" );». Водимо третього друга «микола»."
          },
          {
            type: "paragraph",
            text: "Потім відбудеться друк для перевірки, збільшення параметра циклу на 1 «i++» (і стане рівним 3) і керування передається на заголовок циклу і т.д."
          },
          {
            type: "paragraph",
            text: "Після введення імені сьомого друга «дмитро» відбудеться друк для перевірки, збільшення параметра циклу на 1 «i++» (і стане рівним 7) і керування передається на заголовок циклу. Прийдемо на перевірку можливості виконання тіла циклу «i <= n-1». У нас ця умова прийме вигляд «7 <= 6». Умова не виконується. Тому тіло циклу вже не виконується і управління передається на обробку наступного (за оператором for) оператора."
          },
          {
            type: "paragraph",
            text: "У нашій програмі це оператор «console.log(\"Початок роботи і ре-зультат обробки\");». Він надрукує на екрані повідомлення «Початок роботи і результат обробки», засвідчуючи закінчення вводу даних і початок їх обробки."
          },
          {
            type: "paragraph",
            text: "Перед коментарем подальших конструкцій нашої програми давайте пригадаємо, як ви впорядковували щось, наприклад виконували завдання мами на впорядкування за зростанням купи яблук. Ви обирали найменше, клали його на перше місце. Викидали його з розгляду, зменшивши купу на одиницю (викидали з розгляду одну позицію) і повторювали процес обрання найменшого яблука та переміщення його на останнє місце у відсортованій частині купи доти, поки у купі залишалися ще яблука (позиції) для порівняння."
          },
          {
            type: "paragraph",
            text: "А як нам обрати найменший елемент із якоїсь купи (підкупи). Природно застосувати такий підхід. Зафіксуємо спочатку в якості найменшого перший елемент купи. Далі порівняємо його із усіма іншими (ітераційний процес). Якщо значення нового елемента при черговому порівнянні менше за попередньо обране мінімальне, тоді фіксуємо місце цього елементу в купі і присвоюємо значення цього елементу мінімальному елементу. Перебравши на порівняння всю купу в кінці будемо знати як значення мінімального елементу, так і його позицію в купі."
          },
          {
            type: "paragraph",
            text: "Отже реалізовуємо вищезазначене."
          },
          {
            type: "code",
            code: "for ( var i = 0; i <= n-1; i++ ) \n { // визначення і-го мінімального елементу\n    minName = andryСomrades[i]; /*початковий мінімальний еле-мент  і-го   кроку*/\n   k=i;                                               // та його індекс\n    for ( var j = i+1; j <= n-1; j++ ) \n    { //порівнюємо всі наступні елементи з мінімальним\n                 if (andryСomrades[j].length < minName.length)\n           {  /* якщо знайшовся менший, тоді він становиться тимча-совим  мінімальним та запам'ятовуємо його індекс*/\n          k = j;\n          minName = andryСomrades[j];\n       };\n    }\n   /* найменший елемент серед andryСomrades[j], andryСomrades[j+1],..., andryСomrades[n-1] знайдено - це andryСomrades[k]. Поміняємо його місцями з andryСomrades[i] */.",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Але ми ще не розглядали обмін значеннями двох змінних. Як нам переприсвоїти (поміняти місцями) значення двох фрагментів пам’яті? Це завдання нагадує нам задачу переміщення яблучного і виноградного соку із однієї чашки в іншу."
          },
          {
            type: "paragraph",
            text: "Нехай батько готував сніданок. Він у чашку сина налив яблучний сік а у чашку дочки налив виноградний. Та він переплутав уподобання своїх діток. Дочка любить яблучний сік а син –виноградний. Потрібно поміняти наповнення чашок. Як розв'яже цю задачу батько?"
          },
          {
            type: "paragraph",
            text: "Природно він знайде третю подібну за розміром чисту чашку, переллє у неї наповнення чашки дочки. Помивши чашку дочки, батько переллє до неї виноградний сік із чашки сина. Помивши чашку сина, батько переллє до неї виноградний сік із допоміжної чашки. Тобто потрібно скористатися допоміжним проміжним засобом збереження вмісту."
          },
          {
            type: "paragraph",
            text: "Скористаємося цією ідеєю для переприсвоєння значень двох змінних andryСomrades[i] та andryСomrades[k]. Введемо до розгляду третю додаткову змінну tempVariable та проробимо подібні маніпуляції до чашок:"
          },
          {
            type: "code",
            code: "tempVariable = andryСomrades[i];   \nandryСomrades[i] = andryСomrades[k];\nandryСomrades[k] = tempVariable;.",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Обране і-те мінімальне ім’я вже знаходиться на потрібному місці в масиві (купі), тож можемо вивести його на друк, тобто виводимо на друк чергове і-те мінімальне за довжиною ім'я:"
          },
          {
            type: "code",
            code: "console.log(andryСomrades[i] +\"  \"+i+\" – й елемент\" );",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Ітераційний вибір мінімального за довжиною імені та його друк закінчується при переборі всіх елементів масиву (купи). У результаті роботи програму маємо впорядкований у пам’яті масив імен друзів Андрійка та його відображення на екрані компа."
          },
          {
            type: "paragraph",
            text: "Наголосимо, що цю програму можна використовувати для іншої кількості друзів або впорядкування за довжиною довільних рядків символів."
          },
          {
            type: "paragraph",
            text: "Так, для чотирьох нових друзів Андрійка (Микола, Вітя, Дмитро, Ян) потрібно запустити програму на виконання, ввести значення n =4, потім ввести чотири ім’я. В результаті роботи програми отримаємо друк:"
          },
          {
            type: "code",
            code: "Ян  0 – й елемент\nВітя  1 – й елемент\nДмитро  2 – й елемент\nМикола  3 – й елемент",
            language: "text"
          },
          {
            type: "heading",
            text: "Визначення довжини масиву"
          },
          {
            type: "paragraph",
            text: "Тут знову можемо скористатися аналогією із рядками. Після певних маніпуляцій у програмі із занесенням нових елементів і видаленням елементів за потреби уточнити довжину масиву можна скористатися вмонтованою функцією (властивістю) «length». Синтаксис її застосування збігається із синтаксисом використання довжини рядку."
          },
          {
            type: "paragraph",
            text: "Наприклад, для визначення довжини нашого масиву (кількості елементів) andryСomrades потрібно додати length через крапку:"
          },
          {
            type: "code",
            code: "andryСomrades.length\n// 4",
            language: "text"
          },
          {
            type: "paragraph",
            text: "Використовуючи цю конструкцію та пам’ятаючи, що нумерація елементів починається з 0, можна завжди знайти значення індексу останнього елементу в масиві ось так:"
          },
          {
            type: "code",
            code: "andryСomrades.length-1;\n// 3",
            language: "javascript"
          },
          {
            type: "heading",
            text: "Додавання елементів до масиву"
          },
          {
            type: "paragraph",
            text: "Додати новий елемент на початок масиву можна двома способами. Нехай, до нашого останнього списку друзів Андрійка (Ян, Вітя, Дмитро, Микола) нам потрібно додати ім’я Павло."
          },
          {
            type: "paragraph",
            text: "Перший спосіб – зробити зсув усіх елементів на один елемент вправо, а потім нове значення поставити на першу позицію:"
          },
          {
            type: "code",
            code: "var andryСomrades=[\"Ян\", \"Вітя\", \"Дмитро\"];\nj=andryСomrades.length-1;\nvar j = andryСomrades.length-1;  /* j стане  = 2 – визначає значення ін-дексу останнього елементу масиву andryСomrades;  */\n    for (var i = j; i >= 0; i-- )    /* зсуваємо, починаючи із  останнього елементу масиву andryСomrades всі елементи на одну позицію впра-во */\n      andryСomrades[i+1] = andryСomrades[i];\n   andryСomrades[0] = \"Павло\"; ;      andryСomrades[0]= \"Павло\" /*на звільнену початкову позицію у   масив  andryСomrades[0]  заносимо  \"Павло\" */\nandryСomrades;\n// (4) [\"Павло\", \" Ян \", \" Вітя \", \" Дмитро \"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Другий спосіб – використати спеціальний метод .unshift(елемент) в якому реалізовано подібні до описаних вище дій по зсуву усіх елементів на один елемент вправо, а потім вставка нового значення на першу позицію:"
          },
          {
            type: "code",
            code: "var andryСomrades=[\"Ян \", \" Вітя \", \" Дмитро\"];\nandryСomrades;\nandryСomrades.unshift(\"Павло\");\nandryСomrades;\n// (4) [\"Павло\", \"Ян \", \"Вітя\", \"Дмитро\"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Наголосимо, що застосування (виклик) методу .unshift(\"Павло\"); додає елемент на початок масиву і повертає нове значення довжини масиву (4)."
          },
          {
            type: "paragraph",
            text: "Аналогічно працює і метод .push(елемент), додаючи новий елемент, значення якого міститься в дужках, в кінець масиву:"
          },
          {
            type: "code",
            code: "var andryСomrades=[\"Ян\", \" Вітя\", \"Дмитро\"];\nandryСomrades;\nandryСomrades.push(\"Павло\");\nandryСomrades;\n// (4) [\"Ян\", \"Вітя\", \"Дмитро\", \"Павло\"]",
            language: "javascript"
          },
          {
            type: "heading",
            text: "Видалення елементу із масиву"
          },
          {
            type: "paragraph",
            text: "Видалення елементу із масиву можна за допомогою двох методів pop i shift. Перший видаляє останній елемент масиву, а другий – перший елемент масиву. Синтаксис їх використання однаковий і має вигляд:\nназва_масиву.назва_методу();"
          },
          {
            type: "paragraph",
            text: "Та ці методи виконують ще одну функцію в порівнянні із попередніми методами роботи із масивами. Вони повертають значення видалених елементів масиву. Тобто, це повернуте значення може бути присвоєно якійсь змінній і використовуватись в подальшому."
          },
          {
            type: "paragraph",
            text: "Наприклад, нам потрібно розв’язати таке завдання. У масиві друзів Андрійка потрібно поміняти місцями перший і останній елемент. Фрагмент вирішення цього завдання може мати вигляд:"
          },
          {
            type: "code",
            code: "var andryСomrades=[\"Ян\", \"Вітя\", \"Дмитро\", \"Павло\"];\nvar lastName = andryСomrades.pop();\nconsole.log(lastName);\nconsole.log(andryСomrades);\nvar firstName = andryСomrades.shift();\nconsole.log(firstName);\nconsole.log(andryСomrades);\nandryСomrades.push(firstName);\nconsole.log(andryСomrades);\nandryСomrades.unshift(lastName);\nconsole.log(andryСomrades);\nconsole.log(lastName);\nconsole.log(firstName);\n// Павло\n// (3) [\"Ян  \"Вітя\", \" Дмитро\"]\n// Ян \n// (2) [\" Вітя \", \" Дмитро\"]\n// (3) [\" Вітя \", \" Дмитро\", \"Ян \"]\n// (4) [\"Павло\", \" Вітя \", \" Дмитро\", \"Ян \"]\n// Павло\n// Ян",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Для пояснення наших дій скористаємося поступовим запуском наших методів і виведення на друк результатів їх роботи."
          },
          {
            type: "code",
            code: "/* початкове задання масиву друзів */\nvar andryСomrades=[\"Ян\", \"Вітя\", \"Дмитро\", \"Павло\"];\n/*видалення останнього елементу і присвоєння цього видаленого значення змінній lastName lastName*/;\nvar lastName = andryСomrades.pop();\n// Виведення значення змінної lastName\nlastName; \n//\"Павло\"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Щоб пересвідчитися у видаленні виведемо решту масиву:"
          },
          {
            type: "code",
            code: "andryСomrades;         // Виведення значення решти масиву\n// (3) [\"Ян \", \" Вітя \", \" Дмитро\"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Нагадаємо, що виведене число 3 характеризує довжину масиву."
          },
          {
            type: "paragraph",
            text: "Видалимо перший елемент і збережемо його значення у змінній firstName та надрукуємо це значення."
          },
          {
            type: "code",
            code: "/*видалення першого еле-менту решти масиву і присвоєння цього видаленого значення змін-ній firstName */\nvar firstName = andryСomrades.shift();\nfirstName; // Виведення значення змінної firstName\n// \"Ян \"",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Подивимося що у нас залишилося:"
          },
          {
            type: "code",
            code: "andryСomrades;      // Виведення значення решти масиву\n// (2) [\" Вітя \", \" Дмитро\"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Наразі залишилося вставити перший елемент в кінець масиву. Можемо скористатися випробуваним методом push."
          },
          {
            type: "code",
            code: "andryСomrades.push(firstName);\n/* Вставка  значення змінної firstName \nв кінець решти масиву */\n           andryСomrades;    // Виведення значення решти масиву\n// (3) [\" Вітя\", \"Дмитро\", \"Ян\"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Та додаємо останній елемент на початок масиву, скориставшись методом unshift."
          },
          {
            type: "code",
            code: "andryСomrades.unshift(lastName);  /* Вставка  значення змінної \nlastName  на початок  решти масиву */\nandryСomrades;        // Виведення значення решти масиву\n// (4) [\"Павло\", \" Вітя\", \"Дмитро\", \"Ян\"]",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "Завдання виконано."
          },
          {
            type: "paragraph",
            text: "Зробимо декілька зауважень. У JavaScript не існує окремого типу «символ». Тому коли ми кажемо символ, розуміємо, що на думці маємо рядок із одного символу. Зміст створеного рядка символів не можна змінити. Як тільки рядок створений – він такий назавжди. Можливо лише створити повністю новий рядок і присвоїти в змінну замість старого рядка."
          },
          {
            type: "paragraph",
            text: "Як ми зазначали раніше, для відлагодження програм і спрощення введення вхідних даних програми використовуються псевдовипадкові значення даних. Розглянемо приклад їх застосування на прикладі програми, що реалізує класичний алгоритм знаходження суми значень елементів деякої послідовності чисел:"
          },
          {
            type: "code",
            code: "/* програма знаходження суми значень елементів масиву ви-значених псевдовипадковим чином*/\nvar n = prompt(\"Введіть n: \"); //вв-ення кіль-сті елементів маси-ва\nvar Mas = [ ]; //початкова ініціалізація масиву\nvar Sum = 0; //початкова ініціалізація суми\nfor ( var i = 0; i <= n-1; i++ ) \n { /*визначення псевдозначень елементів масиву за допомоги стандартних методів, обчислення чергової суми і їх виведення для котролю вірності обчислення*/\n    Mas[i] = Math.floor(Math.random() * 100); \n    Sum = Sum + Mas[i];\n    console.log(Mas[i] + \" елемент  \" + i + \" сума рівна  \" + Sum );\n };\n// 79 елемент 0 сума рівна  79\n// 42 елемент  1 сума рівна  121\n// 7  елемент  2 сума рівна  128\n// 91 елемент  3 сума рівна  219\n// 72 елемент  4 сума рівна  291\n// 78  елемент 5 сума рівна  369\n// 79  елемент 6 сума рівна  448\n// 8  елемент 7 сума рівна  456\n// 13  елемент 8 сума рівна  469\n// undefined",
            language: "javascript"
          },
          {
            type: "paragraph",
            text: "У цій програмі вводиться число n, що визначає кількість цілих чисел у послідовності (довжину послідовності). Послідовність реалізує масивом Mas. Значення чергового елементу послідовності визначається викликом методів Math.floor() і Math.random()."
              }
            ]
      },
      {
        id: 4,
            title: "Об'єкти",
        content: [
          {
            type: "heading",
            text: "Об'єкти"
          },
          {
            type: "paragraph",
            text: "Об'єкт – це колекція іменованих значень, які зазвичай називають властивостями (properties) об'єкта або ключами об'єкта, або полями об'єкта. Об'єкти JavaScript відрізняються від масивів доступом до елементів та відсутністю їх упорядкування. Для доступу до об'єктів використовуються рядки, а не числа. Ці рядки називають ключами, або властивостями, або полями, а елементи, які їм відповідають, – значеннями."
          },
          {
            type: "paragraph",
            text: "Ми зупинимося на використанні терміну ключ та пари «ключ-значення». Об'єкти застосовують до опису предметів або понять складної структури у випадку коли за необхідності ми можемо маніпулювати з неподільним предметом або поняттям, а за потреби можемо доступитися і обробляти їх окремі компоненти (складові)."
          },
          {
            type: "paragraph",
            text: "Наприклад, в попередньому розділі ми створювали масиви, що зберігали назви друзів Андрійка. Але ж для багатьох прикладних задач одного імені буде недостатньо для висвітлення особливостей друга. Наприклад, як написати програму, яка буде формувати впорядкування друзів за зростом? Це ми можемо зробити, ввівши до розгляду змінну friend типу об'єкт з двома ключами. Перший ключ призначений для задання імені друга, а другий – зросту. Синтаксично таке оголошення для друга з ім’ям Віктор і зростом 132 см можна відобразити так:"
          },
          {
            type: "code",
            code: "var friend = {\n\t\"name\": \"Віктор\",\n    \" growth \": 132\n};"
          },
          {
            type: "paragraph",
            text: "Як видно, синтаксис задання подібний до визначення масиву. Відмінність полягає у заміні квадратних дужок «[]» на фігурні {}. Все, що стоїть після знаку, « = » називають літералом об’єкту. Літерал об'єкта – це вираз, який створює й ініціалізує новий об'єкт щоразу, коли проводиться обчислення цього виразу."
          },
          {
            type: "paragraph",
            text: "Існують декілька способів звернення до властивості об'єкта. Найпростіше звернення називають точковим: потрібно вказати ім'я об'єкта, потім точку і ім'я ключа (властивості). Наприклад, доступ до значення \"Віктор\" у нашому прикладі забезпечить звернення friend.name."
          },
          {
            type: "paragraph",
            text: "Ключі об'єктів наслідують основні властивості змінних JavaScript – вони можуть містити будь-який тип даних."
          },
          {
            type: "paragraph",
            text: "Як згадувалося раніше, функцію, яка зберігається у властивості об'єкта, часто називається методом, а ім'я властивості стає ім'ям методу. При виклику методу об'єкта спочатку використовується оператор «точка» для вказівки функції, а потім () для виклику цієї функції. Наприклад, метод log об'єкта з ім'ям console можна викликати так:"
          },
          {
            type: "code",
            code: "console.log(\"Привіт\");."
          },
          {
            type: "paragraph",
            text: "Об'єкти можуть використовуватися для побудови асоціативних масивів, у яких окремі значення зв’язуються (асоціюються) з певними рядками."
          },
          {
            type: "paragraph",
            text: "Резюмуючи можна сказати, що об'єкти – це невпорядковані колекції властивостей, кожна з яких має своє ім'я та значення. Іменовані значення, що зберігаються в об'єкті, можуть бути даними елементарних типів, такими як числа або рядки, або самі можуть бути об'єктами."
          },
          {
            type: "heading",
            text: "Створення об'єкта"
          },
          {
            type: "paragraph",
            text: "Найпростіший спосіб створення об'єктів полягає у включенні в оголошення змінної літералу об'єкта. Синтаксис такого створення наступний:"
          },
          {
            type: "code",
            code: "var ідентифікатор = літерал об'єкта;"
          },
          {
            type: "paragraph",
            text: "Літерал об'єкта може бути простий або складний. У першому випадку він приймає вигляд:\n{ \"ім’я1\": значення1},\nдодамо що якщо ім’я1 не містить пробілу, то «\"» можуть не вживатися. У другому випадку літерал має синтаксис:\n\t\t{ \"ім’я1\": значення1,\n\t\t   \"ім’я2\": значення2 ,\n                          . . .\n\t\t   \"ім’яN\": значенняN }"
          },
          {
            type: "paragraph",
            text: "Ключі літералу мають бути обов’язково рядкового типу, а значення – якого завгодно типу, навіть константами або виразами JavaScript."
          },
          {
            type: "paragraph",
            text: "Наведемо кілька прикладів створення об'єктів:"
          },
          {
            type: "code",
            code: "var empty = {}; // Об'єкт без властивостей\nvar coord = {x: 5, y: 10};\nvar friend= {\n\t\t\"Name\": \"Віктор Глушко\",\n\t\t\"Age\": 10,\n\t\tgrowth: 132};"
          },
          {
            type: "paragraph",
            text: "За такого опису для доступу до всього об'єкта можна звернутися за його іменем, а до властивостей за за його іменем і ключем за таким синтаксисом:\nfriend [\"Age\"] або friend [growth]."
          },
          {
            type: "paragraph",
            text: "Створити об’єкт можна поступовим привнесенням у пустий об’єкт нових властивостей, наслідуючи методологію роботи з масивом, тобто додавати властивості як елементи масива, – але використовуючи рядки замість чисел у позначенні ключа властивості. Наприклад, попередньо визначений об’єкт friend можна було б створити так:"
          },
          {
            type: "code",
            code: "var friend= {}; // Оголошення об'єкт а без властивостей\nfriend[\"Name\"] = \"Віктор Глушко\";  /* оголошення властивості «прізвище_ім’я » об’єкта friend з ключем [\"Name\"] і значенням \"Віктор Глушко\" */\nfriend[\"Age\"] = 10;  /* оголошення властивості «вік » об’єкта friend з ключем [\"Age\"] і значенням 10    */\nfriend[\"Growth\"] = 132;  /* оголошення властивості «зріст» об’єкта friend з ключем [\"Growth\"] і значенням 132   */\nfriend.Age; /*звернення до  властивості «зріст» об’єкта friend з ключем  Age, отримання значення властивості*/\n// 10\nfriend.mark;  /*звернення до  не існуючої властивості «оцінка» об’єкта friend з ключем  Mark */\n// undefined"
          },
          {
            type: "paragraph",
            text: "Перевірку факту наявності тієї чи іншої властивості в об'єкта можна зробити, скориставшись або оператором in, або явної перевірки наявності значення у цій властивості. Синтаксис оператору наступний:\nім'я властивості у вигляді рядка in об'єкт, що перевіряється; ."
          },
          {
            type: "paragraph",
            text: "Продемонструємо використання оператору in на прикладі:"
          },
          {
            type: "code",
            code: "if ( \"Age\" in friend) friend.Age = 12; /*Якщо об'єкт має властивість з ключем \" Age \", встановити його нове значення 12*/\nif ( \"Mark\" in friend) friend.Mark = 7\nelse friend.Mark = 6;\nfriend.Age;\nfriend.Mark;\n// 6\nfriend.Age;\n// 12"
          },
          {
            type: "paragraph",
            text: "Та без оператора in можна обійтися, використавши знання про те, що при зверненні до неіснуючої властивості повертається значення undefined:"
          },
          {
            type: "code",
            code: "/* Якщо властивість зріст з ключем  growth об’єкта friend існує і його значення  не дорівнює undefined, присвоїти змінній у значення цього ключа. */\nif (!(friend.growth == undefined)) y = friend.growth;\ny;\n// 132\n/* Якщо властивість оцінка з ключем  mark об’єкта friend існує але його значення  не  визначене (дорівнює undefined), визначити значення цього ключа, присвоївши йому значення 7. */\nif(friend.mark == undefined) friend.mark = 7;\n friend.mark;\n// 7"
          },
          {
            type: "heading",
            text: "Об'єкти як асоціативні масиви"
          },
          {
            type: "paragraph",
            text: "Отже, ми вже вивчили дві можливості доступу до властивостей об'єкта: «точковий» або за допомогою оператора «[]». Так записи «friend[\"growth\"]» і «friend.growth» позначають доступ до однієї властивості «зріст» об’єкту friend за ключем growth. Важлива відмінність у використанні цих двох синтаксичних форм полягає в тому, що перший запис визначає ключ властивості як рядок, а другий визначає ключ властивості як ідентифікатор."
          },
          {
            type: "paragraph",
            text: "Оскільки JavaScript – динамічно типізована мова, то вона дозволяє у програмі створювати довільну кількість властивостей у будь-якому об'єкті. Однак у разі використання «точкового доступу» до властивості об'єкта ключ властивості задається ідентифікатором. А ідентифікатори в програмі представляють собою послідовність символів які є частиною тексту програми, що не можуть бути змінені в процесі роботи програми."
          },
          {
            type: "paragraph",
            text: "Ключ властивості буде рядком, якщо застосувати звернення до властивості об'єкта за допомогою нотації оператору «[]». А рядки JavaScript можуть створюватись та змінюватись під час роботи програми – ОБРОБЛЯТИСЯ, використовуючи синтаксис обробки масивів!!!!."
          },
          {
            type: "paragraph",
            text: "Давайте розглянемо такий приклад. Нехай Олександрі (Саші) терміново потрібно допомогти «хрещеній мамі» навести лад в обліку книжок у магазині та підготовки звітності за параметрами, які наперед невідомі. Вирішили, що на початок написання програми, Саші відомо тільки про потребу оцінити вартість усіх книжок. Яка подальша інформація буде цікавити господаря магазину поки не відомо, та невідома і форма подання звітності. Саша починає писати програму аналізу. Конкретну інформацію про книги «хрещена мати» повідомить їй згодом. Тобто, на початок написання програми Саша практично не знає ні структури інформації про книги, ні конкретних значень, які потім вона має обробляти. Тому вона вирішила в якості типа даних обрати об’єкт книга, з наперед невизначеними властивостями і значеннями полів."
          },
          {
            type: "code",
            code: "// програма аналізу інформації про книги в лавці\nvar n = prompt(\"Введіть n: \"); //введення кількості книжок\nvar arraybooks = [ ];                //початкова ініціалізація масиву книжок\nsum =0;                                     //початкова ініціалізація вартості  книжок\nfor ( var i = 0; i <= n-1; i++ ) \n {\n var book = {};		//Створення пустого об'єкту book\n arraybooks[i] = book;  //Початкова ініціалізація пустим об’єктом  book\n var  nameCond1 = prompt(\"Вв-іть   ім’я 1-го ключа для об’єкта book: \"); \n   arraybooks[i].nameCond1 = prompt(\"Введіть значення 1-го ключа для     об’єкта book:  \");\n   var  nameCond2= prompt(\"Введіть ім’я 2-го ключа для об’єкта book: \");\n   arraybooks[i].nameCond2 = Number(prompt(\"Введіть значення ім’я 1-го ключа для об’єкта book: \"));\n   sum =sum + arraybooks[i].nameCond2; /* Збільшення  вартості  книжок лавки додаванням вартості чергової книги*/\nconsole.log(\"книга №\"+ i + \" назва \" + book.nameCond1+ \"  вартість \" +  book.nameCond2); //виведення назви і вартості книги\n     };\nconsole.log(\"вартість книг у лавці = \" + sum ); /*виведення сумарної  вартості    книг у лавці*/\nconsole.log(\"назва першої книги\" + \" є \" + arraybooks[0].nameCond1 );\n// книга №0 назва Мавка  вартість 87\n// книга №1 назва Лісова пісня  вартість 54\n// книга №2 назва Тіні забутих предків  вартість 91\n// вартість книг у лавці = 232\n// назва першої книги є Мавка"
          },
          {
            type: "paragraph",
            text: "Найперше Саша обрала типи даних, які спростять написання програми обробки інформації про книги. Зрозуміло, що для подальшої зміни в обробці даних про книги потрібно обрати впорядковане сховище для зберігання всієї інформації. Природно, вона обрала для цього масив та ініціювала його як пустий (var arraybooks = [];)."
          },
          {
            type: "paragraph",
            text: "Незнання повної інформації про структуру книги, тобто про параметри за якими потрібно буде далі аналізувати інформацію та надавати відповідний звіт, примусило Сашу прийняти рішення про обрання в якості типу даних об’єкта з наперед невизначеними властивостями. Імена ключів і їх значення для визначення властивостей вона вирішила реалізувати за рахунок спеціального введення рядків символів та їх обробки."
          },
          {
            type: "paragraph",
            text: "Тоді залишилося організувати ітераційний процес введення та обробки інформації про книгу з подальшою звітністю."
          },
          {
            type: "paragraph",
            text: "Вона ввела до розгляду змінну n для позначення кількості книг аналізу. Потім надала початкові значення сховищу arraybooks і змінній sum. Остання використовуватиметься для підрахунку загальної вартості книг у лавці. У циклі for, що задає ітераційний процес обробки, Саша створила пустий об’єкт (book = {}), визначила тип елементу масиву як об’єкт (arraybooks[i]=book;). Цим завершився підготовчий етап для введення і аналізу інформації про книги."
          },
          {
            type: "paragraph",
            text: "Наступив основний етап цього прикладу – визначення властивостей об’єкта та їх значень."
          },
          {
            type: "paragraph",
            text: "Оператором введення вона визначає ім’я ключа першої властивості «назви книги»:\nvar nameCond1 = prompt(\"Введіть ім’я ключа1: \");."
          },
          {
            type: "paragraph",
            text: "Наголосимо, що можливо вводити довільний рядок символів, які можуть бути ідентифікатором у JavaScript. Не використовуйте символів кирилиці для цього. Після введення імені ключа присвоїмо йому значення:\narraybooks[i].nameCond1 = prompt(\"Введіть значення ключа1: \");."
          },
          {
            type: "paragraph",
            text: "Тут arraybooks[i] позначає ім’я об’єкта book . Оператор «.» визначає доступ до поля цього об’єкта з введеним ключом nameCond1."
          },
          {
            type: "paragraph",
            text: "Ввівши інформацію для визначення першої властивості можна за аналогією ввести для програмної обробки стільки властивостей об’єкта, скільки потрібно. Саші потрібні дві властивості. Тому вона почала визначати ім’я ключа другої властивості «вартість книги»:\nvar nameCond2= prompt(\"Введіть ім’я ключа2: \");\n   arraybooks[i].nameCond2 = Number(prompt(\"Введіть значення ключа2: \"));."
          },
          {
            type: "paragraph",
            text: "Тут вона використала перетворення рядка символів у число (Number), адже вартість книги характеризує число."
          },
          {
            type: "paragraph",
            text: "Залишилося долучити вартість цієї книги до загальної вартості книжок:\nsum =sum + arraybooks[i].nameCond2;."
          },
          {
            type: "paragraph",
            text: "Для висвітлення можливості традиційної роботи з об’єктом book за такого визначення властивостей Саша у виведенні інформації про оброблену книгу:\nconsole.log(\"книга №\"+ i + \" назва\" + book.nameCond1+ \"  вартість\" + book.nameCond2);\nскористалася прямим звертанням до значень ключів book.nameCond1 і book.nameCond2."
          },
          {
            type: "paragraph",
            text: "Після виходу із циклу їй залишилося прозвітувати за вартість оброблених книжок\nconsole.log(\"sum = \" + sum )."
          },
          {
            type: "paragraph",
            text: "Для наголошення на можливість програмної обробки довільної інформації із сховища-масиву об’єктів Саша вивела назву першої кни-ги\narraybooks[0].nameCond1 (не забувайте про початок нумерації елементів масиву з 0):\nconsole.log(\"назва першої книги\" + \" є \" + arraybooks[0].nameCond1 );."
              }
            ]
          },
          {
            id: 5,
            title: "Особливість типізації: динамічна, сильна, слабка",
            content: [
              {
                type: "heading",
                text: "Особливість типізації: динамічна, сильна, слабка"
              },
              {
                type: "paragraph",
                text: "Враховуючи те, що JavaScript - динамічно типізована мова програмування, можлива робота із змінними без попереднього оголошення їх типу та присвоєння змінним значень різного типу:"
              },
              {
                type: "code",
                code: "var message = \"hello\"; // рядок\nmessage = 123456; //число ."
              },
              {
                type: "paragraph",
                text: "Також мова має виділені зарезервовані значення для позначення особливих ситуація що трапляються при обчисленнях. Прикладом таких значень є «undefined» і «null». Перше означає «відсутність значення у змінної», про яке ми не знали. Його визначає обчислювальне середовище. Друге ж використовується для явної вказівки відсутності значення у змінної програмістом. «null», на противагу « undefined», можливо передавати як аргумент у функцію і використовувати як довільне явне значення."
              },
              {
                type: "paragraph",
                text: "Значення «undefined» також можливо задавати вручну, але цього ніколи не потрібно робити. Це значення спеціально задумувалось розробниками мови для того, щоб його генерував обчислювач а не програміст."
              },
              {
                type: "paragraph",
                text: "Порівнюючи значення «null» і «undefined» потрібно пам’ятати про таке:"
              },
              {
                type: "code",
                code: "null === undefined;   // false\nnull == undefined;    // true\nnull === null;        // true\nnull == null;         // true\n!null;                // true\n\nisNaN(1 + null);      //false\nisNaN(1 + undefined); //true."
              },
              {
                type: "paragraph",
                text: "Нагадаємо, що коли для порівняння застосовують три знаки рівності «=», тоді мова йде про абсолютну ідентичність порівнюваних даних. Коли ж нам потрібно порівняння після наведення типів, тоді використовуютьдва знаки рівності. Наприклад:"
              },
              {
                type: "code",
                code: "3 === '3';    // false\n3 == '3';     // true\n\ntrue === 1;   // false\ntrue == 1;    // true ."
              },
              {
                type: "paragraph",
                text: "Підтримується сім основних типів даних:"
              },
              {
                type: "list",
                items: [
                  "Чисельний тип - представляє як цілочисельні значення, так і значення з плаваючою точкою. Крім звичайних чисел існують «спеціальні числові значення»: Infinity (-Infinity) – математична нескінченність, NaN – невизначеність.\nНаприклад:\nlet a = 12; \nlet b = 12.345456;\nalert( 1 / 0 ); // Набуде значення Infinity\nalert( \"не число\" / 2 ); // NaN, таке обчислення є помилкою",
                  "Рядок (string) – оголошуються за допомогою одинарних, подвійних і обернених лапок. Одинарні і подвійні лапки не мають різниці в JavaScript. Обернені лапки підтримують форматування ${..}. Приклад:\nlet name = \"Тарас\";\n// Вставка змінної\nalert( `Привіт, ${name}!` ); // Привіт, Тарас!\n// Вставка виразу\nalert( `1 + 2 = ${1 + 2}` ); // Виводить “1 + 2 = 3”",
                  "Логічний тип – може приймати лише два значення: true або false.",
                  "Значення null – не належить ні одному з типів, описаних перед цим. Означає, що значення змінної невідоме або вона не має його взагалі.",
                  "Значення undefined – теж є окремим типом. Такий тип мають змінні, що були оголошені, але їм не було присвоєно значення.",
                  "Об’єкти (object). Всі попередньо наведені типи називаються примітивними. Об’єкти ж використовуються для представлення структурно різнотипних даних, тому не є примітивними.",
                  "Символи (symbol) використовуються для створення унікальних ідентифікаторів об’єктів."
                ]
              },
              {
                type: "paragraph",
                text: "Оператор typeof дозволяє дізнатись тип змінної. Можливі два варіанти використання: typeof x – оператор і typeof(x) – функція. typeof повертає рядок у який записаний тип аргумента. Різницю пояснимо на прикладах:"
              },
              {
                type: "code",
                code: "typeof undefined // \"не визначено\"\ntypeof 0 // \"число\"\ntypeof true // \"boolean\"\ntypeof \"foo\" // \"рядок\"\ntypeof Symbol(\"id\") // \"symbol\"\ntypeof Math /*\"object\"  - Math є вбудованим об’єктом, що містить  математичні операції та константи */\ntypeof null // \"object\" - помилка, яка збережена для сумісності\ntypeof alert // \"function\" - не є окремим типом в JavaScript\n  typeof NaN;     // 'число'"
              },
              {
                type: "paragraph",
                text: "NaN означает «не число», та тип цього значення – число."
              },
              {
                type: "paragraph",
                text: "Мова містить спеціалізований інструментарій перетворення типів:"
              },
              {
                type: "list",
                items: [
                  "до рядка \no alert(value) - перетворює значення в рядок (і виводить),\no String(value) - також перетворює значення в рядок,\no String(false) // перетворює значення в рядок “false”;",
                  "до числа\no \"6\" / \"2\" //   рядки перетворюються в числа,\no Number(value) // функція, що перетворює значення в число,\no Number(“3 ”) // 3,\no Number(“Hello”) // NaN, не може бути перетворений в число.",
                  "до логічного типу - за допомогою функції Boolean(value). Правило перетворення таке:\n0, null, NaN undefined, “ ”\tfalse\nвсе інше\ttrue"
                ]
              },
              {
                type: "paragraph",
                text: "Спробуйте відповісти на питання. Який тип матимуть наступні вирази?"
              },
              {
                type: "code",
                code: "let a = 1 + “2”\nlet b = “1” + 2."
              },
              {
                type: "paragraph",
                text: "Мови з динамічною типізацією перевіряють типи та шукають помилки перетворення і узгодження типів на стадії виконання програмного коду. Враховуючи слабку типізацію, JavaScript досить вільно оперує з даними різного типу, користуючись автоматичною та явною їх конвертацією:"
              },
              {
                type: "list",
                items: [
                  "Автоматична конвертація: \n5 + '9';      // '59'\n3 * '2';      // 6\n5 + true;     // 6\nfalse - 6;    // -6 ;",
                  "Явна конвертація:\nNumber('34');    // 34\nNumber('bady#!!');  // NaN\nBoolean(1);       // true\nBoolean(0);       // false\nString(true);     // 'true'\nString(false);    // 'false'\n\nString(51);  // '51'"
                ]
              },
              {
                type: "paragraph",
                text: "У випадку помилки в перетворенні типів або не можливості застосування функції до аргументу з недопустимим типом видається повідомлення про помилку на кшталт такого «typeError: length is not a function)."
              },
              {
                type: "paragraph",
                text: "Інтерпретатор JavaScript не може визначити, чим щось є, але обов’язково визначить і повідомить, чим щось не може бути. Тобто, JavaScript уміє «розумно» розрізняти типи, що суттєво допомагає шукати семантичні помилки в програмі."
              },
              {
                type: "heading",
                text: "Слабка і сильна типізація"
              },
              {
                type: "paragraph",
                text: "У програмуванні розрізняють дві основні концепції типізації: динамічна проти статичної і сильна проти слабої. Нагадаємо, що для виконання програми, написаний програмний код має перетворитися в зрозумілий для обчислювача код (мову машинних команд). Це перетворення називається компіляцією. Після цього етапу, скомпонувавши потрібні модулі, починається етап виконання. Програма засилається на виконання."
              },
              {
                type: "paragraph",
                text: "Якщо мова програмування зорієнтована на перевірку типів та знаходження помилок типізації на етапі компіляції – кажуть, що ця мова із статичною типізацією (Pascal, C#, C++, Java). В іншому випадку, коли зазначена перевірка виконується вже на етапі виконання, мова підтримує динамічну типізацію (JavaScript, PHP). Мови з динамічною типізацією простіші у вивченні, але така типізація призводить до суттєвого зростання помилок у програмі."
              },
              {
                type: "paragraph",
                text: "Уточнивши, коли виконується типізація, тепер зупинимося на деталізації, як проходить типізація. Останнє пояснює відмінність слабої і сильної типізації."
              },
              {
                type: "paragraph",
                text: "Розглянемо такий JavaScript код:"
              },
              {
                type: "code",
                code: "2 + '3';      // '23'\n2 * '3';      // '6'\n4 + true;     // 5"
              },
              {
                type: "paragraph",
                text: "Як ми отримали ці результати?"
              },
              {
                type: "paragraph",
                text: "У першому прикладі JavaScript конвертує число 2 в рядок \"2\", тому що знак «+» може позначати як операцію додавання, так і операцію конкатенації. Але враховуючи, що другий аргумент це рядок, то ймовірніше інтерпретувати «+» як знак операції конкатенації рядків. Тому і виконується об’єднання рядків. JavaScript тут пробує передбачити те що хотів зробити програміст, знайшовши «найрозумніше» рішення у ситуації що склалася. Так у другому прикладі операція множення «*», на противагу до «+», має тільки одну альтернативу використання – це позначення операції множення. Тому '3' перетворюється у число 3 і виконується множення. У третьому виразі один операнд число, другий – логічне значення. Знову, знак операції «+» може трактуватися тільки як знак операції додавання. Тому, «true» перетворюється в 1 і виконується додавання. JavaScript так аналізує який завгодно вираз, тому що ця мова зорієнтована на слабку типізацію."
              },
              {
                type: "paragraph",
                text: "Багато спеціалістів вважають слабкою типізацією нестрогу типізацію, перетворення в якій залежать суттєво від контексту виразу. У сильній типізації більшість перетворень визначено строгими правилами. Так типізація PHP сильніша за JavaScript а у Python ще сильніша. Та чітку межу визначення цього спектру визначити досить важко."
              },
              {
                type: "paragraph",
                text: "Тому у більшості мов програмування, в тому числі і в JavaScript, існують інструменти явного перетворення типу якими може скористатися програміст. Приклади їх використання ми наводили вище."
              },
              {
                type: "paragraph",
                text: "Вважається, що неявна трансформація типу в тип приховує багато особливостей, тому заплутує розуміння перетворення і призводить у багатьох випадках до помилок."
              },
              {
                type: "paragraph",
                text: "Особливо багато перетворень в JavaScript виконується над логічними виразами. Тут застосовуються такі правила:"
              },
              {
                type: "list",
                items: [
                  "0, ' ', undefined перетворюються в false,",
                  "Все інше перетворюється в true;",
                  "null не перетворюється."
                ]
              },
              {
                type: "paragraph",
                text: "Тепер стає зрозумілою відмінність операторів порівняння «===» і «!==» з операторами «==» і «!=» та побажання не використовувати останні. Відмінність полягає у перетворенні типів:"
              },
              {
                type: "code",
                code: "'' === false; //   false\n    '' == false);  //  true"
              },
              {
                type: "paragraph",
                text: "У першому виразі пустий рядок і false – це різні значення, тому результатом порівняння приймає значення «хибність». У другому виразі оператор «= =» перетворює типи, пуста стрічка перетворюється в «false». Вираз набуває вигляду «false == false»."
              },
              {
                type: "paragraph",
                text: "Порівняння рядків відбувається за лексикографічним порядком, тобто рядки порівнюються посимвольно:"
              },
              {
                type: "code",
                code: "'Я' > 'А'          // true\n  'Коса' > 'Коза';   // true\n  'Тополя' > 'Топ';  // true ."
              },
              {
                type: "paragraph",
                text: "В реальності для порівняння рядків використовується кодування UNICODE, а не алфавіт. Таким чином, регістр символа має значення і велика А != а. Остання вважається більшою – розміщується в таблиці кодів за великою А."
              },
              {
                type: "paragraph",
                text: "Порівняння різнотипних значень передбачає переведення одного значення в тип іншого. Рядки та логічний тип перетворюються на числа при порівнянні з числами:"
              },
              {
                type: "code",
                code: "'2' > 1;     // true\ntrue == 1;   // true."
              },
              {
                type: "paragraph",
                text: "Можливе порівняння з null і undefined:"
              },
              {
                type: "code",
                code: "null == undefined; // true\nnull === undefined; // false\n// null при порівнянні перетворюється на 0, undefined - на NaN\nnull > 0; // false\nnull == 0; // false, тут null не перетворюється на число, тому що має тільки одне значення\nnull >= 0      // true\n\nundefined > 0  // false, будь-яке порівняння з NaN -> false\nundefined < 0  // false\nundefined == 0 // false ."
              }
            ]
          },
          {
            id: 6,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "Дайте визначення правила запису імен файлів в JavaScript.",
                  "Охарактеризуйте поняття «тип даних».",
                  "Наведіть приклади використання булевого типу даних.",
                  "Сформулюйте правила побудови виразів в JavaScript.",
                  "Який порядок виконання операцій у виразі?",
                  "Що означає фраза «Javascript – мова з динамічною типізацією».",
                  "Охарактеризуйте числовий тип даних.",
                  "Наведіть приклади використання рядкових і текстових даних.",
                  "Сформулюйте вимоги до типів операндів у операціях.",
                  "Наведіть приклади опису змінних із початковою ініціалізацію значеннями усіх примітивних типів.",
                  "Чим різняться операції інкрементувння та декрементування.",
                  "Охарактеризуйте оператори плюс-дорівнює (+=), мінус-дорівнює (-=), …(*=), …(/=).",
                  "Як вибрати окремий символ із рядка чи змінної виду рядка за порядковим номером символу в рядку?",
                  "Як вибрати слово за порядковим номером початкового символу слова і номером останнього символу слова в рядку?",
                  "Наведіть приклади застосування оператора маніпулювання перетворенням кеглів символів (символ нижчого чи вищого регістру клавіатури).",
                  "Назвіть особливості спеціальних операторів роботи з рядками.",
                  "Наведіть приклади застосування оператора «length».",
                  "Наведіть приклади застосування булевих операторів у мові JavaScript.",
                  "Створіть програмне прийняття рішення: «Андрійку потрібно йти до лікаря якщо в нього щось болить або про це говорить матуся».",
                  "Чи можливе поєднання у логічних виразах булевих змінних із числами?",
                  "Наведіть приклади застосування спеціального оператора порівняння на абсолютне співпадіння двох значень.",
                  "Наведіть приклади застосування оператору визначення приблизної рівності двох величин, навіть у випадку, коли вони мають різний тип.",
                  "Про що сигналізує повідомлення із значенням «undefined»?",
                  "Про що сигналізує повідомлення із значенням «null»?",
                  "Як визначаються складені або структуровані дані?",
                  "Дайте визначення масиву в JavaScript.",
                  "Напишіть програму яка вводить з клавіатури ціле число що визначає кількість елементів масиву MAS та вводить з клавіатури їх значення. Кожне значення – назва дерева. Потім:\nа) Напишіть функцію що міняє місцями перший і останній елемент масиву. Викличте у програмі цю функцію та виведіть на монітор результат.\nб) Напишіть функцію що міняє місцями j-й та k-й елементи масиву, які є параметрами функції. Викличте у програмі цю функцію та виведіть на монітор результат.\nв) Напишіть функцію параметром якої є змінна, що перевіряє чи значення цієї змінної міститься в масиві дерев MAS. Введіть у програмі значення для цієї змінної, викличте цю функцію та виведіть на монітор результат.\nг) Напишіть функцію параметром якої є змінна, що перевіряє чи значення цієї змінної міститься в масиві дерев MAS. Якщо така назва відсутня – нова назва доається на початок масиву. Введіть у програмі значення для цієї змінної, викличте цю функцію та виведіть на монітор результат.",
                  "Сформулюйте особливості типу даних об’єкт.",
                  "Наведіть приклади створення об’єктів.",
                  "Наведіть приклад застосування об'єкту як асоціативного масиву."
                ]
              }
            ]
          }
        ]
  },
  {
    id: 3,
    title: "Оператори управління",
    topics: [
      {
        id: 1,
          title: "Огляд операторів управління", 
          content: [
            {
              type: "subheading",
              text: "JavaScript підтримує такі типи операторів:"
            },
            {
              type: "list",
              items: [
                "арифметичні оператори,",
                "оператори порівняння,",
                "логічні (або реляційні) оператори,",
                "оператори присвоювання,",
                "оператори управління."
              ]
            },
            {
              type: "paragraph",
              text: "Перші три групи операторів ми вже розглянули. Зосередимося у цьому розділі на операторах управління (інструкціях управління). До них належить оператор послідовної обробки «;», оператор розділення гілок виконання «if», оператор варіантного виконання «switch-case», оператори організації ітераційного виконання «for, while, until», оператори безумовної передачі управління «goto, break, continue»."
            }
          ]
        },
        {
        id: 2,
            title: "Послідовне управління",
        content: [
          {
            type: "heading",
            text: "Послідовне управління"
          },
          {
            type: "paragraph",
            text: "Зрозуміло, щоб розрізнити дві послідовні дії, можна використати пустий оператор. У JavaScript роль пустого оператора виконує «;» або символ переходу на набір нового оператора в наступному рядку. Наголосимо тут на «набір нового оператора». Перехід на набір символів у новій стрічці може використовуватися і для задання «довгого» оператора. Та в цьому випадку він виконує іншу роль – забезпечує наочність зображення складного оператора шляхом структурного представлення його частин у нових рядках."
          },
          {
            type: "paragraph",
            text: "Наприклад, нехай наш процес складається із двох послідовних присвоєнь змінним х1 і х2 значень 3 і 5 відповідно. Тоді цей процес можна описати так:"
          },
          {
            type: "code",
            code: "х1 = 3;\nх2 = 5;"
          },
          {
            type: "paragraph",
            text: "Або так:"
          },
          {
            type: "code",
            code: "х1 = 3\nх2 = 5;"
          },
          {
            type: "paragraph",
            text: "На рівні опису управління, ми можемо сказати, що таким записом ми засвідчуємо факт послідовного виконання двох операторів присвоєння. Спочатку виконується присвоєння змінній х1 значення 3, а потім х2 присвоюється значення 5."
          },
          {
            type: "paragraph",
            text: "Синтаксис інструкції послідовного управління такий:"
          },
          {
            type: "code",
            code: "оператор1; оператор2; або\nоператор1 Shift/Enter оператор2;"
          },
          {
            type: "paragraph",
            text: "Досвідчені програмісти рекомендують завжди оператор закінчувати «;», навіть у випадку, коли синтаксис дозволяє цей символ опустити."
          }
        ]
          },
          {
            id: 3,
            title: "Групування",
            content: [
              {
                type: "heading",
                text: "Групування"
              },
              {
                type: "paragraph",
                text: "Трапляються випадки в заданні управління виконанням процесу обробки інформації, коли потрібно декілька операторів об’єднати в групу. Наприклад, за виконання певної умови запустити на виконання декілька операторів. Як і в математиці, у програмуванні для позначення такого групування (об’єднання) використовується оператор групування або групові дужки. В JavaScript групова відкриваюча дужка позначається «{» а закриваюча – «}». Так, об’єднання двох попередніх операторів присвоювання у групу матиме вигляд:"
              },
              {
                type: "code",
                code: "{\n  х1 = 3; \n  х2 = 5;\n}"
              },
              {
                type: "paragraph",
                text: "Взагалі оператор групування має такий синтаксис запису:"
              },
              {
                type: "code",
                code: "{\n  Оператор1;\n  Оператор2;\n  . . .\n  ОператорN; \n}"
              },
              {
                type: "paragraph",
                text: "Цим записом ми стверджуємо, що ми об’єднуємо в групу N зазначених операторів усередині дужок."
              }
            ]
          },
          {
            id: 4,
            title: "Розгалуження",
            content: [
              {
                type: "heading",
                text: "Розгалуження"
              },
              {
                type: "paragraph",
                text: "У природі і в повсякденному житті лінійний порядок – рідкісне явище. Частіше трапляється нелінійність, тобто ситуації, які потребують альтернативного прийняття рішення. Тому і в мові мають бути спеціальні інструкції управління для адекватного опису процесу обробки даних подібного типу. Їх називають **операторами вибору** або **умовними операторами**. Умовні оператори використовуються для програмування фрагментів алгоритму, що містять алгоритмічну конструкцію розгалуження і синтаксично визначаються службовими словами «if» або «case». Умовний оператор «if» ми вже використовували раніше, покладаючись на здоровий глузд читачів у його застосуванні. Та все ж, для уточнення окремих важливих моментів, розглянемо особливості його використання на наступних прикладах."
              },
              {
                type: "paragraph",
                text: "Нехай нам потрібно описати програмно такий сценарій прийняття рішення мамою Андрійка. Після повернення зі школи та обіду вона дозволяє Андрійку пограти в футбол та, залежно від отриманої ним оцінки з української мови, якщо оцінка більша за 8, дозволяє ще й подивитися мультик."
              },
              {
                type: "code",
                language: "javascript",
                code: "// фрагмент короткого if\nvar markAndUkr = prompt(\"Введіть markAndUkr: \"); /*введення оцінки Андрія з української мови*/\nif (markAndUkr > 8) \n\tconsole.log(\"Андрійко має дозвіл подивитися мультик\" );\nconsole.log(\"Андрійко має дозвіл на  гру в футбол\" );"
              },
              {
                type: "paragraph",
                text: "Якщо запустимо цю програму на виконання, тоді при введенні у вікні prompt значення **markAndUkr = 6**, надрукується «Андрійко має дозвіл на гру в футбол». Коли ж ми запустимо нашу програму на виконання із значенням **markAndUkr = 10**, тоді отримаємо друк «Андрійко має дозвіл подивитися мультик» і «Андрійко має дозвіл на гру в футбол»."
              },
              {
                type: "paragraph",
                text: "Такий оператор розгалуження управління **if** іноді називають «коротким if-ом». Взагалі він має такий синтаксис запису:"
              },
              {
                type: "code",
                code: "if (вираз) оператор;"
              },
              {
                type: "paragraph",
                text: "Наголосимо, що в якості «оператор;» тут може бути і оператор групи. Подібний запис у програмі говорить про те, що якщо «вираз» приймає значення «істина», то управління передається на виконання оператору, який розташований після закриваючої дужки виразу «)». Якщо ж значення «виразу» – хибність, тоді управління передається оператору, який розташований у програмі за оператором **if**."
              },
              {
                type: "paragraph",
                text: "Звертаємо вашу увагу на дотримання всіх вимог синтаксично правильного запису операторів у мовах програмування. У випадку використання оператору **if** зосередьтесь на обов’язковості запису виразу у дужках."
              },
              {
                type: "paragraph",
                text: "Структуру описаного управління відображає блок-схема, зображена на рисунку 2.7."
              },
              {
                type: "image",
                src: "/images/image075.png",
                alt: "Рис. 2.7. Структура управління короткого if"
              },
              {
                type: "paragraph",
                text: "Тут орієнтована стрілка вказує напрямок і місце передачі управління."
              },
              {
                type: "paragraph",
                text: "Якщо результат обрахування виразу не належить логічному типу, він приводиться до нього автоматично. Наприклад:"
              },
              {
                type: "code",
                code: "if (0) { /* 0 is false */ /* тіло оператора ніколи не виконається */ }\nif (1) { /* 1 is true */ /* тіло оператора завжди виконуватиметься */ }"
              },
              {
                type: "paragraph",
                text: "Та набагато частіше зустрічається ситуація, коли потрібно приймати рішення про передачу вказівки на виконання (управління) в альтернативні місця (на два різні оператори). Тобто, у попередній конструкції умовного виконання у випадку хибності виразу сигнал управління на виконання маємо передавати не на наступний за if-ом оператор, а на альтернативний оператор. Він знову ж може бути довільної складності, включаючи оператор групування і короткий або довгий умовний оператор."
              },
              {
                type: "paragraph",
                text: "Такий тип оператор розгалуження управління **if** називають «довгим if-ом». Він має такий синтаксис запису:"
              },
              {
                type: "code",
                code: "if (вираз)\n{\n  Оператор1 \n}\nelse\n{\n  Оператор2\n};"
              },
              {
                type: "paragraph",
                text: "Цей умовний оператор працює так. Якщо «вираз» набуває значення «істина», тоді управління передається на виконання оператору1, а якщо – «хибність», тоді – на виконання оператору2."
              },
              {
                type: "paragraph",
                text: "Наприклад, давайте ускладнимо попередню ситуацію з рішенням мами. Нехай вона дозволяє Андрійку подивитися мультик, якщо він отримав оцінку з української мови в школі більшу за 8. В іншому випадку він мусить повторити всі правила правопису. Описати правило прийняття рішення мамою можна так:"
              },
              {
                type: "code",
                language: "javascript",
                code: "// фрагмент довгого if\nvar markAndUkr = prompt(\"Введіть markAndUkr: \"); /*введення оцінки Андрія з української мови*/\nif (markAndUkr > 8) \n\tconsole.log(\"Андрійко має дозвіл подивитися мультик\" ) \nelse \n\tconsole.log(\"Андрійко має повторити правила\" );\nconsole.log(\"Андрійко має дозвіл на  гру в футбол\" );"
              },
              {
                type: "paragraph",
                text: "Якщо запустимо цю програму на виконання, тоді при введенні у вікні prompt значення **markAndUkr = 6**, надрукується «Андрійко має повторити правила» і «Андрійко має дозвіл на гру в футбол». Коли ж ми запустимо нашу програму на виконання із значенням **markAndUkr = 10**, тоді отримаємо друк «Андрійко має дозвіл подивитися мультик» і «Андрійко має дозвіл на гру в футбол»."
              },
              {
                type: "paragraph",
                text: "Структуру описаного управління за «довгим if» вдало відображає блок-схема з рисунку 2.8:"
              },
              {
                type: "image",
                src: "/images/image076.png",
                alt: "Рис. 2.8. Структура управління довгого if"
              },
              {
                type: "paragraph",
                text: "Розглянемо трішки складнішу ситуацію прийняття рішення мамою. Нехай вона у своє попереднє правило внесла таке доповнення. Якщо оцінка найбільша, рівна 12, тоді Андрійку увечері можна пограти ще й на комп’ютері. Описати правило прийняття рішення мамою у цьому випадку можна таким програмним кодом:"
              },
              {
                type: "code",
                language: "javascript",
                code: "// правило прийняття рішення мамою\nvar markAndUkr = prompt(\"Введіть markAndUkr: \"); /*введення оцінки Андрія з української мови*/\nif (markAndUkr > 8) {\n\tif (markAndUkr == 12) {\n\t\tconsole.log(\"Андрійко має дозвіл пограти на компі \" ) ;\n\t}\n\tconsole.log(\"Андрійко має дозвіл подивитися мультик\" ) \n} else {\n\tconsole.log(\"Андрійко має повторити правила\" );\n}\nconsole.log(\"Андрійко має дозвіл на  гру в футбол\" );\n// Андрійко має дозвіл пограти на компі\n// Андрійко має дозвіл подивитися мультик\n// Андрійко має дозвіл на  гру в футбол"
              },
              {
                type: "paragraph",
                text: "Все дозволено!!! Такий друк буде отримано у випадку вводу значення **markAndUkr = 12**."
              },
              {
                type: "paragraph",
                text: "Тут в якості оператору 1 виступає груповий оператор:"
              },
              {
                type: "code",
                code: "{\n\tif (markAndUkr == 12) \n\t\tconsole.log(\"Андрійко має дозвіл пограти на компі \" ) ;\n\tconsole.log(\"Андрійко має дозвіл подивитися мультик\" ) \n}"
              },
              {
                type: "paragraph",
                text: "Умовні оператори часто використовуються для реалізації алгоритмів у математиці."
              },
              {
                type: "paragraph",
                text: "Нехай учитель математики задав Андрійку двадцять прикладів на перевірку можливості побудови трикутника із трьох відрізків. У Андрійка гарна уява. Він представив найбільший відрізок та поклав на різні кінці цього відрізку два інші. Зрозуміло, що якщо вони склалися без перетину на найбільшому – тоді трикутник не можна побудувати. Коли ж два накладені відрізки перетнулися – тоді трикутник можна побудувати. Андрійко дійшов висновку, що трикутник можна побудувати із трьох відрізків, якщо сума довжин двох відрізків більша за довжину максимального відрізка."
              },
              {
                type: "paragraph",
                text: "Це можна реалізувати, порівнявши суми довжин всіх пар сторін із довжиною третьої сторони, що залишається. Щоб трикутник існував, всі суми завжди мають бути більшими третьої сторони (якщо не враховувати виродженого трикутника). Тобто, якщо позначити довжини сторін через **a, b** і **c**, тоді потрібно порівняти три вирази: **a+b>c, b+c>a, a+c>b**. Якщо хоча б одна нерівність не виконується, тоді трикутник неможливо побудувати."
              },
              {
                type: "paragraph",
                text: "Та йому було ліньки перевіряти 20 разів виконання цього правила на конкретних значеннях довжин відрізків, і він вирішив написати програму розв’язання цієї задачі. Давайте допоможемо йому це зробити."
              },
              {
                type: "paragraph",
                text: "Нехай відрізки характеризують три змінні **a, b, c**. Зрозуміло, що вони приймають числові значення. Наше правило можливості побудови трикутника із трьох відрізків може бути уточнено на базі двох підходів."
              },
              {
                type: "paragraph",
                text: "Перший – давайте визначимо найбільший з них і порівняємо з двома іншими. Якщо його значення більше за суму довжин двох інших – друкуємо повідомлення про можливість побудови трикутника, в іншому випадку – друкуємо повідомлення про неможливість побудови трикутника."
              },
              {
                type: "paragraph",
                text: "Та, згадавши про марудність реалізації алгоритму знаходження максимального елементу в задачі про розміщення кілець пірамідки, приходимо до ідеї використання іншого підходу, у якому порівнюємо всі варіанти порівняння сум довжин двох відрізків з довжиною третього. У випадку, коли хоча б одна сума буде менша за довжину третього відрізка, тоді друкуємо повідомлення про неможливість побудови трикутника, в іншому випадку – друкуємо повідомлення про можливість побудови трикутника."
              },
              {
                type: "paragraph",
                text: "Приходимо до такого програмного коду:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var a = Number(prompt(\"Введіть a: \")); /*введення довжини 1-го відрізка*/\nconsole.log(\"a=\" + a); /*контрольне виведення довжини 1-го відрізка*/\nvar b = Number(prompt(\"Введіть b: \")); /*введення довжини 2-го відрізка*/\nconsole.log(\"b=\" + b); /*контрольне виведення довжини 2-го відрізка*/\nvar c = Number (prompt(\"Введіть c: \"));\nconsole.log(\"c=\" + c); /*контрольне виведення довжини 3-го відрізка*/\nif (a+b > c)\n\tif (a+c > b)\n\t\tif (b+c > a)\n\t\t\tconsole.log(\"трикутник можна побудувати\")\n\t\telse\n\t\t\tconsole.log(\"трикутник  не можна побудувати\");\n\telse\n\t\tconsole.log(\"трикутник  не можна побудувати\");\nelse\n\tconsole.log(\"трикутник  не можна побудувати\");\n// a=1\n// b=2\n// c=5\n// трикутник  не можна побудувати."
              },
              {
                type: "paragraph",
                text: "У інструкції «**var a = Number(prompt(\"Введіть a: \"));**» ми використали конструктор **Number** для перетворення рядкового значення змінної **a** (введене prompt значення за замовчуванням трактується як рядок символів) у число, щоб запобігти помилки в обчисленні виразу «**a+b > c**». Якби ми цього перетворення не зробили, у цьому виразі операція «**+**» розумілася б як операція конкатенації двох рядків **a** і **b** відповідно."
              },
              {
                type: "paragraph",
                text: "Для скорочення кількості операторів **if** часто ускладнюють вираз. У останньому прикладі оператор:"
              },
              {
                type: "code",
                code: "if ( a+b > c)\n\tif ( a+c > b)\n\t\tif ( b+c > a)\n\t\t\tconsole.log(\"трикутник можна побудувати\")\n\t\telse\n\t\t\tconsole.log(\"трикутник  не можна побудувати\");\n\telse\n\t\tconsole.log(\"трикутник  не можна побудувати\");\nelse\n\tconsole.log(\"трикутник  не можна побудувати\"); "
              },
              {
                type: "paragraph",
                text: "може бути замінений на еквівалентний по суті оператор, ускладнивши вираз оператору **if**:"
              },
              {
                type: "code",
                code: "if (( a+b > c) && ( a+c > b) && ( b+c > a)) \n\tconsole.log(\"трикутник можна побудувати\") \nelse \n\tconsole.log(\"трикутник  не можна побудувати\");"
              },
              {
                type: "paragraph",
                text: "Нагадаємо, що тут «**&&**» позначає операцію «логічне **і**». Вона виконується так. Значення виразу «**(( a+b > c) && ( a+c > b) && ( b+c > a))**» прийме значення «істина», коли всі вирази «**( a+b > c)**», «**( a+c > b)**», «**(b+c > a)**» мають значення «істина» і прийме значення «хибність», коли хоча б один із зазначених виразів має значення «хибність»."
              },
              {
                type: "paragraph",
                text: "Зробимо цю заміну в нашій програмі та запустимо її на виконання."
              },
              {
                type: "code",
                language: "javascript",
                code: "var a = Number(prompt(\"Введіть a: \")); \nconsole.log(\"a=\" + a); \nvar b= Number(prompt(\"Введіть b: \")); \nconsole.log(\"b=\" + b); \nvar c = Number (prompt(\"Введіть c: \")); \nconsole.log(\"c=\" + c); \n\nif (( a+b > c) && ( a+c > b) && ( b+c > a))\n\tconsole.log(\"трикутник можна побудувати\")\nelse\n\tconsole.log(\"трикутник  не можна побудувати\");\n// a=2\n// b=3\n// c=4\n// трикутник можна побудувати"
              },
              {
                type: "paragraph",
                text: "Та запис розгалуження управління на дві частини може бути ще скорочено. В JavaScript є **тернарний оператор** «**?**», який семантично еквівалентний до оператора «**if-else**». Cинтаксис запису цього оператору такий:"
              },
              {
                type: "code",
                code: "(вираз) ? оператор1 : оператор2;"
              },
              {
                type: "paragraph",
                text: "Усі синтаксичні вимоги і зауваження відносно правильності побудови «виразу» та використання «оператор1» і «оператор2» співпадають із відповідними побудовами в операторі «**if-else**». Тобто оператор:"
              },
              {
                type: "code",
                code: "if (( a+b > c) && ( a+c > b) && ( b+c > a)) \n\tconsole.log(\"трикутник можна побудувати\") \nelse \n\tconsole.log(\"трикутник  не можна побудувати\"); "
              },
              {
                type: "paragraph",
                text: "може бути замінений на еквівалентний по суті оператор:"
              },
              {
                type: "code",
                code: "(( a+b > c) && ( a+c > b) && ( b+c > a))? \n\tconsole.log(\"трикутник можна побудувати\") : \n\tconsole.log(\"трикутник  не можна побудувати\");  "
              },
              {
                type: "paragraph",
                text: "Зробимо цю заміну в нашій програмі та запустимо її на виконання. "
              },
              {
                type: "code",
                language: "javascript",
                code: "var a = Number(prompt(\"Введіть a: \")); \nconsole.log(\"a=\" + a); \nvar b = Number(prompt(\"Введіть b: \")); \nconsole.log(\"b=\" + b); \nvar c = Number (prompt(\"Введіть c: \")); \nconsole.log(\"c=\" +c); \n\n(( a+b > c) && ( a+c > b) && ( b+c > a)) ? \n\tconsole.log(\"трикутник можна побудувати\") : \n\tconsole.log(\"трикутник  не можна побудувати\");\n// a=3\n// b=6\n// c=12\n// трикутник  не можна побудувати"
              },
              {
                type: "paragraph",
                text: "Тепер Андрійку та його друзям можна перевіряти програмно 20 прикладів домашнього завдання!!!!"
              }
            ]
          },
          {
            id: 5,
            title: "Варіант",
            content: [
              {
                type: "heading",
                text: "Варіант"
              },
              {
                type: "paragraph",
                text: "Ми вважаємо, що читач уже зрозумів, що будь-яке складне розгалуження можна реалізувати шляхом використання декількох коротких чи довгих операторів «**if**». Та у випадку, коли розгалуження залежить тільки від значення однієї змінної, такий повтор «**if**» не завжди видається оптимальним. У цьому випадку краще задавати подібне розгалуження за допомоги оператору **switch**."
              },
              {
                type: "paragraph",
                text: "Пояснимо вищезазначене на такому прикладі. Читач уже зрозумів, що мій Андрійко – «забудько». Особливо ця його вада проявляється, коли справа стосується шкільних справ. Наприклад, він іноді забуває, з яких предметів відбуваються у нього уроки в різні дні тижня. Щоб спростити собі життя, він вирішив написати програму електронного щоденника. Тобто програма має видавати за днем тижня перелік назв уроків, які стоять у розкладі занять в Андрійковій школі у цей день."
              },
              {
                type: "paragraph",
                text: "Програма повинна реалізовувати наступну ідею. Андрійко вводить змінну, значенням якої є день тижня (понеділок, вівторок, середа, четвер, п’ятниця, субота, неділя), а програма друкує назву уроків цього дня. Уточнимо це в алгоритмі 2.2."
              },
              {
                type: "subheading",
                text: "Алгоритм 2.2."
              },
              {
                type: "list",
                items: [
                  "1. Ввести значення змінної **dayOfWeek**.",
                  "2. Якщо **dayOfWeek = «понеділок»** тоді\n    Надрукувати («математика», «укр. мова», «природознавство», «фіз- культура»)\n    інакше\n      Якщо **dayOfWeek = «вівторок»** тоді\n        Надрукувати («інформатика», «укр. література», «основи здоров’я», «праця»)\n    . . .\n        інакше\n          Якщо **dayOfWeek = «п’ятниця»** тоді\n            Надрукувати («англ. мова», «навк. світ», «математика», «фізкультура»)\n            інакше\n              Надрукувати «вихідний день»",
                  "3. Кінець."
                ]
              },
              {
                type: "paragraph",
                text: "Тоді програмна реалізація цього алгоритму прийме вигляд:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var dayOfWeek = prompt(\"Введіть dayOfWeek: \"); // введення дня тижня\nconsole.log(\"dayOfWeek=\" + dayOfWeek); // контрольне виведення дня тижня\nif (dayOfWeek == \"понеділок\")\n\tconsole.log(\"математика,\" + \"укр. мова,\" + \"природознавство,\" +\"фізкультура\");\nelse if (dayOfWeek == \"вівторок\")\n\tconsole.log(\"інформатика,\"  + \"укр. література,\" + \"основи здоров’я,\" +\"праця\");\nelse if (dayOfWeek == \"середа\")\n\tconsole.log(\"інформатика,\" +\"укр. література,\" + \"основи здоров’я,\" + \"праця\");\nelse if (dayOfWeek == \"четвер\")\n\tconsole.log(\"основи здоров’я,\" + \"інформатика,\" +\"укр. мова,\"  + \"праці\");\nelse if (dayOfWeek == \"п’ятниця\")\n\tconsole.log(\"англ. Мова,\" + \"навк. Світ,\" + \"математика,\"  + \"фізкультура\");\nelse\n\tconsole.log(\"вихідний день\");\n// dayOfWeek=п’ятниця\n// англ. мова, навк. світ, математика, фізкультура"
              },
              {
                type: "paragraph",
                text: "З поставленою задачею Андрійко успішно справився. Але викликає естетичне незадоволення від частоти появи оператору **if**, що суттєво впливає на читабельність запису цієї програми. Для усунення зазначених вад і використовується оператор **switch**."
              },
              {
                type: "code",
                language: "javascript",
                code: "var dayOfWeek = prompt(\"Введіть dayOfWeek: \");\nconsole.log(\"dayOfWeek=\" + dayOfWeek);\nswitch (dayOfWeek) {\n  case \"понеділок\": console.log(\"математика,\" + \"укр. мова,\" + \"природознавство,\" +\"фізкультура\"); break;\n  case \"вівторок\": console.log(\"інформатика,\"  + \"укр. література,\" + \"основи  здоров’я,\" +\"праця\"); break;\n  case \"середа\": console.log(\"інформатика,\" +\"укр. література,\" + \"основи здоров’я,\" + \"праця\"); break;\n  case \"четвер\" : console.log(\"основи здоров’я,\" + \"інформатика,\" +\"укр. мова,\"  + \"праця\"); break;\n  case \"п’ятниця\": console.log(\"англ. Мова,\" + \"навк. Світ,\" + \"математика,\"  + \"фізкультура\"); break;\n  default: console.log(\"вихідний день\"); break;\n};\n// dayOfWeek=середа\n// інформатика, укр. література, основи здоров’я, праця"
              },
              {
                type: "paragraph",
                text: "Маємо потрібний результат. Та у такому запису програми значно стала зрозумілішою сутність програми і скоротився її запис."
              },
              {
                type: "paragraph",
                text: "Синтаксис повного оператору **switch-case** такий:"
              },
              {
                type: "code",
                code: "switch (вираз)\n{\n  case \"мітка1\": оператор1; break; \n  case \"мітка2\": оператор1; break;\n  . . .\n  case \"міткаN\": операторN; break; \n  default: операторN+1; break;\n}"
              },
              {
                type: "paragraph",
                text: "При досягненні оператору **switch-case** найперше обраховується значення виразу, що стоїть в дужках після **switch**. Потім іде почергове порівняння обчисленого значення виразу із значеннями міток **мітка1, мітка2,…, міткаN**, які розміщені після службових слів **case**. Потрібно відзначити, що перевірка на рівність завжди «сувора» (значення повинні бути одного типу, щоб виконувалася рівність). Після першого їх співпадіння (нехай це буде мітка J), починає виконуватися той оператор (може бути і оператор групи, як у нашому прикладі), який стоїть після мітки J. Оператор **break** передає управління на вихід із оператору **switch-case**. Він має закінчувати кожну гілку розгалуження. Якщо жодна мітка з блоків не співпадає з обчисленим значенням виразу (в усіх інших випадках), виконується **операторN+1** (може бути і оператор групи), який стоїть після спеціальної мітки **default**. Ця спеціальна мітка та оператор після неї може бути і відсутній в конструкції. Тому цей оператор ще називають оператором варіанту."
              },
              {
                type: "paragraph",
                text: "У наведеному прикладі в якості міток виступали літерали – символьні рядки. Взагалі, згідно стандарту ECMAScript v3, JavaScript дозволяє використовувати мітками числа, рядкові літерали і довільні вирази. Суттєвим тут є те, що співпадіння визначається за допомоги оператору ідентичності «**===**», а не оператором рівності «**==**». Тому у випадку використання у якості мітки виразу, останній має співпадати із виразом, що стоїть після службового слова **switch** без будь-якого перетворення типів."
              },
              {
                type: "paragraph",
                text: "Повернемося до нашої програми. Після введення значення дня тижня у змінну **dayOfWeek** ми приходимо до виконання оператору **switch-case**. Починається перевірка співпадіння значення **dayOfWeek** із мітками. Воно співпадає із міткою «середа». Тому переходимо до виконання оператору, який розміщений за цією міткою. Цим оператором є оператор друку. В результаті його виконання отримаємо друк розкладу занять середи:"
              },
              {
                type: "paragraph",
                text: "інформатика, укр. література, основи здоров’я, праця."
              },
              {
                type: "paragraph",
                text: "Далі, згідно з оператором **break**, виходимо із оператору варіанту. У нашій програмі це буде кінцем програми."
              },
              {
                type: "paragraph",
                text: "Спробуйте запустити цю програму на виконання, видаливши із неї всі оператори **break**."
              }
            ]
          },
          {
            id: 6,
            title: "Ітерація",
            content: [
              {
                type: "heading",
                text: "Ітерація"
              },
              {
                type: "paragraph",
                text: "Термін **ітерація** (від лат. *iteratio* — повторювання) будемо використовувати для позначення багаторазового повторення виконання якихось дій. У програмуванні ітерація заміняється терміном **цикл**, або **циклічне виконання**. Зрозуміло, що ітераційний процес може бути скінченним або нескінченним. Маємо відповідно і цикли – скінченні та нескінченні. Останні приводять до помилкових обчислень і завершуються аварійною зупинкою обчислень. Тобто результат таких обчислень ми ніколи не зможемо побачити, тому й зупиняємо обчислення."
              },
              {
                type: "paragraph",
                text: "Скінченні цикли бувають двох типів: **зліченні** та **умовні**. Перші використовуються у випадку, коли ми наперед знаємо потрібну кількість ітерацій, що приведе нас до бажаного результату. У другому випадку ми, як і в операторах розгалуження, використовуємо вираз, який визначає умову продовження ітераційного процесу або його закінчення. Зрозуміло, що в природі та повсякденному житті зустрічається більше ітераційних процесів другого типу."
              },
              {
                type: "paragraph",
                text: "У програмуванні зліченні цикли позначаються у більшості мов за допомоги службового слова **for**, а умовні – **while**."
              },
              {
                type: "paragraph",
                text: "Розглянемо особливості синтаксичного написання та використання цих конструкцій."
              },
              {
                type: "subheading",
                text: "Оператор while"
              },
              {
                type: "paragraph",
                text: "Задання ітераційного процесу другого типу повинно мати дві складові: умову виконання повторних дій і оператор, який задає ці дії. JavaScript дотримується такого синтаксису для виділення цих складових:"
              },
              {
                type: "code",
                code: "while (вираз) оператор;"
              },
              {
                type: "paragraph",
                text: "Структуру управління обробки інформації цим оператором описує наступна блок-схема (рис 2.9):"
              },
              {
                type: "image",
                src: "/images/image077.png",
                alt: "Рис 2.9 Структура управління оператору while"
              },
              {
                type: "paragraph",
                text: "Він починає роботу з обчислення та аналізу виразу, який задає умову виконання повторних дій. Якщо значення виразу рівне **false** (хибність), управління передається наступному за **while** оператору програми. Якщо ж значення виразу рівне **true** (істина), тоді виконується оператор (оператор групи) і управління передається на початок **while**, тобто на обчислення і перевірку значення виразу оператору програми. Адже виконання оператору (оператору групи) може змінити значення змінних, що може привести до зміни адрес передачі управління. Тобто, якщо значення виразу рівне **false** (хибність), управління передається наступному за **while** оператору програми, в противному разі виконується оператор (оператор групи) і управління передається на початок **while**. Таким чином і утворюється циклічна (ітераційна) обробка оператору (оператору групи). Кількість повторень можна встановити, задавши параметр циклу – якусь додаткову змінну, перед початком циклу обнуливши її (присвоївши значення 0), а в тілі циклу в операторі (операторі групи) на кожній ітерації збільшивши її значення на 1."
              },
              {
                type: "paragraph",
                text: "Важливо пам’ятати, що тіло циклу **while** може жодного разу і не виконатися, якщо при першому входженні на перевірку виразу, його значення буде рівним **false**."
              },
              {
                type: "paragraph",
                text: "Зрозуміло, що нескінченний цикл можна задати таким чином:"
              },
              {
                type: "code",
                code: "while (true) оператор;"
              },
              {
                type: "paragraph",
                text: "Таке задання циклічного процесу обробки даних в програмі буває корисним, коли ми не можемо коротко і точно сформулювати умову (вираз) виконання повторних дій (ітерацій). В цьому випадку, оператор групи обов’язково, для закінчення обчислень у циклі, повинен містити оператор **break** безумовної передачі управління (виходу із циклу) наступному за **while** оператору програми."
              },
              {
                type: "paragraph",
                text: "Та нескінченний цикл невмілий програміст іноді задає помилково. Це відбувається, коли на початку виконання значення умови (вираз) приймає значення **true**, а в операторі (тілі циклу) ніяким чином не змінюються значення змінних, присутніх у виразі, тобто він залишається незмінним, рівним **true**. Тобто ми ніколи не вийдемо на умову виходу із циклу. Приведемо приклад такої конструкції. Андрійку потрібно було написати програму, в якій би 20 разів друкувалася з нового рядка фраза «Друзі, привіт!!!». Він «гарно» опанував теоретичний матеріал. Тому швидко написав програму:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var i_Parametr = 1;\nwhile(i_Parametr <= 20) \n      console.log(\"Друзі, привіт!!!\");\n      i_Parametr++;"
              },
              {
                type: "paragraph",
                text: "та запустив її на виконання. І що ж він побачив? Все починалося так добре. Почався друк потрібної фрази. Та ба, закінчення друку не було кінця. Він зрозумів, що комп’ютер вийшов на нескінченне повторення дій, яке в програмуванні називають простіше – «зациклився». Що ж робити? Потрібно аварійно закінчити обчислення і виправляти сутність програми."
              },
              {
                type: "paragraph",
                text: "Подивившись уважно на текст програми, Андрійко зрозумів, що такий запис циклу включає в його тіло тільки конструкцію **console.log(\"Друзі, привіт!!!\")**. Крапка з комою «;» закінчує тіло циклу. Тому, виконавши друк, управління передається на перевірку умови **i_Parametr < 100**, тобто **1 < 100**. Значення виразу прийме значення **true**. Тому переходимо на виконання тіла циклу, а значення **i_Parametr** залишається без змін. Значення виразу – істина, перехід на виконання друку і т.д. і т.п.. Зациклилися!!!!"
              },
              {
                type: "paragraph",
                text: "Тому зміну значення параметру **i_Parametr++** потрібно включити в тіло циклу, застосувавши оператор групи:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var i_Parametr = 1;\nwhile(i_Parametr <= 20) \n{\n\tconsole.log(\"Друзі, привіт!!!\");\n\ti_Parametr++;\n}"
              },
              {
                type: "paragraph",
                text: "У цьому випадку значення **i_Parametr** збільшується на 1 на кожній ітерації циклу (кожний раз при вході в тіло циклу). В кінці кінців **i_Parametr** стане рівним 21. Умова входу не виконається (**21 <= 20**), прийме значення хибність і управління передається на наступний оператор програми, у нашому випадку кінець програми."
              },
              {
                type: "subheading",
                text: "Цикл do/while"
              },
              {
                type: "paragraph",
                text: "Основною відмінністю циклу **do/while** від циклу **while** є обов’язкове виконання тіла циклу. Така ситуація рідкісніша, та все ж буває. Ми вже зазначали, що цикл **while** реалізує ітераційний процес типу «нуль і більше повторень». Але в багатьох випадках потрібно реалізовувати ітерацію типу «одне і більше повторень». Тобто, тіло циклу в останньому випадку виконається хоча б один раз."
              },
              {
                type: "paragraph",
                text: "Синтаксис запису оператору такий:"
              },
              {
                type: "code",
                code: "do оператор while (вираз);"
              },
              {
                type: "paragraph",
                text: "Структуру управління обробкою інформації за використання цього оператору описує така блок-схема (Рис. 2.10)."
              },
              {
                type: "image",
                src: "/images/image078.png",
                alt: "Рис. 2.10 Структура передачі управління в операторі do/while"
              },
              {
                type: "paragraph",
                text: "Тобто, потрапивши на виконання оператору **do/while**, зразу починаємо виконувати тіло циклу, задане оператором (груповим оператором). А потім починається все те, що було і в операторі **while** за незначної відмінності. Обчислюється і аналізується значення виразу, і в залежності від цього значення управління передається на виконання тіла циклу або на наступний оператор програми (вихід із циклу)."
              },
              {
                type: "paragraph",
                text: "Тут службові слова **do** і **while** виконують функцію маркерів початку і кінця тіла циклу. Це допомагає усувати помилки, подібні до попереднього прикладу. У цьому випадку розв’язок попереднього завдання прийме вигляд:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var i_Parametr = 1;\ndo {\n\tconsole.log(\"Друзі, привіт!!!\");\n\ti_Parametr++;\n} while (i_Parametr <= 20);"
              },
              {
                type: "subheading",
                text: "Цикл for"
              },
              {
                type: "paragraph",
                text: "Цикл **for** використовується в основному тоді, коли наперед відома кількість ітерацій (повторних дій), що має описати програма. Він має подібну до вище описаних операторів циклу. Основною відміною тут є перевірка роботи повторних дій (тіла циклу). У попередніх прикладах циклів такою перевіркою була перевірка на істинність певного виразу. Ми вже зазначали, що в довільному циклі можна ввести спеціальну змінну, яку називають лічильником циклу (лічильником кількості ітерацій). З нею працюють по-різному. Важливо, щоб перед початком ітерацій вона мала значення, а в тілі циклу – зазнавала якихось змін. Так ось, оператор циклу типу **for** у своєму заголовку містить спеціальні місця для уточнення цих маніпуляцій з лічильником циклу: **ініціалізацію, перевірку умови і оновлення значення**."
              },
              {
                type: "paragraph",
                text: "Синтаксис циклу **for** наступний:"
              },
              {
                type: "code",
                code: "for(ініціалізація; умова; інкремент) оператор."
              },
              {
                type: "paragraph",
                text: "Як бачите, він може легко переписаний за допомоги використання цих же складових елементів у операторі **while**:"
              },
              {
                type: "code",
                code: "ініціалізація;\nwhile(умова) { оператор; інкремент; }."
              },
              {
                type: "paragraph",
                text: "По суті, він буде подібний, та не зовсім еквівалентний (пояснимо далі). Вираз-ініціалізація, як правило, є оператором присвоєння початкового значення лічильнику, обчислюється один раз перед початком усіх дій по організації повторних обчислень, тобто перед початком циклу. Як ми вже знаємо, в JavaScript ініціалізація змінних може бути поєднана з оголошенням змінних за допомоги інструкції **var**."
              },
              {
                type: "paragraph",
                text: "Перевірка «умови» проводиться перед кожною ітерацією. Вона визначає, буде виконуватися тіло циклу, якщо умова прийме значення **true**, чи управління буде передане на наступний оператор програми в іншому випадку."
              },
              {
                type: "paragraph",
                text: "В кінці тіла циклу обчислюється «інкремент». Традиційно він описується оператором присвоєння або спеціалізованими операторами типу «**++**»."
              },
              {
                type: "paragraph",
                text: "Давайте перепишемо нашу попередню програму, скориставшись інструкцією **for**."
              },
              {
                type: "code",
                language: "javascript",
                code: "for (var i_Parametr = 1; i_Parametr <= 20; i_Parametr++)\n\tconsole.log(\"Друзі, привіт!!!\");"
              },
              {
                type: "paragraph",
                text: "Для закріплення розглянутого матеріалу давайте напишемо програму розв’язку такої задачі. Нехай вам потрібно автоматизувати роботу касового апарату по видачі решти покупцю в магазині. Касир вводить в автомат число, яке визначає решту, що потрібно повернути покупцю мінімальною кількістю купюр чи монет."
              },
              {
                type: "paragraph",
                text: "Отже, нам потрібно розбити число на декілька співмножників. Наприклад, якщо решта становить 254 гривні, а серед купюр у нас є купюри з номіналом 500 грн, 200 грн, 100 грн, 50 грн, 20 грн, 10 грн, 5 грн, 2 грн, 1 грн, тоді матимемо такий розподіл:"
              },
              {
                type: "paragraph",
                text: "254 = 0 * 500 + 1 * 200 + 0 * 100 + 1 * 50 + 0 * 20 + 0 * 10 + 0 * 5 + 2 * 2 + 0 * 1."
              },
              {
                type: "paragraph",
                text: "Алгоритм розв’язку простий. По черзі з максимальної до мінімальної купюри пробуємо визначити кількість цих купюр і на розмірність цієї купюри зменшуємо решту. Процес повторюємо до тих пір, поки решта не стане рівна 0. Спробуємо його сформулювати."
              },
              {
                type: "subheading",
                text: "Алгоритм: Видача решти"
              },
              {
                type: "list",
                items: [
                  "1. Заповнити масив banknote значеннями (**banknote = [500, 200, 100, 50, 20, 10, 5 , 2, 1]**);",
                  "2. Ввести значення решти **change**.",
                  "3. Надрукувати введене значення решти **change** (контроль введення).",
                  "4. Визначити **leng** довжину масиву **banknote**.",
                  "5. Для усіх **count** від 0 до **leng-1** зробити\n    **Початок**\n        Присвоїти змінній **countBanknote** значення нуль.\n        Якщо **change = 0** тоді вийти з циклу інакше\n            **Початок**\n                Поки **change / banknote[count] >= 1** робити\n                    **Початок**\n                        **countBanknote** збільшити на 1;\n                        **change** зменшити на **banknote[count]**\n                    **Кінець**\n                Надрукувати «видати **countBanknote** купюр розмірності **banknote[count]**;\n            **Кінець**\n    **Кінець**\n**Кінець алгоритму**."
                ]
              },
              {
                type: "paragraph",
                text: "Переведемо цей алгоритм у програмний код:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var banknote =[500, 200, 100, 50, 20, 10, 5 , 2, 1]  ;\nvar change = prompt(\"Введіть решту:\"); /* введення значення решти */\nvar leng = banknote.length; //Визначити довжину масиву banknote.\nfor (var count=0; count<= leng-1; count++) /*Для усіх count від 0 до leng-1 зробити*/\n  { // Початок\n    countBanknote = 0;\n    if (change == 0 ) break; // Якщо change = 0 тоді вийти з циклу\n    else //інакше\n      { // Початок\n        while (change / banknote[count] >= 1); //Поки  change/banknote[count] >0    робити\n          { //Початок\n            countBanknote++; // countBanknote збільшити на 1;\n            change = change - banknote[count];\n          }; // change зменшити на banknote[count]\n    }; //кінець\n  console.log (\"видати \", countBanknote, \" купюр розмірності \", banknote[count]);\n};"
              },
              {
                type: "paragraph",
                text: "Прибравши коментарі, приходимо до програми:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var banknote = [500, 200, 100, 50, 20, 10, 5 , 2, 1] ;\nvar change = prompt(\"Введіть решту:\"); \nconsole.log (\"change =  \", change);\nvar leng = banknote.length; \nfor (var count=0; count<= leng-1; count++) { \n  countBanknote=0; \n  if (change == 0 )  break; \n  else { \n    while (change / banknote[count] >=1) { \n      countBanknote++; \n      change = (change - banknote[count]);\n    } ;\n  }; \n  console.log (\"видати \", countBanknote, \" купюр розмірності \",   banknote[count]);\n };\n// change =   673\n// видати   1  купюр розмірності  500\n// видати   0  купюр розмірності  200\n// видати   1  купюр розмірності  100\n// видати   1  купюр розмірності  50\n// видати   1  купюр розмірності  20\n// видати   0  купюр розмірності  10\n// видати   0  купюр розмірності  5\n// видати   1  купюр розмірності  2\n// видати   1  купюр розмірності  1"
              },
              {
                type: "paragraph",
                text: "Таке виведення надлишкове. Повідомлення про виведення 0 купюр можна позбавитися, додавши в програму перевірку про виведення 0 купюр."
              },
              {
                type: "paragraph",
                text: "Замінимо оператор: «**console.log (\"видати \", countBanknote, \" купюр розмірності \", banknote[count]);**» на умовний оператор «**if (countBanknote > 0 ) console.log (\"видати \", countBanknote, \" купюр розмірності \", banknote[count]);**» і запустимо програму на виконання для решти 849 грн. Отримаємо виведення:"
              },
              {
                type: "code",
                language: "console",
                code: "change =   849\nвидати   1  купюр розмірності  500\nвидати   1  купюр розмірності  200\nвидати   1  купюр розмірності  100\nвидати   2  купюр розмірності  20\nвидати   1  купюр розмірності  5\nвидати   2  купюр розмірності  2."
              },
              {
                type: "paragraph",
                text: "Розглянемо деякі особливості роботи циклу **for**, структуру його заголовку на такому прикладі:"
              },
              {
                type: "code",
                language: "javascript",
                code: "for (var i = 0; i < 10; i++)\n{ \n\talert(i); // виведе 0, потім 1,… потім 9 \n}"
              },
              {
                type: "paragraph",
                text: "Нагадаємо, що «**var i = 0;**» – виконується один раз при вході в цикл; умова припинення ітерацій «**i < 3;**» перевіряється на початку кожної ітерації; «**i++**» – виконується після кожної ітерації, перед перевіркою умови. Так як змінна «**і**» оголошена всередині циклу (це буде її область видимості), тому доступ до її значення поза циклом буде обмежений."
              },
              {
                type: "paragraph",
                text: "Деякі фрагменти циклу можна пропускати:"
              },
              {
                type: "list",
                items: [
                  "1. **var i = 0;** // і вже оголошена і має значення\n   **for(; i < 10; i++) {** // тому пропускаємо ініціалізацію\n   **alert( i );** // 0, 1, 2,3,4,5,6,7,8,9\n**}**",
                  "2. // пропуск визначення зміни значення змінної-параметра циклу\n   **for (; i < 10;) {**\n   **alert( i++ );**\n**}**",
                  "3. /* нескінченний цикл (буде виконуватись вічно) */\n   /* аналог while (true) */\n   **for (;;) {**\n   **alert(\"З Новим Роком\");**\n**}**"
                ]
              },
              {
                type: "paragraph",
                text: "З циклу можна в будь-який момент вийти за допомогою директиви **break**."
              },
              {
                type: "paragraph",
                text: "Розглянемо такий приклад. Нехай нам потрібно написати програму, яка вводить із клавіатури послідовність цілих чисел. Наперед кількість цих чисел нам невідома. Ознакою закінчення введення чисел буде набір якогось значення, відмінного від числа."
              },
              {
                type: "paragraph",
                text: "Таке введення чисел можна реалізувати заданням нескінченного циклу із виходом з нього за умови введення «не числа». Наприклад так:"
              },
              {
                type: "code",
                language: "javascript",
                code: "while (true) {\n  var numb = +prompt(\"Введіть число\", '');\n  if (!numb) break; // вихід із цикла\n  ...\n}"
              },
              {
                type: "paragraph",
                text: "Тоді залишиться тільки реалізувати множення введених чисел. Введемо змінну «**var prod = 1**» для початкового визначення добутку, а потім множитимемо чергове введене число на попереднє значення добутку:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var prod=1;\nwhile(true){\n  var numb =+prompt(\"Введіть число\",'');\n  if(!numb)break; // вихід із цикла\n  prod*= numb; // prod=prod* numb\n}\nalert('Добуток: '+prod);"
              },
              {
                type: "paragraph",
                text: "Здавалося, що ми успішно справилися із завданням. Та ба!!! А що буде робити програма, якщо ми не хочемо вводити жодного числа? Ви скажете, що тоді не точно виконується умова задачі. Насправді, таке трапляється досить часто. Тобто, нам потрібно реалізувати захист від введення інформації, що не відповідає умові задачі. У середовищі програмістів це називають реалізацією захисту «від дурня»."
              },
              {
                type: "paragraph",
                text: "Нам потрібно реалізувати обробку ситуації виявлення не введення жодного числа. Давайте зробимо це так. Спочатку перевіримо, чи перше введення – число. Якщо не число, тоді надрукуємо про це повідомлення, інакше початкове значення добутку присвоїмо це перше число:"
              },
              {
                type: "code",
                language: "javascript",
                code: "if(!numb) alert('чисел не уведено');\nelse { var prod = numb; while(true){ var numb = +prompt(\"Введіть число\",''); if(!numb)break; // вихід із цикла prod*= numb; // prod=prod* numb } alert('Добуток: '+prod); }"
              },
              {
                type: "paragraph",
                text: "Приходимо до програми:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var numb = +prompt(\"Введіть число\", '');\nif (!numb) alert( ' Чисел не уведено ');\nelse {\n  var prod = numb;\n  while (true) {\n    var numb = +prompt(\"Введіть число\", '');\n    if (!numb) break; // вихід із цикла\n    prod *= numb; // prod = prod *value\n  }\n  alert( 'Добуток: ' + prod );\n}"
              },
              {
                type: "paragraph",
                text: "Пограйтеся із програмою, задавши варіанти даних, що охоплюють усі розглянуті гілки виконання програми."
              },
              {
                type: "paragraph",
                text: "Розглянемо ще один приклад. Нехай нам потрібно написати програму розв’язку такої задачі."
              },
              {
                type: "paragraph",
                text: "З клавіатури вводиться значення N деякого натурального числа. Потрібно вивести на друк усі натуральні числа, які лежать в межах від 1 до N і серед своїх цифр запису містять цифру «3»."
              },
              {
                type: "paragraph",
                text: "Існує декілька варіантів розв’язку цієї задачі. Зупинимося на такому. Структурно наш алгоритм міститиме три складові: введення значення N та «захист від дурня», породження чисел в межах від 1 до N, перевірка на присутність у числі цифри 3. Уточнимо ці складові."
              },
              {
                type: "subheading",
                text: "Введення значення N та «захист від дурня»:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var numbN =+prompt(\"Введіть число\",'');\nif(!numbN){    // «захист від дурня», перевірка чи уведено число\n\talert(' уведено не натуральне число ');\n}\nelse if(numbN < 3){ // «захист від дурня», пе-ка чи уведено число менше 3\n\talert(' Число не містить цифри 3 ');\n}\nelse if (( numbN == 3)||( numbN < 3)) { // тоді єдине число містить 3\n\talert(' Число  рівне 3  ');\n}\nelse { // Подальші обчислення алгоритму \n\t...\n};"
              },
              {
                type: "subheading",
                text: "Породження чисел в межах від 13 до N (наступне натуральне число після 3, яке містить цифру 3):"
              },
              {
                type: "code",
                language: "javascript",
                code: "for (var iN=13; iN < numbN; iN++) { // Перевірка на присутність у числі цифри \n  ... \n}."
              },
              {
                type: "subheading",
                text: "Перевірка на присутність у числі цифри. Існує декілька варіантів розв’язку цієї задачі. Зупинимося на такому:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var ciN=iN; \nvar remainderNumbN = iN; \nwhile (remainderNumbN >= 1) {\n\tvar lastDigitNumber = ciN % 10;\n\tif(lastDigitNumber == 3){ // «якщо ця цифра  3\n\t\tconsole.log ('  число: ' + iN );\n\t}\n\tciN = (ciN - lastDigitNumber) / 10; \n\tif (ciN  == 3) { // «якщо ця цифра  3\n\t\tconsole.log('  число: ' + iN);\n\t}\n\tremainderNumbN = ciN / 10\n};"
              },
              {
                type: "paragraph",
                text: "Додавши виведення заголовку, отримаємо таку програму:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var numbN = +prompt(\"Введіть число\", '');\nif (!numbN) { // «захист від дурня», перевірка чи уведено число\n  alert( ' уведено не натуральне число ' );\n} else if (numbN < 3) { // «захист від дурня», пе-ка чи уведено число <  3\n  alert( ' Число не містить цифри 3 ' );\n} else if (( numbN == 3) || ( numbN < 13)) { // тоді єдине число містить 3\n  alert( ' Число  рівне 3  ' );\n} else { console.log('В інтервал від 1 до  ' + numbN + '    входять числа: 3');\n  for (var iN=13; iN < numbN; iN++) {\n    var ciN=iN;\n    var remainderNumbN = iN;\n    while (remainderNumbN >= 1) {\n      lastDigitNumber = ciN % 10;\n      if (lastDigitNumber  == 3) { // «якщо ця цифра  3\n        console.log('  число: ' + iN );\n      };\n      ciN = (ciN-lastDigitNumber) / 10;\n      if (ciN  == 3) { // «якщо ця цифра  3\n        console.log('  число: ' + iN);}\n      remainderNumbN = ciN / 10;\n    }  \n  }    \n};"
              },
              {
                type: "paragraph",
                text: "Запустивши програму на виконання, бачимо – вона працює вірно, але не ефективно. Знайшовши у числі першу трійку, програма продовжує шукати інші трійки числа, і якщо вони присутні, виводить одне й те саме число декілька разів. Для вирішення подібних задач можна знову скористатися інструкцією «**break**»:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var numbN = +prompt(\"Введіть число\", '');\nif (!numbN) { // «захист від дурня», перевірка чи уведено число\n  alert( ' уведено не натуральне число ' );\n} else if (numbN < 3) { // «захист від дурня», пе-ка чи уведено число <  3\n  alert( ' Число не містить цифри 3 ' );\n} else if (( numbN == 3) || ( numbN < 13)) { // тоді єдине число містить 3\n  alert( ' Число  рівне 3  ' );\n} else { console.log('В інтервал від 1 до  ' + numbN + '    входять числа: 3');\n  for (var iN=13; iN < numbN; iN++) {\n    var ciN=iN;\n    var remainderNumbN = iN;\n    while (remainderNumbN >= 1) {\n      lastDigitNumber = ciN % 10;\n      if (lastDigitNumber  == 3) { // «якщо ця цифра  3\n        console.log('  число: ' + iN );\n        break; // Вихід з внутрішнього циклу після знаходження першої трійки\n      };\n      ciN = (ciN-lastDigitNumber) / 10;\n      if (ciN  == 3) { // «якщо ця цифра  3\n        console.log('  число: ' + iN);\n        break; // Вихід з внутрішнього циклу після знаходження першої трійки\n      }\n      remainderNumbN = ciN / 10;\n    }  \n  }    \n};"
              },
              {
                type: "paragraph",
                text: "Іноді, за виконання певної умови в обчисленнях, потрібно не виходити повністю із циклу, а передавати управління виконання на наступний крок ітерації, проігнорувавши обчислення, що містяться далі в тілі циклу. Для цього можна скористатися інструкцією «**continue**». Фактично вона є альтернативою використання конструкції «**if…else**», коли альтернативна частина «**else**» включає в себе решту усіх обчислень тіла циклу. Розглянемо використання **continue** на такому прикладі:"
              },
              {
                type: "code",
                language: "javascript",
                code: "for (let i = 0; i < 100; i++) {\n  if (i % 2 != 0) continue;\n  console.log(i); // 0, 2, 4, … , 98\n}"
              },
              {
                type: "paragraph",
                text: "Зауважимо, що конструкції **break** і **continue** не можна використовувати в логічних умовах з оператором «**?**»."
              }
            ]
          },
          {
            id: 7,
            title: "Інтерфейс браузера: alert, prompt, confirm",
            content: [
              {
                type: "heading",
                text: "Інтерфейс браузера: alert, prompt, confirm"
              },
              {
                type: "paragraph",
                text: "У цій книзі ми розглядаємо стандартний JavaScript, не звертаючи увагу на особливості браузера або середовища виконання програмного коду. Але використовуючи якийсь браузер, користувачу потрібно мати засоби для обміну інформацією із ним. Для цього використовують спеціальні функції, які розміщуються в спеціалізованих бібліотеках. Ми вже застосовували деякі з них (**console.log**). Для спрощення синтаксису та підвищення якості взаємодії користувача з браузером розглянемо основні інтерфейсні функції браузера: **alert, prompt** і **confirm**."
              },
              {
                type: "subheading",
                text: "Функція alert()"
              },
              {
                type: "paragraph",
                text: "Функція відображення повідомлення у модальному вікні браузера «**alert**» будує вікно в браузері, друкує в ньому повідомлення. **Модальність** вікна означає, що після виведення повідомлення призупиняється виконання програмного коду і всіх дій до натискання користувачем кнопки «ОК». Синтаксис її такий:"
              },
              {
                type: "code",
                code: "alert(повідомлення);"
              },
              {
                type: "paragraph",
                text: "Наприклад:"
              },
              {
                type: "code",
                code: "alert(\"З Новим Роком\");"
              },
              {
                type: "subheading",
                text: "Функція prompt()"
              },
              {
                type: "paragraph",
                text: "Та для ефективної взаємодії також потрібен засіб вводу інформації (даних). Цю мету задовольняє функція «**prompt**». ЇЇ синтаксис такий:"
              },
              {
                type: "code",
                code: "змінна = prompt(заголовок, [default]);"
              },
              {
                type: "paragraph",
                text: "Другий параметр тут не обов’язковий. Він встановлює початкове значення в полі для тексту в модальному вікні. Цей параметр потрібно встановлювати за використання браузера Internet Explorer. Якщо його опустити, тоді Internet Explorer установить значення \"undefined\" у полі для введення. З появою модального вікна користувач може надрукувати потрібне в полі введення і натиснути «OK». Він може відмінити введення за допомоги кнопки «Відміна» або натиснувши на клавішу **Esc**."
              },
              {
                type: "paragraph",
                text: "Виклик **prompt** поверне як значення текст, що записаний у полі для введення, або **null**, якщо введення відмінено користувачем."
              },
              {
                type: "paragraph",
                text: "Пояснимо застосування функції на прикладі. Нехай нам потрібно організувати діалог користувача з обчислювальним середовищем відносно введення до розгляду віку користувача. Скористаємося таким кодом:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var age = prompt(\" Скільки тобі років? \", '');\nalert('Тобі: ' + age + ' років'  );"
              },
              {
                type: "paragraph",
                text: "Запустивши фрагмент коду на виконання, спочатку на моніторі отримаємо модальне вікно:"
              },
              {
                type: "image",
                src: "/images/image079.png",
                alt: "Діалогове вікно prompt з питанням про вік"
              },
              {
                type: "paragraph",
                text: "Набравши на клавіатурі число, наприклад 10, та натиснувши кнопку ОК, отримаємо модальне вікно:"
              },
              {
                type: "image",
                src: "/images/image080.png",
                alt: "Діалогове вікно alert з виведеним віком"
              },
              {
                type: "paragraph",
                text: "Та будьте обережні із використанням **prompt** у плані перетворення типів. Зважте, що у класичному варіанті значення введеної ним інформації – рядок."
              },
              {
                type: "paragraph",
                text: "Пояснимо це на такому прикладі. Нехай нам потрібно ввести для змінної «х» деяке число, збільшити його на 1 та вивести результат на друк. Здавалося, це можна просто зробити, скориставшись таким фрагментом кода:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var х = prompt(\" Уведіть значення числа\", ' ');\nx = x + 1;\nalert('Нове значення х:  '+ х );"
              },
              {
                type: "paragraph",
                text: "Нове значення х: 51."
              },
              {
                type: "paragraph",
                text: "Тобто, у виразі «**x + 1**» операція «**+**» проінтерпретувалася як операція «зчеплення (конкатенації)» двох рядків «5» + «1» і в результаті отримали рядок «51». Та це ж не те, що ми бажали. На щастя, є простий вихід із цієї ситуації. Якщо перед **prompt** поставити знак «**+**», тоді значення введеного рядка символів буде перетворюватися примусово у число. Скористаємося цим:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var х = +prompt(\" Уведіть значення числа\", ' ');\nx = x + 1;\nalert('Нове значення х:  '+ х );"
              },
              {
                type: "paragraph",
                text: "Запустивши фрагмент на виконання та увівши для х початкове значення – 5, у результаті виконання у модальному вікні отримаємо друк:"
              },
              {
                type: "paragraph",
                text: "Нове значення х: 6."
              },
              {
                type: "paragraph",
                text: "За допомоги цих двох конструкцій можливо, досить просто, робити простенькі діалоги. Наприклад, програмна реалізація знайомства та уточнення імені сестри Андрійка приводиться далі:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var name = prompt(\" Як тебе звати? \", '');\nalert('Тебе звати: ' + name );\nvar sister = prompt(\" Мені здавалося, що,твою сестру  звати Оля. Це так? \", '');\nif (sister == 'Так') {\n\talert('Як добре, що  я не забув!');;\n} else {\n\tvar name_sister = prompt (\" Тоді нагадай, будь ласка, як її    звати? \", '');\n\talert('Дякую! Тепер я знатиму, що твою сестру звати: ' +  name_sister);\n}"
              },
              {
                type: "paragraph",
                text: "Наберіть подібний фрагмент та запустіть його на виконання. Пограйтеся з різними варіантами відповідей Андрійка."
              },
              {
                type: "subheading",
                text: "Функція confirm()"
              },
              {
                type: "paragraph",
                text: "Як бачите, у подібних діалогах часто потрібно реалізовувати підтвердження чи спростування якогось висловленого твердження. Для цього використовується спеціальна функція «**confirm**». Вона реалізує визначення логічного значення як результат відповіді користувача на запитання, сформоване в модальному вікні за допомоги натискання на кнопку **OK** або **Відміна**. Функція повертає **true**, якщо натиснуто **OK**, і **false**, якщо натиснуто кнопку «Відміна» або **Esc** з клавіатури."
              },
              {
                type: "code",
                code: "result = confirm(question);"
              },
              {
                type: "paragraph",
                text: "Наприклад, якщо потрібно реалізувати підтвердження статі учня (дівчина чи хлопець), тоді набравши:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var isBoy = confirm(\"Ти хлопець?\");\nalert( isBoy); // true, якщо натиснута OK"
              },
              {
                type: "paragraph",
                text: "змінна **isBoy** прийме значення **false**, якщо натиснута кнопка «Відміна (скасувати)»."
              },
              {
                type: "paragraph",
                text: "Давайте скористаємося цією можливістю для спрощення реалізації попереднього діалогу. Фрагмент коду: **var sister = prompt(\" Мені здавалося, що,твою сестру звати Оля. Це так? \", ''); if (sister == 'Так') …** , що вимагав чіткого співпадіння нашої відповіді із рядком '**Так**', можливо замінити на простіший:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var sister = confirm(\" Мені здавалося, що,твою сестру  звати Оля. Це так? \", '');\nif (sister)….,"
              },
              {
                type: "paragraph",
                text: "який для схвальної відповіді вимагає тільки натискання кнопки «ОК»."
              },
              {
                type: "paragraph",
                text: "Тоді наш фрагмент коду прийме вигляд:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var name = prompt(\" Як тебе звати? \", '');\nalert('Тебе звати: ' + name );\nvar sister = confirm(\" Мені здавалося, що,твою сестру  звати Оля. Це так? \", '');\nif (sister) { \n\talert('Як добре, що  я не забув!');;\n} else {\n\tvar name_sister = prompt (\" Тоді нагадай, будь ласка, як її    звати? \", '');\n\talert('Дякую! Тепер я знатиму, що твою сестру звати: ' +  name_sister);\n}"
              },
              {
                type: "paragraph",
                text: "Спробуйте на практиці і цей варіант."
              },
              {
                type: "paragraph",
                text: "Наголосимо, що ці три методи реалізації взаємодії з браузером є модальними. Вони зупиняють виконання програмного коду і не дозволяють користувачу працювати з іншими складовими сторінки до закриття виділеного вікна. Розташування вікна на сторінці визначається браузером. Традиційно вікно знаходиться в центрі або зверху сторінки."
              }
            ]
          },
          {
            id: 8,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "Напишіть програму визначення суми цифр натурального числа, що вводиться із клавіатури. Наприклад, якщо ввести число 2013 починається то програма повинна друкувати «сума цифр числа 2013 = 6». Число 6 = 2 + 0 + 1+ 3.",
                  "Напишіть програму визначення знаходження 0 серед цифр натурального числа, що вводиться із клавіатури. Наприклад, якщо ввести число 2013 починається то програма повинна друкувати «Так», а якщо ввести 457 тоді – «ні». Число 6 = 2 + 0 + 1+ 3.",
                  "Напишіть програму визначення дня тижня за номером дня в тижні, що вводиться із клавіатури. Наприклад, якщо нумерація починається із 1 то якщо вводиться «3», тоді програма має друкувати «середа».",
                  "Напишіть програму яка вводить з клавіатури ціле число що визначає кількість елементів послідовності цілих чисел та вводить з клавіатури їх значення. Знайти та вивести на друк максимальний і мінімальний елемент введеної послідовності. При вирішенні підзадачі перебору елементів послідовності скористайтеся трьома різними операторами циклу та установіть який саме оператор циклу є найбільш підходящим і чому.",
                  "Напишіть програму яка вводить з клавіатури два цілих числа N і К, перше визначає кількість елементів масиву цілих чисел A[N], та заповнює цей масив псевдовипадковими числами. Знайти та вивести на друк індекс j такого елемента масиву A[j], значення якого A[j] = К.",
                  "Напишіть програму яка вводить з клавіатури ціле число N, що визначає кількість елементів масиву цілих чисел A[N], та заповнює цей масив псевдовипадковими числами. Впорядкуйте за допомоги алгоритму «бульбашка» масив A[N] і виведіть його на друк.",
                  "Указівка. Алгоритм 'бульбашкового' сортування: Суть цього упорядкування, наприклад по неспаданню, полягає в наступному. Будемо переглядати зліва направо всі пари сусідніх елементів: A[1] і A[2], A[2] і A[3], ..., A[ N-1] і A [N]. Якщо при цьому A[I>] A[I + 1], то елементи міняємо місцями. В результаті такого перегляду масиву максимальний елемент виявиться на крайньому правому (своєму) місці. Про інші елементи нічого певного сказати не можна. Будемо переглядати масив знову, виключивши з розгляду правий елемент. На своєму місці тепер виявиться вже другий за величиною елемент. І так далі. В останньому перегляді братимуть участь тільки перший і другий елементи.",
                  "Модифікуйте програму із попереднього завдання врахувавши наступний факт. Часто масив виявляється відсортованим вже після кількох перших ітерацій алгоритму і подальші ітерації не потрібні. Тому, якщо на якомусь проході масиву жоден обмін не проведений, то масив уже відсортований, і робота алгоритму закінчена."
                ]
              }
            ]
          }
        ]
  },
  {
    id: 4,
    title: "Функції",
    topics: [
      {
        id: 1,
            title: "Парадигма процедурного програмування. Підпрограми",
        content: [
          {
            type: "heading",
            text: "Парадигма процедурного програмування. Підпрограми"
          },
          {
            type: "paragraph",
            text: "У 1999 році відомий інженер програмного забезпечення Тім Пі-терс написав набір з 19 принципів гарного стилю написання програмного коду і розмістив його у списку розсилки Python. Серед них ми виділимо чотири, які суттєво впливають на якість програми:"
          },
          {
            type: "list",
            items: [
              "простота – це добре",
              "монолітність – це погано",
              "будь послідовним у досягненні мети",
              "явне значно краще неявного",
              "угода пріоритетніша за конфігурацію"
            ]
          },
          {
            type: "paragraph",
            text: "Наприклад, для їх дотримування при розв'язанні складних задач використовують метод декомпозиції. Задача розбивається на простіші підзадачі, знаходяться розв'язки підзадач і з них комбінується побудова загального розв'язку задачі. Відповідно алгоритм, що знаходить розв'язок окремої підзадачі, називають допоміжним алгоритмом, а відповідну «допоміжну програму» – підпрограмою (або процедурою)."
          },
          {
            type: "paragraph",
            text: "У багатьох мовах програмування процедура оформляється так само або майже так само, як головна програма. Тобто підпрограма це виділений фрагмент коду з визначеними вхідними і вихідними параметрами для позначення вхідних даних і результату обробки відповідно. Одна і та ж підпрограма може обробляти різні дані, передані їй як аргументи. Від інших даних основної (головної) програми підпрограма, в ідеалі, ізольована (хоча багато мов програмування дозволяють використовувати всередині коду підпрограми глобальні змінні). Та це вважається «поганим» стилем програмування."
          },
          {
            type: "subheading",
            text: "Коли використовують підпрограми?"
          },
          {
            type: "paragraph",
            text: "Окрім реалізації вирішення підзадач, у випадку коли один фрагмент коду використовується кілька разів у програмі. Очевидна доцільність одноразового складання таких часто вживаних фрагментів програмного коду, зберігання їх і подальше використання в найрізноманітніших завданнях. Набори таких підпрограм зазвичай об'єднують в бібліотеки підпрограм."
          },
          {
            type: "paragraph",
            text: "Підпрограми найчастіше застосовують для спрощення процесу розробки і відлагодження програми методом послідовних уточнень. Окрім виділення реалізації підзадач підпрограмами практично кожний програмний модуль технологічно може бути розбитий на етапи: введення даних, перевірка правильності цього введення, обробку даних і виведення назовні результатів обробки. Далі, за потреби, кожен з етапів розбивають на більш дрібні, потім, при необхідності - ще. Так продовжуємо, поки підзадачі не опиняться настільки простими, що кожну з них можна буде записати за допомогою невеликої і зрозумілої підпрограми (процедури)."
          },
          {
            type: "paragraph",
            text: "Такий спосіб розробки програм називають проектуванням методом зверху-донизу. Підпрограма є основним будівельним блоком в імперативному програмуванні (таке програмування описує процес виконання програми у вигляді інструкцій, що змінюють стан виконавця)."
          },
          {
            type: "paragraph",
            text: "Проектування методом зверху-донизу забезпечує:"
          },
          {
            type: "list",
            items: [
              "Скорочення часу розробки великих програм",
              "Оптимізацію процесу відлагодження програми шляхом простої локалізації місць помилок (розібратися в роботі процедури і знайти можливу помилку набагато простіше, якщо ця процедура коротка)",
              "Відносну автономність модифікації програми (коли потрібно внести корективи у програму, це робиться шляхом переробки деяких процедур)",
              "Розпаралелювання розробки і відлагодження програми між бригадою програмістів"
            ]
          },
          {
            type: "paragraph",
            text: "Більшість мов програмування (МП) мають засоби уточнення (реалізації) двох основних абстракцій: абстракцію процесів і абстракцію даних. Під абстракцією розуміється дія, що складається у виборі для подальшого вивчення або використання невеликого числа властивостей об'єкта і вилучення з розгляду інших властивостей, які нам в даний момент не потрібні. У цьому розділі ми зосередимося на процедурних засобах уточнення абстракції процесів."
          },
          {
            type: "paragraph",
            text: "Складний процес містить у собі багато підпроцесів, деякі з яких можуть повторюватись багато разів зовсім незмінними або з незначними змінами власних параметрів функціонування. Ці підпроцеси у МП описуються певним набором операторів, які записується у вигляді підпрограми. Повторне використання підпрограм дозволяє зменшити час розробки програмного продукту і представляє собою абстракцію, у якій деталі обчислень, виконаних підпрограмою, замінені в програмі оператором, що викликає цю підпрограму – оператором виклику, що дозволяє дійсно абстрагуватися від деталей обчислень в місцях виклику, поліпшує читабельність програми, дозволяє легко виявити її логічну структуру."
          },
          {
            type: "paragraph",
            text: "В основному підпрограми мають задовольняти таким умовам:"
          },
          {
            type: "list",
            items: [
              "Має один вхід",
              "На час виконання викликаної підпрограми виконання модуля, що її викликав, відкладається",
              "Керування після виконання підпрограми завжди повертається на наступний оператор за оператором виклику підпрограми у модулі, що її викликав"
            ]
          },
          {
            type: "paragraph",
            text: "Визначення підпрограми має описувати її взаємодію (тобто інтерфейс) із модулем, який її викликав, і дії, що абстрагуються підпрограмою. Інтерфейс підпрограми визначається заголовком підпрограми а дії – тілом підпрограми. Заголовок підпрограми містить службове слово, яке указує на тип підпрограми (процедура чи функція), ім'я підпрограми і необов'язковий список параметрів. Можливі різні варіації заголовку підпрограми. Наприклад, у випадку коли МП підтримує тільки один тип підпрограм це спеціальне слово визначення типу підпрограми опускається. У якості імені підпрограми виступає ідентифікатор визначений у мові. Профіль параметрів підпрограми включає визначення кількості, порядок підстановки параметрів і їх типи. Тіло підпрограми може мати всі компоненти притаманні тілу програми."
          },
          {
            type: "paragraph",
            text: "У тілі підпрограми описують потрібні обчислення над даними розміщеними у пам'яті компа. До цих даних можна добратися через глобальне ім'я або передачу параметрів. Глобальне ім'я визначається глобальною змінною спеціально оголошеною десь в іншому місці в програми, але видимої в підпрограмі. Дані, передані через параметри, доступні за іменами, що є локальним для підпрограми. Таку підпрограму, що одержує через параметри доступ до даних, які потрібно обробити, є параметризованим обчисленням. Вона може виконати обчислення описані в тілі підпрограми на підставі будь-яких даних, одержуваних через параметри (за умови, що типи параметрів збігаються з очікуваними в підпрограмі). Якщо доступ до даних здійснюється через глобальні змінні, для проміжних обчислень у тілі підпрограми бажано працювати із копіями глобальних змінних, присвоївши їхні значення локальним змінним підпрограми, щоб не пошкодити глобальні дані у випадку нештатних ситуацій. Широкий доступ до глобальних змінних у підпрограмах може знизити надійність програми."
          },
          {
            type: "paragraph",
            text: "У деяких ситуаціях зручно передавати в підпрограми як параметри не дані, а обчислення. Тоді ім'я підпрограми, що реалізує таке обчислення, можна використовувати як параметр."
          },
          {
            type: "paragraph",
            text: "Параметри заголовку підпрограми називають формальними параметрами. Те, що підставляється за них при виклику підпрограми, називають фактичними параметрами. Зв'язування фактичних параметрів з формальними на основі позиційного принципу, тобто на основі їхнього розміщення у списку заміщення. Перший фактичний параметр відповідає першому формальному параметру, другий – другому і так далі. У більшості МП кількість фактичних параметрів у виклику має збігатися з кількістю формальних параметрів у визначенні заголовка підпрограми."
          },
          {
            type: "paragraph",
            text: "Підпрограми розділяються на дві різні категорії: процедури і функції. Процедури – це набори нових операторів, що визначають параметризовані обчислення, які активізуються операторами виклику. Наприклад, якщо в мові не має оператора впорядкування послідовності імен, то програміст може написати процедуру впорядкування цих імен і викликати її в потрібних місцях програми."
          },
          {
            type: "paragraph",
            text: "Функції у МП по своїй суті нагадують математичні функції. Функцію можна викликати, вказавши її ім'я у виразі разом з відповідними фактичними параметрами. Значення, обчислене при виконанні функції, повертається в модуль, який її викликав і замінює собою виклик. Функції – це нові оператори, визначені користувачем. Наприклад, якщо в мові немає оператора, що обчислює значення середнього арифметичного двох чисел, можна написати функцію, яка обислює і повертає це значення."
          },
          {
            type: "paragraph",
            text: "Функція JavaScript – це блок програмного коду, який визначається один раз і може викликатися багаторазово. Функції можуть визначатися програмістом або бути вмонтованими в мову. Прикладом останніх можуть слугувати такі функції як: eval() і parseInt(), сonsole.log(), alert(). Вбудовані функції застосовуються в точності так, як і функції, визначені користувачем."
          },
          {
            type: "paragraph",
            text: "Процедурне програмування (ПП) - це одна з парадигм програмування. Парадигма програмування визначає те, як програміст підходить до реалізації алгоритму і проектування програми. У ПП програма представляється через визначену послідовність виклику процедур."
          },
          {
            type: "paragraph",
            text: "Із застосуванням ПП з'явилися широкі можливості колективної розробки програм і ефективного повторного використання створеного раніше коду."
          },
          {
            type: "paragraph",
            text: "Основу процедурної програми складає головна підпрограма в якій визначають початок і кінець загального алгоритму, яка щось робить сама, а щось доручає виконати допоміжним підпрограмам, які, в свою чергу, роблять щось самі і, можливо, викликають на виконання інші допоміжні підпрограми і т.д."
          },
          {
            type: "paragraph",
            text: "Парадигма об'єктно-орієнтованого програмування включає в себе і процедурну парадигму."
              }
            ]
          },
          {
            id: 2,
            title: "Визначення і виклик функцій",
            content: [
              {
                type: "heading",
                text: "Визначення і виклик функцій"
          },
          {
            type: "paragraph",
                text: "Заголовок функції у JavaScript має такий синтаксис:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function ім'я_функції(необов'язковий список імен параметрів, розділених комами) {\n  // тіло функції\n};"
              },
              {
                type: "paragraph",
                text: "У тілі функції може бути присутня інструкція return. Вона припиняє виконання функції і повертає значення зазначеного в ній виразу (якщо він є) у місце виклику; при відсутності виразу інструкція повертає значення undefined. Якщо функція не містить інструкцію return, вона просто виконує всі інструкції в своєму тілі і повертає невизначене значення (undefined)."
              },
              {
                type: "paragraph",
                text: "Давайте напишемо функцію обчислення середнього арифметичного двох чисел та розглянемо приклад її виклику."
              },
              {
                type: "code",
                language: "javascript",
                code: "// Функція обчислення середнього арифметичного.\nfunction mіddle(x1, x2) { // заголовок функції\n  return ((x1 + x2)/2); // тіло функції\n}; // кінець тіла функції\n\nvar y1 = prompt(\"введіть перше число:\");\nconsole.log(\"y1 =  \", y1);\nvar y2 = prompt(\"введіть друге число:\");\nconsole.log(\"y2 =  \", y2);\nvar z = mіddle(Number(y1), Number(y2)); // виклик функції\nconsole.log(\"середнє арифметичне =  \", z);\n//y1 = 10\n//y2 = 20\n//середнє арифметичне = 15"
              },
              {
                type: "paragraph",
                text: "Звернемо вашу увагу на виклик нашої функції «mіddle(Number(y1), Number(y2));». Замість першого формального параметру x1 маємо підставити значення фактичного параметру y1, а замість другого формального параметру x2 маємо підставити значення фактичного параметру y2. Тому щоб підставити їх значення використовуємо інструкцію Number. Якщо поставити виклик: var z = mіddle(y1, y2); тоді отримаємо повідомлення про помилку у визначенні y1: Uncaught ReferenceError: y1 is not defined. Зазначимо, що імена формальних і фактичних параметрів можуть співпадати, та це суттєво погіршує читабельність програми."
              },
              {
                type: "subheading",
                text: "Виклик функції"
              },
              {
                type: "paragraph",
                text: "Після визначення, функція може викликатися у різних місцях програми за допомогою конструкції () з іменем функції. Вони стоять після імені та обмежують визначення необов’язкового списку фактичних параметрів, записаних через кому. Виклик функції може знаходитися в будь-якому виразі JavaScript, який повертає значення. У якості фактичного параметру може виступати і допустимий вираз."
              },
              {
                type: "paragraph",
                text: "Враховуючи динамічну типізацію змінних у JavaScript, виклики функцій у цій мові мають певні відмінності від тих, які ми зазначали при описі викликів у підпрограмах вище. Перше, при описі параметрів їх тип вказувати не потрібно. За потреби тип алгоритму програміст може визначити, скориставшись оператором typeof. Друге, JavaScript не перевіряє на співпадіння за кількістю списку формальних і списку фактичних параметрів. Якщо фактичних аргументів зазначено більше у виклику, то надлишкові параметри ігноруються. Якщо аргументів менше, то відсутнім присвоюється значення undefined. Важливо тут те, щоб програміст враховував ці особливості, які можуть суттєво вплинути на сутність обчислень заданих у функції."
              },
              {
                type: "paragraph",
                text: "Для пояснення використання функцій без інструкції return перепишемо нашу програму про оптимізацію решти гривень касового апарату."
              },
              {
                type: "code",
                language: "javascript",
                code: "// Функція обчислення і друку решти.\nfunction changeF(x1) {\n  var banknote = [500, 200, 100, 50, 20, 10, 5, 2, 1];\n  var leng = banknote.length;\n  for (var count = 0; count <= leng - 1; count++) {\n    countBanknote = 0;\n    if (x1 == 0) break;\n    else {\n      while (x1 / banknote[count] >= 1) {\n        countBanknote++;\n        x1 = (x1 - banknote[count]);\n      };\n    };\n    if (countBanknote > 0)\n      console.log(\"видати \", countBanknote, \" купюр розмірності \", banknote[count]);\n  };\n};\n\nvar change1 = prompt(\"Введіть решту:\");\nconsole.log(\"change =  \", change1);\nchangeF(change1); // 1-й виклик функції\n\nvar change2 = prompt(\"Введіть решту:\");\nconsole.log(\"change =  \", change2);\nchangeF(change2); // 2-й виклик функції\n\n//change =   67\n//видати  1  купюр розмірності  50\n//видати  1  купюр розмірності  10\n//видати  1  купюр розмірності  5\n//видати  1  купюр розмірності  2\n\n//change =   78\n//видати  1  купюр розмірності  50\n//видати  1  купюр розмірності  20\n//видати  1  купюр розмірності  5\n//видати  1  купюр розмірності  2\n//видати  1  купюр розмірності  1"
              },
              {
                type: "paragraph",
                text: "У цій програмі changeF(x1) обчислює мінімальну кількість купюр і значення їх та виводить їх на друк. Здійснивши друк після виклику changeF(change1), функції нічого (ніякого значення) не потрібно повертати в програму виклику. Тому в ній відсутня інструкція return і на виході changeF(change1) повертає значення undefined."
              },
              {
                type: "paragraph",
                text: "Змінна x1 виступає тут в якості формального параметру – аргументу функції. Змінні banknote, count визначені в тілі функції changeF з оператором var, називають локальними змінними функції. Тобто, після виходу із тіла функції їх значення недоступні. Так при зверненні до них після закінчення нашої програми отримаємо повідомлення про помилки:"
              },
              {
                type: "code",
                language: "javascript",
                code: "banknote[2]; // Uncaught ReferenceError: banknote is not defined\ncount; // Uncaught ReferenceError: count is not defined"
              },
              {
                type: "paragraph",
                text: "Змінні change1, change2 називають глобальними змінними програми. Вони виступають у якості фактичних параметрів функції при її виклику changeF(change1), changeF(change2). Їх значення, як і значення змінної countBanknote (використаної в тілі функції changeF без оголошення в var) доступні у довільному місці програми."
              },
              {
                type: "subheading",
                text: "Функціональні літерали"
              },
              {
                type: "paragraph",
                text: "Cтандарт ECMAScript v3 надає ще одну можливість (реалізовану в JavaScript 1.2 і пізніших версіях) для визначення функцій за допомогою функціональних літералів. Синтаксис цього задання такий:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var функціональний_літерал = function(список формальних параметрів) { тіло функції };"
              },
              {
                type: "paragraph",
                text: "Перевага такого визначення функції від попереднього полягає у використанні функціонального літералу в виразах JavaScript для наглядності (уточненні) запису складнішого сценарію. Використання функціональних літералів корисне і при рекурсивному виклику функцій. Так функція обчислення значення середнього арифметичного двох чисел може бути перевизначена так:"
              },
              {
                type: "code",
                language: "javascript",
                code: "// Визначення функціїї обчислення середнього арифметичного як функціонального літералу\nvar mіd = function(x1, x2) {\n  return ((x1 + x2)/2);\n};\n\nvar y1 = prompt(\"введіть перше число:\");\nconsole.log(\"y1 =  \", y1);\nvar y2 = prompt(\"введіть друге число:\");\nconsole.log(\"y2 =  \", y2);\nvar z1 = mіd(Number(y1), Number(y2));\nvar z = mіd(Number(y1), Number(y2)) + 6; // виклик функції у виразі\nconsole.log(\"середнє арифметичне =  \", z1);\nconsole.log(\"z =  \", z);\n//y1 =   6\ny2 =   14\n//середнє арифметичне = 10\n//z =   16"
              }
            ]
          },
          {
            id: 3,
            title: "Глобальні і локальні змінні",
            content: [
              {
                type: "heading",
                text: "Глобальні і локальні змінні"
              },
              {
                type: "paragraph",
                text: "У функції є повний доступ до зовнішніх (глобальних) змінних на зчитування та запис."
              },
              {
                type: "paragraph",
                text: "Зовнішня змінна використовується, тільки якщо всередині функції немає такої локальної. Якщо однойменна змінна оголошується в середині функції, тоді це оголошення перекриває зовнішнє. Наприклад, в наступному коді функція використовує локальну змінну userName. Зовнішня буде проігнорована:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var userName = \"Тарас\";\nfunction showMessage() {\n   var userName = \"Петро\"; // оголошуємо локальну змінну\n   var message = 'Привіт, ' + userName; // Петро\n  alert(message);\n}\n/* функція створить і буде використовувати свою локальну змінну username*/\nshowMessage();\nalert( userName ); /*Тарас, значення не змінилось, функція не змінила зовнішню змінну*/"
              },
              {
                type: "paragraph",
                text: "Змінні, оголошені зовні всіх функцій, такі як зовнішня змінна userName у попередньому коді - називаються глобальними. Глобальні змінні видимі для будь-якої функції (якщо тільки їх не перекривають однойменні локальні змінні)."
              },
              {
                type: "paragraph",
                text: "Для кращої роботи з пам’яттю бажано мінімально використовувати глобальні змінні. Хоча, вони корисні для зберігання найважливіших загально-проектних даних."
              },
              {
                type: "paragraph",
                text: "При передачі фактичних параметрів значення використаних змінних копіюються, тому будь-які маніпуляції з параметрами не впливають на їх значення зовні функції:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function showMessage(from, text) {\n  from = '*' + from + '*'; \n  alert( from + ': ' + text );\n}\nvar from = \"Аня\";\nshowMessage(from, \"Привет\"); // *Аня*: Привіт\n/*значення \"from\" не змінилось, функція змінила значення локальної змінної*/\nalert( from ); // Аня"
              },
              {
                type: "paragraph",
                text: "Ми вже зазначали, що, якщо параметр не вказаний явно, його значенням стає undefined. Можна вказати значення параметра за замовчанням:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function showMessage(from, text = \"текст не доданий\") {\n  alert( from + \": \" + text );\n}\nshowMessage(\"Аня\"); // Аня: текст не доданий"
              },
              {
                type: "paragraph",
                text: "Параметром за замовчанням може бути функція. Вона виконується тільки якщо параметр не вказали явно і при виклику:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function showMessage(from, text = anotherFunction()) {\n  /*anotherFunction() виконеться тільки якщо text не буде переданий\n   результатом буде значення text*/\n}; ."
              },
              {
                type: "paragraph",
                text: "У JavaScript параметри за замовчанням обчислюються при кожному виклику функції (якщо параметр не вказаний явно)."
              },
              {
                type: "paragraph",
                text: "Функція може повернути результат, який буде переданий в код, що викликав її:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function sum(a, b) {\n  return a + b;\n}\nvar result = sum(1, 2);\nalert( result ); // 3  ."
              },
              {
                type: "paragraph",
                text: "Результат функції з порожнім return або без нього - undefined."
              },
              {
                type: "paragraph",
                text: "Ніколи не додавайте новий рядок між return і його значенням. Якщо набрати: return (some + long + expression + or + whatever * f(a) + f(b)) ; код не виконається, тому що інтерпретатор JavaScript підставить крапку з комою після return. Якщо вираз, що повертається із функції займає кілька рядків, потрібно почати його писати на тому ж рядку, що і return, або поставити там відкриваючу дужку та не забути і закриваючу дужку після закінчення виразу."
              }
            ]
          },
          {
            id: 4,
            title: "Рекурсія",
            content: [
              {
                type: "heading",
                text: "Рекурсія"
              },
              {
                type: "paragraph",
                text: "Рекурсія – визначення, опис, зображення якого-небудь об\'єкту або процесу всередині самого цього об\'єкта або процесу, тобто описує ситуацію, коли об\'єкт є частиною самого себе. Термін «рекурсія» використовується в різних спеціальних галузях знань, починаючи з лінгвістики і закінчуючи логікою, але найбільш широке застосування знаходить в математиці та інформатиці. Рекурсія є досить поширеним явищем, яке зустрічається й у повсякденному житті. На рисунку 2.11 представлено відомий ефект Дросте. Він характеризує зображення в якому це ж зображення представлено в меншому розмірі."
              },
              {
                type: "image",
                src: "/images/image081.jpg",
                alt: "Рис. 2.11 Ефект Дросте."
              },
              {
                type: "paragraph",
                text: "Подібний ефект або один із варіантів побачити рекурсію – це навести Web камеру на екран монітора комп\'ютера, природно, попередньо її включивши. У цьому випадку, камера буде записувати зображення екрану комп\'ютера, і виводити його ж на цей екран, вийде щось на зразок замкнутого циклу. У підсумку ми будемо спостерігати щось схоже на тунель представлений на рис. 2.12."
              },
              {
                type: "image",
                src: "/images/image082.png",
                alt: "Рис. 2.12 Рекурсивний екран монітора"
              },
              {
                type: "paragraph",
                text: "Найбільш видовищним прикладом рекурсії є географічні об\'єкти. Наприклад, острови посеред озер, які в свою чергу розташовані на островах. Серед таких об\'єктів найвідомішим є прісноводне озеро Тааль, розташоване на острові Лоусон в провінції Батангас, Філіппіни. На озері знаходиться вулканічний острів Тааль, в його кратері є ще одне озеро. А на ньому в свою чергу є свій власний невеликий острів, Вулкан-Пойнт (рис. 2.13)."
              },
              {
                type: "image",
                src: "/images/image083.png",
                alt: "Рис. 2.13. Озеро Тааль."
              },
              {
                type: "paragraph",
                text: "Прикладом рекурсії в природі є голівка соняшника зображена на рис. 2.14."
              },
              {
                type: "image",
                src: "/images/image084.png",
                alt: "Рис. 2.14. Соняшник"
              },
              {
                type: "paragraph",
                text: "Яскравим прикладом рекурсії з тваринного світу, теж досить наочні: одвічна пара «куриця і яйце» і ... еволюція (рис.2.15):"
              },
              {
                type: "image",
                src: "/images/image085.png",
                alt: "Рис. 2.15. Еволюція яйця і куриці."
              },
              {
                type: "paragraph",
                text: "Самими ж відомими прикладами нескінченної рекурсії в літературі є «нескінченні казки»:"
              },
              {
                type: "paragraph",
                text: "Я відкрив свої очі. Блакитні небеса, І зелене покривало, І волохатий ліс ... Ось і річка - все тече, Сонце встало - знову пече ... Взяв я ручку і зошит та вирішив все записати,… Я відкрив свої очі Блакитні небеса ..."
              },
              {
                type: "paragraph",
                text: "В математиці рекурсія має відношення до методу визначення функцій і числових рядів: рекурсивно задана функція визначає своє значення через звернення до себе самої з іншими аргументами. При цьому можливі два варіанти: кінцева рекурсивна функція і нескінченна. Кінцева рекурсивна функція задається таким чином, щоб для будь-якого кінцевого аргументу за кінцеве число рекурсивних звернень привести до одного з окремо визначених окремих випадків, що обчислюються без рекурсії. Класичний приклад – факторіал цілого невід\'ємного числа. Тут кожне наступне рекурсивне звернення робиться з аргументом, меншим на одиницю. Оскільки n, за визначенням, ціле невід\'ємне число, через n рекурсивних звернень обчислення функції гарантовано прийде до окремого випадку, на якому рекурсія припиниться. Таким чином, незважаючи на рекурсивність визначення, обчислення функції для будь-якого аргументу з області визначення виявиться кінцевим. Наприклад, факторіал числа n позначається « n!» і визначається так:"
              },
              {
                type: "code",
                language: "text",
                code: "n! = n * (n-1) * (n-2)* …* 2*1.\nТак, 5!= 5*4*3*2*1 = 120."
              },
              {
                type: "paragraph",
                text: "Рекурсивну схему (алгоритм) цього обчислення можна описати:"
              },
              {
                type: "code",
                language: "text",
                code: "якщо (n > 1) тоді fac  = n* fac(n-1)\n\tінакше, коли (n = 1) fac  = 1."
              },
              {
                type: "paragraph",
                text: "Нескінченна рекурсія представляє числову послідовність, яка задана рекурентною формулою, коли кожен наступний член послідовності обчислюється як результат функції від n попередніх членів. У цьому випадку за допомогою кінцевого виразу (що представляє собою сукупність рекурентної формули і набору значень для перших n членів послідовності) може даватися визначення нескінченної послідовності. Прикладом такої рекурентної формули може виступати рекурентна формула задання чисел Фібоначчі. Чи́сла Фібона́ччі — елементи числової послідовності  1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, …, в якій  перші  два числа рівні або 1 і 1, або 0 і 1, а кожне наступне число рівне сумі двох попередніх. У математиці цю послідовність задають рекурентним співвідношенням. Рекурентний (лат., той, що повертається) той, що дає змогу відшукувати значення якоїсь величини за знайденими раніше іншими значеннями тієї самої величини."
              },
              {
                type: "paragraph",
                text:"F1=1, F2=1, Fn+2=Fn+Fn+1,    n=1,2,3,…\nF1 =1, F2 =1, F3 =2, F4 =3, F5 =5, F6 =8, F7 =13, F8 =21,…"
              },
              {
                type: "paragraph",
                text:"F1 =1, F2 =1, F3 =2, F4 =3, F5 =5, F6 =8, F7 =13, F8 =21,…"
              },
              {
                type: "paragraph",
                text: "Часто, особливо в сучасному вигляді, послідовність доповнюється ще одним початковим членом – нулем. За визначенням, тоді кожне наступне число є сумою двох попередніх, починаючи з      n=4 ."
              },
              {
                type: "paragraph",
                text: "Багато явищ і закономірностей у природі, мистецтві, архітектурі описується на основі використання послідовності чисел Фібоначчі або їх співвідношень. Однією із найвідоміших є співвідношення яке називають золотим перерізом. Золотий переріз (золота пропорція, розподіл в крайньому і середньому відношенні) є поділ відрізка АС на дві частини таким чином, що більша його частина АВ відноситься до меншої ВС так, як весь відрізок АС відноситься до АВ (тобто АВ: ВС = АС : АВ). Приблизно це відношення  5: 3, точніше 8: 5, 13: 8 і т. д. Термін «золотий перетин» згадувався римським істориком Вітрувієм як основна пропорція класичної грецької архітектури. Ця пропорція, що вважається приємною для споглядання, присутня  в багатьох зразках архітектури і живопису Ренесансу."
              },
              {
                type: "image",
                src: "/images/image086.jpg",
                alt: "Визначення та приклади застосування"
              },
              {
                type: "paragraph",
                text: "Значення пропорції приблизно рівне 1,618. На рисунку 2.16 показаний спосіб геометричного побудови відрізка, відповідного числу 1.618 та відомі приклади застосування (Пропорції Парфенона в Афінах). Давайте уважно придивимося до чисел, які утворюють це відношення - 5: 3,  8: 5, 13: 8 і 21: 13, 34: 21 і т. д. Ви вже зрозуміли, що пару у відношенні утворюють числа Фібоначчі. Рекурентну схему (алгоритм) обчислення чисел послідовності Фібоначчі, що починається з одиниці, можна описати:"
              },
              {
                type: "code",
                language: "text",
                code: "Якщо (n > 2) тоді fib  = fib(n-1) + fib(n-2)\nІнакше\n      Початок\n           fib(1)  = 1;           fib(2)  = 1;\n      кінець."
              },
              {
                type: "paragraph",
                text: "З рекурсією тісно пов\'язана математична індукція. Вона є природним способом доведення властивостей функцій на натуральних числах, які рекурсивно задаються через свої менші значення."
              },
              {
                type: "paragraph",
                text: "У програмуванні рекурсія це виклик функції (процедури) з неї ж самої, безпосередньо (проста рекурсія) або через інші функції (складна або непряма рекурсія). Наприклад, функція А викликає функцію Б, а функція Б – функцію А. Рекурсивна програма дозволяє описати ітераційне або навіть потенційно нескінченне обчислення, причому без явних повторень частин програми і використання циклів. Кількість вкладених викликів функції або процедури називається глибиною рекурсії. Структурно рекурсивна функція на верхньому рівні завжди має команду розгалуження (вибір однієї з двох або більше альтернатив в залежності від умови (умов), яку в цьому випадку доречно назвати «умовою припинення рекурсії»), що має дві або більше альтернативні гілки, з яких хоча б одна є рекурсивної і хоча б одна – термінальною (скінченою, визначальною). Так у нашому прикладі рекурсивного визначення побудови чисел Фібоначчі у якості команди розгалуження виступає гілка якщо (n > 2)…, а умовою припинення рекурсії (зворотнім кроком рекурсії) буде умова n < 2, тобто гілка інакше …"
              },
              {
                type: "paragraph",
                text: "Реалізація рекурсивних викликів функцій в практично застосовуваних мовах і середовищах програмування, як правило, спирається на механізм стеку викликів. Тобто, адреса повернення і локальні змінні функції записуються в стек, завдяки чому кожен наступний рекурсивний виклик цієї функції користується своїм набором локальних змінних і за рахунок цього працює коректно. Стек, спеціальна комора, яка працює за наступним правилом. Останнє покладене в комору видається першим при зверненні на видачу. Зворотним боком цього досить простого за структурою механізму є те, що на кожен рекурсивний виклик потрібна деяка кількість оперативної пам\'яті комп\'ютера, і при надмірно великій глибині рекурсії може наступити переповнення стеку викликів. Розглянемо механізм стеку викликів на прикладі рекурсивної програми обчислення 4!. При виклику функції fac(4), 4>1 і тому йдемо на гілку рекурсивного виклику: fac(4) = 4 * fac(3). Цей виклик заноситься в стек-комору:"
              },
              {
                type: "paragraph",
                text: "fac(4) = 4 * fac(3)\nі викликається на виконання функція  fac(3)."
              },
              {
                type: "code",
                language: "text",
                code: "fac(4) = 4 * fac(3)"
              },
              {
                type: "paragraph",
                text: "При виклику функції fac(3), 3>1 і тому йдемо на гілку рекурсивного виклику: fac(3) = 3* fac(2). Цей виклик заноситься в стек-комору:"
              },
              {
                type: "code",
                language: "text",
                code: "fac(3) = 3 * fac(2)\nfac(4) = 4* fac(3)"
              },
              {
                type: "paragraph",
                text: "і викликається на виконання функція  fac(2)."
              },
              {
                type: "paragraph",
                text: "При виклику функції fac(2), 2>1 і тому йдемо на гілку рекурсивного виклику: fac(2) = 2* fac(1). Цей виклик заноситься в стек-комору:"
              },
              {
                type: "code",
                language: "text",
                code: "fac(2) = 2* fac(1)\nfac(3) = 3 * fac(2)\nfac(4) = 4* fac(3)"
              },
              {
                type: "paragraph",
                text: "і викликається на виконання функція  fac(1)."
              },
              {
                type: "paragraph",
                text: "При виклику функції fac(1), умова  1>1  приймає значення хибність і управління передається на гілку зворотного кроку рекурсії (гілку «інакше»)  – виконується визначення  fac(1) = 1. Після цього управління передається на обробку викликів функцій, які знаходяться у стеці-коморі"
              },
              {
                type: "paragraph",
                text: "Із нього послідовно вибирається на виконання і видаляється черговий   занесений виклик функції. Процес повторюється до тих пір поки стек-комора не стане пустою."
              },
              {
                type: "paragraph",
                text: "У нашому прикладі прийдемо до такої послідовності дій."
              },
              {
                type: "paragraph",
                text: "Наразі,  стек-комора не пуста, тоді:"
              },
              {
                type: "code",
                language: "text",
                code: "Початок\nВибрати останній занесений виклик :\nfac(2) = 2* fac(1);\nВиконати: fac(2) = 2* fac(1)= 2* 1= 2;\nВидалити  із стеку:\nfac(3) = 3 * fac(2)\nfac(4) = 4* fac(3)\n  кінець."
              },
              {
                type: "paragraph",
                text: "Наразі, стек-комора не пуста, тоді:"
              },
              {
                type: "code",
                language: "text",
                code: "Початок\n      Вибрати останній занесений виклик:\n     fac(3) = 3* fac(2);\n    Виконати: fac(3) = 3* fac(2)=   3* 2= 6;\n    Видалити із стеку:\nfac(4) = 4* fac(3)\n    Кінець."
              },
              {
                type: "paragraph",
                text: "Наразі, стек-комора не пуста, тоді: "
              },
              {
                type: "code",
                language: "text",
                code: "Початок\n   Вибрати останній занесений виклик :\n    fac(4) = 4* fac(3);\n   Виконати: fac(4) = 4* fac(3)=   4* 6= 24;\n     Видалити із стеку:\n\n    кінець."
              },
              {
                type: "paragraph",
                text: "Стек пустий. Тоді повернути у місце виклику функції обчислене значення 24.\n(4!=24)."
              },
              {
                type: "paragraph",
                text: "Структуру рекурсивного алгоритму найчастіше будують так, щоб рекурсивний виклик був останньою виконуваною операцією в функції, а його результат безпосередньо повертається в якості результату функції («хвостова рекурсія»). Такі рекурсивні обчислення, навіть якщо вони формально нескінченні (наприклад, коли за допомогою рекурсії організовується робота командного інтерпретатора, що приймає команди користувача), ніколи не призводять до виснаження пам\'яті. Повернемося до JavaScript і порівняємо ітераційний та рекурсивний варіант реалізації функції обчислення факторіалу."
              },
              {
                type: "code",
                language: "javascript",
                code: "// Введення натурального числа для якого шукатимемо факторіал\nvar num = prompt(\"Ведіть натуральне число \");\nvar fac= function(n) // Визначення функції обчислення факторіалу\n {\n    if (n == 0)\n      {\n        return 1;\n       } \n    else \n      {\n        product = 1;\n        for (var i = 1; i <= n; i++) \n          {\n            product *= i;\n\\t }\n        return product;\n      }\n    }\nconsole.log(fac (num));"
              },
              {
                type: "paragraph",
                text: "Рекурсивна версія функція-літерал за вищеописаної схеми прийме вигляд:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var fact = function(n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * fact (n - 1);\n    }\n}\nconsole.log(fact (num));"
              },
              {
                type: "paragraph",
                text: "Дійшла черга до реалізації рекурсивної функції знаходження n-го числа Фібоначчі:  "
              },
              {
                type: "code",
                language: "javascript",
                code: "// введення значення n\nvar num = Number(prompt(\\\"введіть значення n\\\"));\n// Визначення рекурсивної  функції обчислення n-го числа Фібоначчі\nvar fib = function (x)    //заголовок функції\n{ //початок тіла функції\n\tif (x<=2) \n\t{\n   \t\treturn  (1);        \n\t} \n\telse\n\t{\n\t\treturn (fib(x-1) + fib(x -2) );\n\t}\n}; //кінець тіла функції\n\nconsole.log(\\\" n   =  \\\" +  num );\nconsole.log(\\\" n – те число Фібоначі  =  \\\" + fib(num));\n/*_____________________________________________________________\n   n   =  5\n   n – те число Фібоначі  =  5\n   -----------------------------------------------------------------\n   n   =  7\n   n – те число Фібоначі  =  13  \n*/"
              }
            ]
          },
          {
            id: 5,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "Написати функцію визначення і друку периметра квадрату, параметром якої є ціле число, що характеризує довжину сторони квадрата.",
                  "Написати функцію визначення і друку площі прямокутника, параметром якої є два цілих числа, що характеризують довжини сторін прямокутника.",
                  "Написати функцію визначення і друку входження літери, що є першим аргументом функції, у рядок символів, який задається другим аргументом функції.",
                  "Написати функцію визначення і друку входження рядка символів, що є першим аргументом функції, у рядок символів, який задається другим аргументом функції, та використовує для цього фукцію із попереднього завдання.",
                  "Написати функцію, що задає обчислення ознаки парності цілого числа.",
                  "Написати функцію, що задає обчислення ознаки подільності націло на 3 цілого числа.",
                  "Написати функцію, що задає обчислення ознаки подільності націло на 4 цілого числа.",
                  "Написати функцію, що задає обчислення ознаки подільності націло на 5 цілого числа.",
                  "Напишіть програму, яка для цілого числа, що вводиться із клавіатури, визначає чи ділиться введене число на 2, 3, 4 і 5, використовуючи для цього написані функції із попередніх завдань та виводить на друк відповідне повідомлення.",
                  "Написати рекурсивну функцію визначення піднесення цілого числа, що є першим аргументом функції, у степінь, яка задається другим аргументом функції.",
                  "Напишіть програму, яка для послідовності N (значення вводиться із клавіатури) псевдовипадкових чисел менших 100 будує послідовність цих чисел піднесених до кубу (3-ї степені), використовуючи функцію піднесення до ступеня із попереднього завдання, та виводить їх на друк."
                ]
              },
              
            ]
          }
        ]
  },
  {
    id: 5,
    title: "Додаткові можливості та інструментарій",
    topics: [
      {
        id: 1,
        title: "Інструментарій розробок",
        content: [
          {
            type: "heading",
            text: "Інструментарій розробок"
          },
          {
            type: "paragraph",
            text: "Методологія проєктування складних комп'ютерних систем полягає в тому, що система (комп'ютерна програма, програмний модуль) частково або повністю повинна складатися з частин (підсистем), написаних раніше самим програмістом або іншими програмістами компонентів і/або частин іншої системи. Тому ці компоненти (підсистеми) повинні писатися в такому архітектурному стилі та так документуватися, щоб їх можна було б застосовуватися більш одного разу (якщо не в рамках одного проєкту, то хоча б різних)."
          },
          {
            type: "paragraph",
            text: "Повторне використання - основна методологія, яка застосовується для скорочення трудовитрат при розробці складних систем."
          },
          {
            type: "paragraph",
            text: "Найпоширеніший випадок організації та повторного використання коду - бібліотеки програм. Бібліотеки надають загальну досить універсальну функціональність, що покриває вибрану предметну область. Простими прикладами бібліотек спеціалізованих наборів функцій є бібліотека математичних функцій, бібліотека функцій для роботи з графікою, бібліотека для роботи з базами даних."
          },
          {
            type: "paragraph",
            text: "Розробники нової програми можуть використовувати існуючі бібліотеки для вирішення власних завдань і не «винаходити велосипеди»."
          },
          {
            type: "paragraph",
            text: "Програмний фреймворк (англ. software framework) — це готовий до використання комплекс програмних рішень, включаючи дизайн, логіку та базову функціональність системи або підсистеми. Відповідно — програмний фреймворк може містити в собі також допоміжні програми, деякі бібліотеки коду, скрипти та загалом все, що полегшує створення та поєднання різних компонентів великого програмного забезпечення чи швидке створення готового і не обов'язково об'ємного програмного продукту. Побудова кінцевого продукту відбувається, зазвичай, на базі єдиного API."
          },
          {
            type: "paragraph",
            text: "Застосунок, застосовна програма, прикладна програма (англ. application, application software, app) — користувацька комп'ютерна програма, що дає змогу вирішувати конкретні прикладні задачі користувача."
          },
          {
            type: "paragraph",
            text: "Застосунок у своїй роботі спирається на системне програмне забезпечення і використовує (застосовує) концепції, функціональність і можливості, закладені у середовище, де він виконується: операційної системи, мов програмування, бібліотек, архітектурних шаблонів тощо."
          },
          {
            type: "paragraph",
            text: "За останнім десятиліття з'явилося величезна кількість фреймворків: Spring, Ruby on Rails, Play, django. Для успішного використання фреймворків треба чітко розуміти, що це таке і навіщо воно потрібно розробникам. Фреймворк можна розглядати як набір програмних сутностей (таких як класи, об'єкти і компоненти), які допомагають будувати реюзабельну архітектуру для подібних застосунків. Для створення застосунку розробник розширює і налаштовує фреймворк, додаючи власну логіку."
          },
          {
            type: "paragraph",
            text: "Основною характеристикою фреймворка є інверсія управління. Зазвичай фреймворк грає головну роль і викликає код самого застосунка. Потік управління інвертується тут - фреймворк викликає додаток, а не навпаки. На схемі рисунку 2.17 зображена взаємодія між фреймворком, застосунком і бібліотекою. Досить часто фреймворк сам використовує бібліотеки."
          },
          {
            type: "image",
            src: "/images/image087.png",
            alt: "Рис. 2.17. Схема взаємодії фреймворку, бібліотеки і застосунку"
          },
          {
            type: "paragraph",
            text: "Насамперед, фреймворк допомагає розробнику підвищити продуктивність і якість коду за рахунок використання спеціалізованого інструментаря, наприклад для кодогенерації, або готові каркаси типових застосунків, або спеціалізовані засоби безпеки. По-друге, фреймворк допомагає стандартизувати роботу великої команди програмістів та виробити у програмістів цієї команди єдиний стиль програмування шляхом застосування загальноприйнятих рішень типових задач, кодстайлу і готових реалізацій, які містяться у фреймворку."
          },
          {
            type: "paragraph",
            text: "Вивчення нового фреймворку вимагає затрат значних зусиль і часу. На противагу вивченню бібліотеки, за якого програміст може знайомитися з її API в міру необхідності, опанування фреймворком вимагає повного розуміння його принципів до початку його використання."
          },
          {
            type: "paragraph",
            text: "Перші фреймворки були монолітними, тому що їх основною метою було забезпечити підтримку повного стека завдань розробки. Тут термін «монолітний» визначає побудову у вигляді єдиної сильно пов'язаної кодової бази. Але монолітні системи мають багато проблем. Наприклад, внесення змін в невелику частину фреймворка вимагало повторного тестування і випуску нової версії всього фреймворку. Тому з’явилися невеликі вузькоспеціалізовані фреймворки, наприклад для логування, кешування, роботи в базою даних."
          },
          {
            type: "paragraph",
            text: "Сучасні фреймворки мають слабо пов'язану архітектуру. Універсальні фреймворки подібні Spring перетворилися в набори слабо пов'язаних компонентів, які можуть бути використані окремо або замінені сторонніми рішеннями."
          },
          {
            type: "paragraph",
            text: "Спеціалізовані фреймворки (Sinatra, Express.js і Martini), взаємодіючи «за контрактом», роблять створений застосунок менш залежним від цього фреймворка. Самі по собі ці фреймворки дуже маленькі, але відкрита архітектура дозволяє легко розширювати їх до нескінченності, використовуючи сторонні рішення."
          },
          {
            type: "paragraph",
            text: "Фреймворк у всіх випадках використовує розумні значення за замовчуванням, дозволяючи змінити їх через конфігурацію. Це суттєво зменшує кількість рішень, які необхідно приймати розробникові самостійно."
          },
          {
            type: "paragraph",
            text: "Успішне використання фреймворка - це знаходження балансу між простотою і функціональністю. На протязі всієї розробки необхідно приймати рішення, керуючись перерахованими вище принципами."
          }
        ]
          },
          {
            id: 2,
            title: "Додаткові можливості",
            content: [
              {
                type: "heading",
                text: "Додаткові можливості"
              },
              {
                type: "subheading",
                text: "Екосистема JavaScript"
              },
              {
                type: "paragraph",
                text: "Екосистема JavaScript значно зросла. Давно минули ті часи, коли просто вставивши скрипт на вашому сайті можна було показувати та ховати елементи. Практично наразі, будь-який додаток, можна написати на JavaScript."
              },
              {
                type: "paragraph",
                text: "Серед розробок в яких активно використовують JavaScript виділяють: фронтенд, консольні додатки (CLI), настільні додатки (GUI), мобільні додатки, автоматизацію застосувань."
              },
              {
                type: "subheading",
                text: "Фронтенд розробка (веб-програмування)"
              },
              {
                type: "paragraph",
                text: "Протягом довгого часу, JavaScript використовується виключно для Document Object Model маніпуляції (примітивні операції з елементами на сторінці). Між браузерами була і залишається велика різниця, тому одні і ті самі функції можуть працювати по різному. Структура Document Object Model приведена на рисунку 2.18."
              },
              {
                type: "image",
                src: "/images/image088.png",
                alt: "Рис. 2.18. Структура DOM"
              },
              {
                type: "paragraph",
                text: "Об'єктна модель документа (англ. DOM) — специфікація прикладного програмного інтерфейсу для роботи зі структурованими документами (як правило, це документи XML). Визначається ця специфікація консорціумом W3C."
              },
              {
                type: "paragraph",
                text: "За парадигми об'єктно-орієнтованого програмування DOM визначає класи, методи та атрибути цих методів, що застосовуються для надання програмній системі доступу та динамічної модифікації структури, змісту та оформлення документа у вигляді дерева. Для усунення проблеми несумісних інтерфейсів роботи із HTML документами в інтерпретаторах JavaScript, вбудованих в веб-переглядачі, W3C узгодив та визначити низку стандартів, які отримали назву W3C Document Object Model (W3C DOM), що не залежать від платформи або мови програмування. DOM підходить для застосувань в програмах, які вимагають багаторазовий доступ до елементів документа в довільному порядку. В противному разі, для пришвидшення переробки та зменшення обсягів необхідної пам'яті рекомендується використовувати послідовну модель роботи зі структурованими документами, яку називають простим програмним інтерфейсом для роботи з XML (англ. Simple API for XML, SAX)."
              },
              {
                type: "paragraph",
                text: "З’явилися спеціалізовані програмні розробки обробки та аналізу DOM. Серед них виділяють бібліотеку Jquery. Вона зробила революцію, увівши уніфіковані методи для DOM маніпуляцій. JQuery стала однією з найпопулярніших бібліотек для фронтенд розробки на JavaScript. З ростом складності веб-сайтів і веб-додатків, існує необхідність у вирішенні складних питань (збереження стану, відображення даних, рендеринг і т.д.). Для вирішення цих задач з’явилися біблітотеки React.js та AngularJS. Наприклад Facebook працює за допомогою бібліотеки React.js"
              },
              {
                type: "subheading",
                text: "Застосунки командного рядка"
              },
              {
                type: "paragraph",
                text: "Інтерфейс командного рядка (англ. Command line interface, CLI) є різновидністю текстового інтерфейсу (англ. Character User Interface, CUI) між людиною і компом. У цьому випадку команди компу даються за допомоги їх вводу в основному з клавіатури у вигляді текстових стрічок (рис. 2.19). В UNIX-системах можливе використання «мишки»."
              },
              {
                type: "image",
                src: "/images/image089.png",
                alt: "Рис. 2.19. Command line interface"
              },
              {
                type: "paragraph",
                text: "Багато розробників покладаються в основному на CLI. Код деплоймента (розгортання програмного забезпечення), запуск сервера та інші завдання часто використовують командний рядок. Додатки CLI, написані з використанням Node.js, є середовищем з відкритим вихідним кодом, зорієнтовані на крос-платформне середовище виконання. Це дозволяє виконувати код JavaScript всюди через відповідний інтерпретатор від Google Chrome (не тільки в браузері, як раніше)."
              },
              {
                type: "paragraph",
                text: "Було б дуже погано, якщо потрібно було б писати всі функціональні можливості кожного додатка з нуля. NPM менеджер пакетів для модулів Node.js дозволяє легко встановлювати, підключати та розповсюджувати бібліотеки JavaScript."
              },
              {
                type: "paragraph",
                text: "Додаток CLI, також може бути упакованим у вигляді модуля Node.js і поширюється через NPM. Багато популярних бібліотек і інструментів мають CLI додатки для більш зручного використання."
              },
              {
                type: "subheading",
                text: "Розробка настільних додатків (GUI)"
              },
              {
                type: "paragraph",
                text: "Графічний інтерфейс користувача (англ. Graphical user interface, GUI) дозволяє користувачам взаємодіяти з електронними пристроями через графічні зображення та візуальні вказівки. У цьому випадку виконання дій — це безпосередня маніпуляція з графічними елементами. На рисунку 2.20 зображено графічний інтерфейс у Windows."
              },
              {
                type: "image",
                src: "/images/image090.png",
                alt: "Рис. 2.20. Графічний інтерфейс користувача у Windows"
              },
              {
                type: "paragraph",
                text: "Застосунки в основному мають тенденцію до переміщення в Інтернет або на мобільні пристрої. Тим не менш, настільні додатки мають доступ до функцій, які недоступні для веб-додатків."
              },
              {
                type: "paragraph",
                text: "Найбільшою перевагою написання додатків GUI на JavaScript є їх крос-платформність. Забезпечивши хорошу структуру проекту, можна використовувати багато спільного коду між веб і настільним додатком. Це, у свою чергу, призводить до здешевлення розробки."
              },
              {
                type: "paragraph",
                text: "Відомі додатки зроблені з NW.js: Game Dev Tycoon, GitHub Atom, WhatsApp Desktop, Facebook Messenger Desktop, Microsoft Visual Studio Code."
              },
              {
                type: "subheading",
                text: "Мобільні застосунки"
              },
              {
                type: "paragraph",
                text: "Ринок мобільних пристроїв розвивається дуже швидко. JavaScript екосистема надає можливість розробляти крос-платформні (IOS, Android і Windows Phone) застосунки. Наприклад, PhoneGap використовує обгортку навколо браузера HTML/JS (рис. 2.21.) і забезпечує доступ до інших пристроїв (камера, різні датчики, і т.п.)."
              },
              {
                type: "image",
                src: "/images/image091.png", 
                alt: "Рис. 2.21. PhoneGap"
              },
              {
                type: "subheading",
                text: "Розробка бекенду"
              },
              {
                type: "paragraph",
                text: "Node.js також є основною рушійною силою в серверній розробці на JavaScript."
              },
              {
                type: "paragraph",
                text: "Головною перевагою Node.js у порівнянні з іншими технологіями є не блокуюча модель введення/виводу. Ця модель надає можливість Node.js обробляти велику кількість запитів у режимі реального часу шляхом обробки всіх одночасних запитів в одному потоці. Останнє значно зменшує необхідні системні ресурси і дозволяє відмінно масштабуватись. Типовим прикладом цих переваг є чат додатки."
              },
              {
                type: "subheading",
                text: "Автоматизація застосувань"
              },
              {
                type: "paragraph",
                text: "Мова Javascript знайшла себе також, як мова автоматизації. Оскільки існує багато відкритих інтерпретаторів мови, її почали використовувати для написання скриптів для інших застосувань."
              },
              {
                type: "paragraph",
                text: "Наприклад, мова JavaScript використовується для написання скриптів для всіх продуктів Adobe (Photoshop, Illustrator, InDesign). За допомогою мови JavaScript можна виконувати ті ж самі дії, що і за допомогою графічного інтерфейсу."
              }
            ]
          },
          {
            id: 3,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "1. Визначте методологію проєктування складних комп'ютерних систем.",
                  "2. Уточніть використання терміну «бібліотека програм».",
                  "3. Що називається фреймворком у програмуванні?",
                  "4. Дайте визначення поняття «застосунок» у програмуванні.",
                  "5. Проведіть порівняння монолітних і спеціалізованих фреймворків.",
                  "6. Охарактеризуйте сучасну екосистему JavaScript.",
                  "7. Приведіть визначення об'єктної моделі документа.",
                  "8. Уточніть поняття «інтерфейс командного рядка».",
                  "9. Що надає графічний інтерфейс користувача?",
                  "10. Приведіть приклади мобільних застосунків."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 6,
        title: "JavaScript – особливий представник сімейства клієнтських скриптів",
        topics: [
          {
            id: 1,
            title: "Скрипти",
            content: [
              {
                type: "heading",
                text: "Скрипти"
              },
              {
                type: "paragraph",
                text: "Скрипт - це програма або програмний файл сценарію, що авто-матизують деяку задачу, яку користувач робив би вручну, використо-вуючи інтерфейс програми. Скрипти пишуться   скриптовими мовами  AngelScript, Perl, Python, PHP, JavaScript, JScript і інші. Скриптова мо-ва – високорівневий опис дій, які має виконати система, а  сценарієм тоді можна  назвати спеціальну програму на цій мові, яка описує вка-зану взаємодію через готові програмні компоненти. "
              },
              {
                type: "paragraph",
                text: "Сфера застосування скриптів величезна. Наприклад,  за їх допо-моги користувач отримує можливість звертатися до баз даних, спосте-рігати статистику відвідувань (лічильники відвідуваності), здійснювати записи в гостьових книгах, залишати коментарі до вподобаних статей. На скриптах засновані всі   форуми. Скрипти допомагають робити  ди-намічне відображення веб-сайту,  організувати зміни частини сайту без перевантаження всієї сторінки і багато багато іншого."
              }
            ]
          },
          {
            id: 2,
            title: "Порівняння JavaScript з іншими мовами програмування",
            content: [
              {
                type: "heading",
                text: "Порівняння JavaScript з іншими мовами програмування"
              },
              {
                type: "paragraph",
                text: "Як ми вже зазначали не раз, JavaScript(JS) є динамічною мовою програмування, яка використовується для реалізації клієнтських скриптів для взаємодії з користувачем та динамічної зміни вмісту документа, що відображається. JS також використовується для написання серверних скриптів, ігор та створення настільних та мобільних додатків."
              },
              {
                type: "paragraph",
                text: "JS має багато властивостей об’єктно-орієнтованої мови, але завдяки концепції прототипів вона все ж таки відрізняється від традиційних мов ООП."
              },
              {
                type: "paragraph",
                text: "Прототипування програмного забезпечення (від англ. Prototyping) є специфічним етапом розробки програмного забезпечення. Тут уточнюється процес створення прототипу програми – макета програми (чорновий варіант пробної версії) – з наголосом на перевірку придатності пропонованих для застосування концепцій, архітектурних і/або технологічних рішень, а також для представлення програми замовнику на ранніх стадіях процесу розробки."
              },
              {
                type: "paragraph",
                text: "Наприклад, Java заснована на класах: кожен клас має свої об’єкти та екземпляри, успадкування відбувається по всій ієрархії класів, класи не можуть мати динамічно доданих властивостей та методів. В JS відсутнє поняття класу (як в Java), а успадкування відбувається шляхом клонування існуючого примірника об’єкта – прототипу. Оскільки поняття класу в JS, як такого немає, то за створення об’єктів відповідають функції-конструктори. Також такі конструктори дозволяють довизначати та перевизначати методи та властивості об’єктів. Тому в JS властивості та методи можуть додаватися до об’єкта динамічно. Візьмемо, наприклад, таку функцію:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function myConstructor(name, email){\n\tthis.blog = \"http://uk.wikipedia.org\";\n\tthis.name = name;\n\tthis.email = email;\n\tthis.getInfo = function(){\n\t\talert(\"I'm \" + this.name + \". I read \" + this.blog + \". My email   is: \" + this.email + \".\");\n\t};\n}"
              },
              {
                type: "paragraph",
                text: "Створимо об’єкт за допомогою цієї функції-конструктора:"
              },
              {
                type: "code",
                code: "var obj = new myConstructor(\"Andriy\", \"sword6633@gmail.com\");"
              },
              {
                type: "paragraph",
                text: "Запустивши:"
              },
              {
                type: "code",
                code: "obj.getInfo();"
              },
              {
                type: "paragraph",
                text: "Отримаємо друк:"
              },
              {
                type: "code",
                language: "console",
                code: "I'm Andriy. I read http://uk.wikipedia.org. My email is: sword6633@gmail.com."
              },
              {
                type: "paragraph",
                text: "Прототипом цього об’єкта буде:"
              },
              {
                type: "code",
                code: "obj.__proto__; // [object Object]\nobj instanceof myConstructor; //true ."
              },
              {
                type: "paragraph",
                text: "Ми можемо створити новий об’єкт, який буде нащадком obj:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var bar = {mainName: “Hotel”};\nbar.__proto__ = obj;\nbar.getInfo = function () { alert(\"Hello, I'm \" + this.mainName + \".\"); };"
              },
              {
                type: "paragraph",
                text: "Отже, ми створили новий об’єкт, який успадкував характеристики свого прототипу (obj) й динамічно змінили одну функцію цього об’єкта."
              },
              {
                type: "paragraph",
                text: "Окрім цього, JS має властивості, притаманні функціональним мовам – вже згадані функції як об’єкти першого рівня, об’єкти як списки та інші. В JS наявна інтроспекція – можливість визначити тип і структуру об’єкта під час виконання програми."
              },
              {
                type: "paragraph",
                text: "На відміну від багатьох мов програмування, JS не бачить різниці між цілими числами та числами з плаваючою точкою. Всі числа в JS представлені у вигляді значення з плаваючою тотою."
              },
              {
                type: "heading",
                text: "Прототипування"
              },
              {
                type: "subheading",
                text: "Прототип об'єкта"
              },
              {
                type: "paragraph",
                text: "Більш повну і новішу інформацію по цій темі можна знайти на сторінці https://learn.javascript.ru/prototype-inheritance. Матеріали сторінки лягли в основу для цього викладення. Як ми зазначали вище, для реалізації наслідування об'єкти в JavaScript можна організувати в ланцюжки так, щоб властивість, що не знайдена в одному об'єкті із цього ланцюжка, автоматично шукалася б в іншому."
              },
              {
                type: "paragraph",
                text: "Ланцюжок утворюється за допомоги спеціального посилання **__proto__** на інший об'єкт. У випадку невдалої спроби читання властивості з базового об’єкта, тобто, якщо властивість відсутня у цьому об'єкті, вона шукається в об'єкті-прототипі, на який вказує посилання **__proto__**. Наприклад:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var children = {\n\tread : true\n};\nvar andrij = {\n\tplay : true \n};\nandrij.__proto__ = children;\n// в andrij можна знайти обидві властивості\nalert ( andrij . play ); // true\nalert ( andrij . read ); // true"
              },
              {
                type: "paragraph",
                text: "Перше виведення властивості в **alert** тут працює очевидним чином - він виводить властивість **play** об'єкта **andrij**. За другого виведення шукається властивість **read** в об'єкті **andrij**. Там вона відсутня. Тому продовжується пошук в **andrij.__proto__**, тобто в прототипі **children**. У цьому випадку ще кажуть, що об'єкт **andrij** «прототипно успадковує» властивість від **children**."
              },
              {
                type: "paragraph",
                text: "У об'єкта, який є **__proto__**, може бути свій **__proto__**, у того - свій, і так далі. При цьому властивості будуть шукатися по ланцюжку."
              },
              {
                type: "paragraph",
                text: "Звернемо увагу - прототип використовується виключно при читанні. Запис значення, наприклад:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var children = {\n\tread : true\n};\nvar andrij = {\n\ttoy : true\n};\nandrij.__proto__ = children;\nalert ( andrij . toy ); // true\nalert ( andrij . read ); // true\nandrij . read = \"book\";\n// andrij; /*в andrij обидві властивості будуть мати значення {toy: true, read: \"book\"} */"
              },
              {
                type: "paragraph",
                text: "Якщо після оформлення прототипування об’єктів, у об’єкті, що використовує наслідування, записати цю ж властивість, тоді він перестає брати її у прототипу, а бере вже з самого об'єкта:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var children = {\n\tread : true,\n\twrite : true\n};\nvar andrij = {\n\ttoy : true,\n\tread : false\n};\nandrij.__proto__ = children ;\n// в andrij можна знайти обидві властивості, але andrij . read буде рівне false\n// andrij; /*{toy: true, read: false}*/"
              },
              {
                type: "paragraph",
                text: "Отже, прототип можна вважати «резервним сховищем властивостей і методів» об'єкта, що автоматично використовується при пошуку. У специфікації ECMAScript властивість **_proto_** позначено як **[[Prototype]]**. Зверніть увагу на подвійні дужки. Вони тут використані для позначення відмінності від властивості з назвою **prototype**."
              },
              {
                type: "paragraph",
                text: "Для отримання інформації про всі властивості об’єкта, включаючи і ті, які знаходяться в його прототипах, можна скористатися циклом **for..in**. Наприклад:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var children = {\n\tread : true,\n\twrite : true\n};\nvar andrij = {\n\ttoy : true,\n\tplay : false\n};\nandrij.__proto__ = children ;\n// надрукуємо всі властивості об'єкта andrij\nfor (var key in andrij) {\n\tconsole.log (key + \" = \" + andrij[key] );  \n};\n// toy = true\n// play = false\n// read = true\n// write = true\n// undefined"
              },
              {
                type: "paragraph",
                text: "Для визначення властивостей самого об'єкта, які знаходяться в ньому, а не в прототипі, використовують метод **obj.hasOwnProperty(name)**. Він повертає **true**, якщо властивість **name** належить самому об'єкту **obj**, інакше **false**. Наприклад:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var children = {\n\tread : true,\n\twrite : true\n};\nvar andrij = {\n\ttoy : true,\n\tplay : false\n};\nandrij.__proto__ = children ;\n// надрукуємо власні властивості об'єкта andrij\nfor (var key in andrij) {\n\tif ( ! andrij . hasOwnProperty ( key )) \n\t\tcontinue ; // пропустити \" НЕ свої \" властивості\n\tconsole.log (key + \" = \" + andrij[key] );  \n};\n// toy = true\n// play = false\n// undefined"
              },
              {
                type: "paragraph",
                text: "Іноді потрібно відмовитися від прототипу. Об'єкт, що створюється за допомогою **Object.create(null)** не має прототипу, а значить в ньому немає зайвих властивостей."
              },
              {
                type: "paragraph",
                text: "Метод **Object.setPrototypeOf(obj,proto)** встановлює **obj._proto_=proto** (крім IE10-)."
              },
              {
                type: "paragraph",
                text: "Використання **Object.create(proto, descriptors)** дозволяє створити порожній об'єкт з **_proto_**, рівним першому аргументу (крім IE8-), другий необов'язковий аргумент може містити дескриптори властивостей."
              },
              {
                type: "subheading",
                text: "Вбудовані прототипи"
              },
              {
                type: "paragraph",
                text: "Всі вбудовані функції-конструктори мови JavaScript використовують властивість «**prototype**»."
              },
              {
                type: "paragraph",
                text: "Розглянемо об'єкт:"
              },
              {
                type: "code",
                code: "var obj = {};\nalert ( obj ); // \"[object Object]\"?"
              },
              {
                type: "paragraph",
                text: "Тут рядок \"**[object Object]**\" генерує вбудований метод **toString**. Подивимося, де він береться."
              },
              {
                type: "paragraph",
                text: "Пригадаємо, що запис **obj = {}** є короткою нотацією запису **obj = new Object()**, де **Object** - вбудована функція-конструктор для об'єктів з власною властивістю **prototype**, яка посилається на глобальний об'єкт з методом **toString** і багатьма іншими. За виклику **new Object()** властивість **[[Prototype]]** цього об'єкта встановлюється на **Object.prototype** за правилами, які ми обговорювали в попередньому розділі, і коли викликається **obj.toString()**, метод береться з **Object.prototype**."
              },
              {
                type: "paragraph",
                text: "Аналогічно, вбудовані об'єкти **Array, Date, Function** і інші, також зберігають свої методи в прототипах. Згідно зі специфікацією, нагорі ієрархії вбудованих прототипів знаходиться **Object.prototype**. Тому іноді кажуть, що «все успадковується від об'єктів»."
              },
              {
                type: "paragraph",
                text: "А що ж відбувається з рядками, числами і булевими значеннями? Адже ж, вони не об'єкти. Та при спробі отримати доступ до їх властивостей, створюється тимчасовий об'єкт-обгортка з використанням вбудованих конструкторів **String, Number** і **Boolean**, який надасть методи і після цього зникне. Ці об'єкти створюються невидимо. Методи цих об'єктів також знаходяться в прототипах, доступних як **String.prototype, Number.prototype** і **Boolean.prototype**."
              },
              {
                type: "paragraph",
                text: "Спеціальні значення **null** і **undefined** особливі. У них немає об'єктів-обгорток, так що методи і властивості їм недоступні. Також у них немає відповідних прототипів."
              },
              {
                type: "paragraph",
                text: "JS працює з числами, використовуючи арифметичні оператори та спеціальні символи, що надає мова [11,12]:"
              },
              {
                type: "list",
                items: [
                  "**Number.POSITIVE_INFINITY** // Нескінченність,",
                  "**Number.NEGATIVE_INFINITY** // Від'ємна нескінченність,",
                  "**Number.MIN_VALUE/2** // приблизно 0,",
                  "**Number.NaN** // NaN (наприклад при 0/0)."
                ]
              },
              {
                type: "paragraph",
                text: "Число **NaN** в JS має незвичайну особливість: його не можна порівнювати. Наприклад, не можна написати **x == NaN**, проте запис **x != x** може бути істинним тоді і тільки тоді, коли **x = NaN**."
              },
              {
                type: "paragraph",
                text: "Дуже цікавим явищем в JS є також позитивний і негативний нулі. Хоча вони й нічим не відрізняються один від одного, та при діленні на нуль все ж таки різниця є: **1/0 = Infinity**, а **1/-0 = -Infinity**."
              },
              {
                type: "subheading",
                text: "Функції та методи:"
              },
              {
                type: "list",
                items: [
                  "**isFinite(х), isNaN(х)** - повертають true тільки тоді, коли аргументом першої є звичайне число, а для другої – NaN, Infinity, -Infinity;",
                  "перетворення рядка в число: **parseInt('24px') // 24**, **parseFloat('12.3.') //12.3**;",
                  "перетворення числа у зазначену систему числення: **4..toString(2) //100**;",
                  "округлення числа до зазначеної точності (повернення результату у вигляді рядка): **4..toFixed(2) //4.00**;"
                ]
              },
              {
                type: "paragraph",
                text: "Дуже цікавим є представлення десяткових чисел. Наприклад, число **0.1** не завжди подається однозначно:"
              },
              {
                type: "code",
                code: "var x = 0.3-0.2;\nvar y = 0.2-0.1;"
              },
              {
                type: "paragraph",
                text: "Здається, ніби **x == y** (адже вони обоє мають дорівнювати **0.1**). Проте:"
              },
              {
                type: "code",
                code: "x==y //false,\nx==0.1 //false,\ny==0.1 //true."
              },
              {
                type: "paragraph",
                text: "Насправді **x** буде рівне **0.09999999999999998**. Подумайте, чому."
              },
              {
                type: "heading",
                text: "Об’єкт"
              },
              {
                type: "paragraph",
                text: "Об’єкт в JS являє собою невпорядкований набір властивостей та методів. Крім власних властивостей, він також успадковує властивості іншого об’єкта, який є прототипом даного. Саме на прототипах і побудований механізм успадкування в JS. Об’єкти є динамічними – їх властивості можна додавати й видаляти вже під час виконання програми."
              },
              {
                type: "paragraph",
                text: "Об’єкти присвоюються та передаються за посиланнями. Тобто, якщо ми одному об’єкту присвоюємо інший, то ми не створимо копії, а дві змінні будуть вказувати на один і той же об’єкт. Наприклад, запустивши на виконання таку послідовність команд:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var person = {name:\"Andriy\", age:19}; // у змінній посилання\nvar person2 = person; // скопіювали посилання\nalert(person2.name);  // Andriy"
              },
              {
                type: "paragraph",
                text: "отримаємо виведення ім’я Андрій."
              },
              {
                type: "paragraph",
                text: "Властивість об’єкта складається з імені та значення. Ім’я може бути будь-яким (навіть порожнім), але не може бути двох однакових імен в одному об’єкті."
              },
              {
                type: "paragraph",
                text: "Прототип об’єкта є посиланням на інший об’єкт, з якого успадковані властивості."
              },
              {
                type: "paragraph",
                text: "Існують кілька груп об’єктів:"
              },
              {
                type: "list",
                items: [
                  "1. Власні об’єкти (arrays, functions, dates),",
                  "2. Об’єкти середовища (визначаються приймаючим середовищем, наприклад веб-браузером, HTML-сторінки).",
                  "3. Об’єкти, створені користувачем."
                ]
              },
              {
                type: "paragraph",
                text: "Об’єкт можна створити двома способами:"
              },
              {
                type: "list",
                items: [
                  "1. простий спосіб (**var point = {x:2, y:2};**).",
                  "2. за допомогою **new** (**var person = new Object();**)."
                ]
              },
              {
                type: "paragraph",
                text: "Властивість можна додати динамічно: **person.surname = “Dyhdalo”**."
              },
              {
                type: "paragraph",
                text: "Доступитися до властивості об’єкта можна по-різному:"
              },
              {
                type: "code",
                code: "person['name']; // \"Andriy\"\nvar key = 'name';  person[key]; // \"Andriy\"\nperson.name; // \"Andriy\""
              },
              {
                type: "paragraph",
                text: "Існує ще третій спосіб створення об’єкта. Кожен об’єкт має прототип – клас, від якого він наслідує певні властивості. Наприклад, **Object.prototype**, який є одним з небагатьох об’єктів, що не мають прототипу. Всі вбудовані конструктори-функції та функції, створені користувачем, мають прототип, що успадковує властивості від **Object.prototype**. Це дещо подібне до Java – в ній всі класи успадковуються від класу **Object**."
              },
              {
                type: "paragraph",
                text: "Третій спосіб створення об’єкта використовує функцію **create()**, першим аргументом якої є прототип, від якого буде успадковувати властивості даний об’єкт. Другий аргумент не обов’язковий – він описує властивості нового об’єкта:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var v = Object.create({x:1, y:1});  // v успадковує властивості x,y\nvar v1 = Object.create(null);      // v1 не успадковує нічого \nvar v2 = Object.create(Object.prototype);// аналог var v2  =   new Object();"
              },
              {
                type: "paragraph",
                text: "Сам об’єкт не створюється так, як в інших мовах програмування, адже в JS відсутня концепція класів. JS використовує функції-конструктори, які можна назвати альтернативою класам. Тобто, під час створення об’єкта (наприклад, вищенаведений person) він отримує властивості, визначені в конструкторі."
              },
              {
                type: "paragraph",
                text: "Отже, функції-конструктори – це заміна класам в JS. Робота з ними аналогічна роботі з будь-якою іншою функцією, проте оголошений в ній код дозволяє створити нові об’єкти."
              },
              {
                type: "paragraph",
                text: "Розглянемо приклад конструктора та його використання:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function myConstructor(name, email){\n\tthis.blog = \"RubyDev.ru\";\n\tthis.name = name;\n\tthis.email = email;\n\tthis.getInfo = function (){\n\t\talert(\"I'm \" + this.name + \". I read \" + this.blog + \". My email is: \" + this.email + \".\");\n\t};\n}\nvar obj = new myConstructor(\"Barak\",\"black.president@whitehouse.gov\");\nobj.getInfo();\n//I'm Barak. I read RubyDev.ru. My email is: black.president@whitehouse.gov.\nmyConstructor.getInfo(); /* Error: myConstructor.getInfo is not a function*/\nalert(myConstructor.prototype); //[object Object]\nalert(obj.__proto__); // [object Object] тільки в Firefox.\nalert(obj.constructor); // function myConstructor ...\nalert(typeof obj); //object\nalert(obj instanceof myConstructor); //true\nalert(obj.constructor.name); /*myConstructor - реально корисна информація по типу об’єкта. */\nvar obj1 = new myConstructor(\"John\", \"elt.john@stars.com\");\nvar obj2 = new myConstructor(\"Brad\", \"brad.pitt@stars.com\");\nobj1.getInfo(); /*I'm John. I read RubyDev.ru. My email is: elt.john@stars.com. */\nobj2.getInfo(); /*I'm Brad. I read RubyDev.ru. My email is: brad.pitt@stars.com. */\nobj1.getInfo = function () { alert(\"Hello, I'm \" + this.name + \".\"); };\nobj1.getInfo(); /*Hello, I'm John. - зараз getInfo - властивість са-мого об’єкта, а не його прототипа.*/\nmyConstructor.prototype.getName = function () { alert(this.name); };\nmyConstructor.prototype.getInfo = function () { alert(this.email); };\nobj1.getName(); //John\nobj2.getName(); //Brad\nobj1.getInfo();  //Hello, I'm John.\nobj2.getInfo();  /*I'm Brad. I read RubyDev.ru. My email is: brad.pitt@stars.com.*/\nobj1.getName = function () { alert(\"My name is Legion: for we are many.\"); };\nobj1.getName(); //My name is Legion: for we are many."
              },
              {
                type: "paragraph",
                text: "Посилання **this** у прикладі функції покликається на створюваний об’єкт. Помилка «**myConstructor.getInfo is not a function**» виникла тому, що метод **getInfo()** оголошений не для самого конструктора, а для об’єктів, які він породив. За необхідності, можна додати в конструктор і його власні властивості:"
              },
              {
                type: "code",
                language: "javascript",
                code: "myConstructor.getDefaultInfo = obj.getInfo;\nmyConstructor.getDefaultInfo();/* I'm myConstructor. I read undefined. My email is: undefined. */"
              },
              {
                type: "paragraph",
                text: "Дістати інформацію про прототип створеного об’єкта можна за допомогою метода **prototype** або **__proto__** (тільки для Firefox). Властивість **constructor** об'єкта повертає функцію – конструктор об'єкта. Насправді ж дана властивість належить не самому об’єкту, а його прототипу. Оператор **typeof** повертає тип об’єкта, а **instanceof** - true або false відповідно якщо об'єкт породжений відповідним конструктором чи ні. Ця властивість (**instanceof**) є дуже важливою – вона використовується, коли необхідно перевірити передані у функцію дані на приналежність їх певному, необхідному типу."
              },
              {
                type: "paragraph",
                text: "Конструктор також дозволяє доприсвоювати методи прототипу, а через нього і методи породжуваних об’єктів. Тобто, створюючи об’єкт за допомогою конструктора, ми визначаємо для нього властивості, притаманні прототипу. Потім можна змінити ці властивості для кожного окремого об’єкта ( у прикладі – змінено властивість **getInfo()** для **obj1**). Використовуючи властивість **prototype**, можна допуститися до прототипу й визначити для нього нові властивості. Якщо такої нової властивості немає в об’єктах прототипу, то вони звертаються до свого прототипу, який цю властивість має (властивість **getName**). Властивість **getInfo** спочатку вже належала об’єктам, тому вони не звертаються до прототипу, а повертають свій власний метод **getInfo()**."
              },
              {
                type: "paragraph",
                text: "Девід Фланаган назвав таку властивість звертатися до свого прототипу у пошуку методів, яких у нього немає, «**chain or linked list from which properties are inherited**». Для успадкування автор використав функцію **inherit()**."
              },
              {
                type: "paragraph",
                text: "Девід Фланаган також згадує про гетери і сетери в JS. Гетери потрібні для того, щоб отримати певну властивість об’єкта, а сетери – встановити значення властивості (для сетерів ігнорується «return value»). Вони потрібні для того (за прикладом автора), щоб не писати кілька разів слово **function** до функцій з однаковими іменами:"
              },
              {
                type: "code",
                language: "javascript",
                code: "get r() { return Math.sqrt(this.x*this.x + this.y*this.y); }\nset r(newvalue) {\n\tvar oldvalue = Math.sqrt(this.x*this.x + this.y*this.y);\n\tvar ratio = newvalue/oldvalue;\n\tthis.x *= ratio;\n\tthis.y *= ratio;\n}"
              },
              {
                type: "paragraph",
                text: "У цьому випадку в нас є дві функції, які описують одну і ж ту властивість. Тільки одна відповідає лише за повернення властивості, а друга – тільки за її редагування."
              },
              {
                type: "subheading",
                text: "Фабрика об’єктів"
              },
              {
                type: "paragraph",
                text: "На закінчення можна згадати ще одну цікаву рису JS – фабрику об’єктів:"
              },
              {
                type: "code",
                language: "javascript",
                code: "function objFactory(name, lastname){\n\treturn {\n\t\tname : name,\n\t\tlastName : lastname,\n\t\tconstructor : objFactory\n\t};\n};\nvar obj1 = objFactory(\"Андрій\", \"Дигдало\");\nalert(obj1.name); //Андрій"
              },
              {
                type: "paragraph",
                text: "Масиви в JS майже нічим не відрізняються від масивів інших мов програмування. Проте, дуже важливим в JS є те, що в масив можна записувати елементи будь-якого типу."
              },
              {
                type: "code",
                code: "var mix = ['Андрій', 92, { name: 'Дигдало', age: 19 }, true];"
              },
              {
                type: "paragraph",
                text: "Кубенський в своїх презентаціях описує такі особливі методи для масивів:"
              },
              {
                type: "list",
                items: [
                  "**split(separator)** – перетворює рядок у масив, розбивши його на підрядки по роздільнику **separator**;",
                  "**join(separator)** – склеює масив у рядок;",
                  "**splice(index, devareCount, [elem1, ..., elemN])** - видалити **devareCount** елементів, починаючи з позиції **index**, а потім вставити **elem1, ..., elemN** на їх місце;",
                  "**sort(fn)** – сортує масив за вказаним порядком;",
                  "**reverse** – змінює порядок елементів у масиві на зворотній."
                ]
              },
              {
                type: "paragraph",
                text: "Функції в JS – це не тільки іменована послідовність операторів, а й значення, які можна присвоювати, передавати, створювати будь-де у коді. Існують три способи оголошення функцій: **Function Declaration** – функція, оголошена в основному потоці коду; **Function Expression** – функція, створена як частина виразу; «**На місці**» - функція оголошується і викликається одразу ж."
              },
              {
                type: "paragraph",
                text: "Відмінності способів оголошення функцій приводяться в таблиці 2.3."
              },
              {
                type: "image",
                src: "/images/imageTable23.png",
                alt: "Таблиця 2.3"
              },
              {
                type: "paragraph",
                text: "Відомо, що усі змінні всередині функції – це властивості об’єкта **LexicalEnvironment**. Під час створення функція отримує посилання на об’єкт зі змінними, в контексті якого була створена. Пошук змінних спочатку здійснюється у поточному об’єкті **LexicalEnvironment**, а потім за посиланням (рис.2.22)."
              },
              {
                type: "image",
                src: "/images/imageVarSearch.png",
                alt: "Рис. 2.22. Пошук змінних"
              },
              {
                type: "paragraph",
                text: "Такий поділ називають **замиканням функції** – це сама функція плюс весь ланцюжок **LexicalEnvironment**, який при цьому утворюється."
              }
            ]
          },
          {
            id: 3,
            title: "Характеристика серверного JavaScript",
            content: [
              {
                type: "heading",
                text: "Характеристика серверного JavaScript"
              },
              {
                type: "paragraph",
                text: "Як ми вже знаємо, клієнтський JS з’являється в таких випадках: всередині тега `<script>`; під час включення операторів як обробників подій в тегах HTML; значення HTML-атрибутів тощо. В той час серверний JS з’являється в наступних ситуаціях: оператори та функції всередині тега `<server>`; під час специфікування файлу як JS-вихідника для компілятора додатків JS; під час специфікування певного виразу JS як значення або імені HTML-атрибуту."
              },
              {
                type: "paragraph",
                text: "Серверний JS містить такі глобальні функції: **write** - (додає оператори до сторінки, яка вже генерується); **flush** (очищає буфер виводу); **redirect** (перенаправляє клієнта по певному URL); **addClient** (приєднує клієнтську інформацію до URL); **addResponseHeader** (додає нову інформацію в «шапку» відповіді, що надсилається клієнту); **debug** (виводить значення виразів у вікні трасування) та інші."
              },
              {
                type: "paragraph",
                text: "Також слід згадати об’єкти та класи, оскільки крім загальноприйнятих об’єктів клієнтського JS, серверний JS має такі: **Connection**– одиничне з’єднання з базою даних; **Cursor** – курсор бази даних; **Resultset** – інформація, яка повертається збереженою процедурою бази даних; **File** – надає доступ до файлової системи сервера; **SendMail** – відправка електронної пошти з вашого додатку JS. **database** – з’єднання з базою даних; **client** – дозволяє зберігати інформацію про пару клієнт-додаток довше, ніж протягом одного HTTP-запиту; **request** – інкапсулює інформацію про окремий HTTP-запит; **server** – інкапсулює загальну інформацію про сервер, яка зберігається, поки сервер не зупиниться."
              },
              {
                type: "paragraph",
                text: "На відміну від сторінок з чисто клієнтським JS, сторінки, що використовують серверний JS, компілюються в байт-кодові виконувані файли. Ці файли запускаються на виконання веб-сервером."
              },
              {
                type: "paragraph",
                text: "Отже, створення таких файлів виконання (рис 2.23) передбачає процес з двох етапів:"
              },
              {
                type: "list",
                items: [
                  "1. Створення HTML-сторінки і файлів .js, після чого компілятор додатків JS (JavaScript application compiler) компілює ці файли в єдиний блок виконання;",
                  "2. Клієнтський браузер робить запит на дану сторінку, машина виконання обробляє всі знайдені на сторінці оператори серверного JS, а потім надсилає остаточний варіант сторінки мережею клієнту, який вже виконує клієнтський JS."
                ]
              },
              {
                type: "image",
                src: "/images/imageCreate.png",
                alt: "Рис. 2.23. Створення файлів виконання"
              },
              {
                type: "paragraph",
                text: "Проте, щоб запускати виконувані файли на сервері, потрібно підключити машину виконання JS у Server Manager. Також, щоб використовувати бібліотеки, такі як LiveWire (доступ до баз даних, розширює базову функціональність серверного скрипта), потрібно підключити серверний JS до підключення Java, використовуючи меню програм Administration Server. Більше того, потрібна віртуальна машина Java (JVM), адже будь-який Java-додаток, запущений на сервері, використовує цю машину. JVM була доопрацьована для того, щоб дати додаткам JS можливість отримувати доступ до Java-класів через використання LiveConnect-функціональності JS.."
              },
              {
                type: "paragraph",
                text: "Отже, якщо не підключити середовище додатків JS, наведеним вище чином, то виконувані файли, що використовують службу LiveWire Database Service, працювати не будуть. А функціональність чистого серверного JS настільки бідна, що вона й не набула широкої функціональності. Навіть використовуючи бібліотеки LiveWire, JS не може зрівнятися у функціональності з чисто серверною мовою програмування PHP, яка була створена саме з такою метою (в той час як JS був створений для взаємодії з браузером/клієнтом)."
              },
              {
                type: "paragraph",
                text: "Великим недоліком JS є і те, що він не має функції length для всіх об’єктів (хіба що для масивів), на відміну від PHP, яка має таку функцію."
              },
              {
                type: "paragraph",
                text: "Хоча PHP і набагато перевершує JS завдяки своїй підтримці великої кількості технологій для програмування на стороні сервера, JS все-таки має аналог до цієї серверної мови – Node.js. Node.js – це програмна платформа, яка перетворює JS з вузькоспеціалізованої мови в мову загального призначення."
              },
              {
                type: "paragraph",
                text: "Таким чином, хоч PHP і є фаворитом серед серверних мов програмування завдяки своїй функціональності, семантиці та продуктивності, JS все-таки надає нам платформу, яка аналогічна PHP і може виконувати ті ж завдання. Проте, JS краще все-таки використовувати як клієнтський скрипт, для чого він і був створений. А серверний JS – це вже як «гібрид» - хоч він і чудово справляється з серверними задачами, краще залишити їх для чисто серверних мов програмування, які мають в цій сфері більше досвіду, інструментів та технологій."
              }
            ]
          },
          {
            id: 4,
            title: "Висновки",
            content: [
              {
                type: "heading",
                text: "Висновки"
              },
              {
                type: "paragraph",
                text: "Аналізуючи мову JS, її переваги та недоліки, можна назвати такі основні області застосування мови, як представника клієнтських скриптів:"
              },
              {
                type: "list",
                items: [
                  "1. Динамічне створення документа HTML.",
                  "2. Перевірка достовірності полів форм перед передачею їх на сервер.",
                  "3. Виведення повідомлення користувачу у діалогових вікнах.",
                  "4. Локальне опрацювання форм, введення інформації користувачем.",
                  "5. Використовуючи об’єкт Event та модель подій Drag&Drop, реагувати на дії користувача.",
                  "6. Об’єкт Date – можливість створення інтерактивних годинника та календаря.",
                  "7. Надання користувачу можливості вибору операцій, що будуть оброблятися браузером."
                ]
              },
              {
                type: "paragraph",
                text: "Можна з впевненістю сказати, що JavaScript – скрипкова мова, насамперед призначена для створення інтерактивних веб-сторінок, оскільки має для цього потужну базу. JS не потрібно компілювати, адже вона є інтерпретованою мовою програмування. З одного боку це є перевагою, адже розробникові не потрібно задумуватися над тим, для якої платформи він пише програму – йому потрібно тільки знати, чи підтримує браузер, на якому буде запускатися програма, мову JS (а майже всі браузери її підтримують). З іншого боку – це недолік, адже виконання інтерпретованої мови значно повільніше, ніж компільованої. Тому, якщо писати дуже великі проекти на JS, то вони можуть під час запуску довго завантажуватися на сторінку, а вже коли завантажаться, то працювати на таких сторінках вже нормально. Отже, об’ємні JS є причиною уповільнення завантаження сторінок. Ще однією перевагою JS можна назвати інтроспекцію – можливість визначити тип і структуру об’єкта під час виконання програми."
              },
              {
                type: "paragraph",
                text: "Хоча мова JS і являється простою у вивченні та написанні, та це унеможливлює виконання досить складних операцій через малу кількість вбудованих функцій та методів. Отже, значним недоліком JS є відсутність стандартної бібліотеки – для виконання великих проектів та складних завдань потрібно підключати, наприклад, бібліотеку jQuery. Також для таких завдань можуть підійти аплети мови Java. Проте, на відміну від аплетів, дія яких обмежується виділеною площею вікна браузера, скрипти можуть належати до всього документа HTML."
              },
              {
                type: "paragraph",
                text: "Ще однією перевагою JS є автоматичне приведення типів – ця «вільна» конструкція відкриває перед початківцями-програмістами чимало можливостей. Отже, JS має мінімальні вимоги під час створення об’єктів, а об’єктна модель на базі прототипів надає динамічне спадкування та можливість динамічно надавати до об’єктів властивості та методи."
              },
              {
                type: "paragraph",
                text: "Виходячи з того, що JS підключають до HTML-сторінки, його код неможливо приховати від інших користувачів мережі Інтернет. Більше того, через те, що JS продовжує динамічно розвиватися і еволюціонувати (на перший погляд можна сказати, що це велика перевага), на ринку не встигають з’являтися відповідні допоміжні засоби для роботи програміста. Тому, автор свого коду має сам перевіряти, чи правильно діє створена програма, а потім довго гадати, що ж є причиною появи тієї чи іншої помилки. Це великий недолік JS."
              },
              {
                type: "paragraph",
                text: "Що ж до серверних скриптів, то серверний JS значно поступається мові PHP, яка й була розроблена для таких цілей. Та перевагою JS в даній сфері є те, що його використовують для розширення можливостей PHP, оскільки JS дуже непогано доповнює PHP та деякі функції все-таки зручніше робити на скрипті."
              },
              {
                type: "paragraph",
                text: "Перевагою JS можна вважати і просту роботу пов’язану з використанням об’єктної моделі документа, обробників подій та моделі Drag&Drop. Досить ефективно в мові реалізуються засоби динамічної зміни сторінки, додавання і видалення тегів, зміна стилі елементів, швидке реагування на події (клік миші або натисання клавіші), виконання запиту до сервера і завантаження даних без перезавантаження сторінки, встановлення та зчитування cookie."
              },
              {
                type: "paragraph",
                text: "Таким чином, можна зробити висновок, що унікальність та конкурентоспроможність мови JS як представника сімейства клієнтських скриптів забезпечується трьома аспектами:"
              },
              {
                type: "list",
                items: [
                  "1. Повна інтеграція з браузером.",
                  "2. Простий синтаксис – прості речі робляться просто.",
                  "3. Підтримується майже скрізь."
                ]
              },
              {
                type: "paragraph",
                text: "Така тріада робить JS дійсно унікальною."
              }
            ]
          },
          {
            id: 5,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "1. Приведіть приклад використання скрипта.",
                  "2. Дайте загальну характеристику концепції прототипів JavaScript.",
                  "3. Опишіть ланцюжок створення прототипу об’єкта.",
                  "4. Який метод використовується для визначення властивостей об'єкта?",
                  "5. Як використать вбудовану функцію-конструктор.",
                  "6. Назвіть особливості використання об’єктів JavaScript.",
                  "8. Уточніть поняття «фабрика об’єктів».",
                  "9. Охарактеризуйте серверний JavaScript.",
                  "10. Опишіть процес побудови байт-кодового виконувануваного файлу.",
                  "11. Назвіть основні переваги і недоліки мови JavaScript."
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    id: 3,
    title: "ВЕБ-ПРОГРАМУВАННЯ",
    sections: [
      {
        id: 1,
        title: "Загальна характеристика",
        topics: [
          {
            id: 1,
            title: "Вступ до веб-програмування",
            content: [
              {
                type: "heading",
                text: "Вступ до веб-програмування"
              },
              {
                type: "paragraph",
                text: "Розглянемо взаємодію користувача з веб-сторінкою. Веб-сторінка – це електронний документ, який містить текст, графічні зображення, мультимедійні об'єкти, гіперпосилання та спеціальні команди форматування. Ви перейшли на веб сторінку, захотіли оновити інформацію, або відкрити певну форму, дізнатися більше, і таке інше. Після запиту з вашого боку сторінка повністю перезавантажується для зміни контенту. Подібну роботу у Всесвітній павутині називають навігацією або веб-серфінгом. Комп’ютерну навігацію мережею забезпечує встановлена спеціальна програма-клієнт, яку називають веб-браузером. У мережі розташовані комп’ютери, які на основі спеціально встановленого на них програмного забезпечення (веб-сервера), отримують по мережі запити від клієнта (використовуючи http-протокол) їх обробляють і пересилають клієнту відповідь."
              },
              {
                type: "paragraph",
                text: "Це традиційна комп’ютерна взаємодія, яку називають «клієнт-сервер». Користувач робить http-запит, що оброблюється сервером. Результат обробки (оновлену сторінку або контент) сервер повертає користувачу."
              },
              {
                type: "image",
                src: "/images/image094.png", 
                alt: "Клієнт-серверна взаємодія"
              },
              {
                type: "paragraph",
                text: "Розділ програмування, орієнтований на розробку спеціальних програмних рішень для уточнення різноманітних форм цієї взаємодії, називають Веб-програмуванням, а використовувані для цього мови – мовами веб-програмування. Ці мови умовно ділять на дві групи: клієнтські і серверні."
              },
              {
                type: "paragraph",
                text: "В основному, веб-програмування полягає у написанні спеціальних засобів управління цією взаємодією – скриптів. Серверні скрипти виконуються комп'ютером-сервером, на якому розміщений сайт, ще до завантаження сторінок сайту на комп'ютер користувача. Після завантаження сторінки комп'ютер-клієнт починає обробляти клієнтський скрипт, не вимагаючи додаткового перезавантаження сторінки."
              },
              {
                type: "paragraph",
                text: "Існують різні мови веб програмування. Одні (Javascript, Flash, Vbscript) мають інструменти написання тільки серверних скриптів, другі – тільки клієнтських скриптів, треті – й ті, і інші скрипти. Для використання перших на сайті не потрібно встановлювати жодних додаткових програмних засобів. У цьому випадку скрипт вставляється в html-код сторінки сайту. Дякуючи виконанню цього скрипту прямо у браузері, на клієнтському комп'ютері не потрібно встановлювати спеціального програмного забезпечення."
              },
              {
                type: "paragraph",
                text: "Зрозуміло, що різні мови програмування надають різні можливості реалізації задумів програміста. Наприклад, Javascript дозволяє просто відслідковувати дії відвідувачів сайту й реагувати на них. Але ця мова слабенька у підтримці анімації. Тут програмісту приходить на виручку складніша мова з розвинутими засобами реалізації мультимедійних ефектів, наприклад, Adobe Flash."
              },
              {
                type: "paragraph",
                text: "Найбільш відомими мовами веб-програмування серверних скриптів є PHP, Perl. Мова PHP виділяється простотою синтаксису і можливістю використання без застосування додаткового спеціалізованого програмного забезпечення (скрипт вставляється в код html-сторінки) у браузері. Тому багато систем керування сайтом написані на PHP."
              },
              {
                type: "paragraph",
                text: "Розробник сайту має оптимізувати на сайті різноманітні інтерактивні можливості взаємодії клієнта і сервера, серед яких традиційно виділяють:"
              },
              {
                type: "list",
                items: [
                  "засоби зворотного зв'язку (реєстрація, поштові форми);",
                  "інструменти розсилання (новин);",
                  "систему керування сайтом (CMS);",
                  "анімацію;",
                  "пошук по сайту."
                ]
              },
              {
                type: "paragraph",
                text: "Резюмуючи вступ до поняття веб-програмування, можна зазначити такі основні фактори."
              },
              {
                type: "paragraph",
                text: "Практично не можливо створити сучасний веб-сайт, не використовуючи CSS (Cascading Style Sheet). Ці каскадні таблиці стилів є базовим інструментом у веб-дизайні компоновки сторінок, створенні інтерактивних кнопок і меню або простого декорування. Якщо акцент використання сучасних мов розмітки тексту зміщується на уточнення змісту і сутності (семантику), тоді специфікація CSS стала базовою технологією веб-дизайну. Спеціалізовані мови сценаріїв (скриптові мови), в тому числі і JavaScript, були створені з метою оптимізації (покращення, спрощення, уточнення) отримання доступу із сценаріїв до всіх елементів HTML-документа. У цих мовах виділяються спеціалізовані інструменти (засоби) спрощення організації управління інтерактивної (динамічної) взаємодії з користувачем сайту. Прикладом останньої може бути перевірка адрес електронної пошти в формах вводу даних. Разом із CSS JavaScript закладає основу потужності динамічних веб-сторінок, які міняються надзвичайно швидко. Окрім скриптових мов існують і спеціалізовані технології побудови сценаріїв. Наприклад, ASP.NET є базовою технологією побудови серверних скриптів від Microsoft. Вона є найповнішою платформою для веб-розробки, але за її використання потрібно платити гроші."
              },
              {
                type: "paragraph",
                text: "Не останнє місце серед питань, які мусить задавати собі початківець-розробник, є питання вартості програмного забезпечення, яке використовується у розробці. Тут у пригоді стає скриптова мова PHP. Її використання у сполуці з MySQL дозволяє обійти необхідність сплати коштів за ліцензійне програмне забезпечення і в той же час надає гарні засоби веб-програмісту для динамічного веб-конструювання з акцентом на використання баз даних."
              },
              {
                type: "paragraph",
                text: "Кажуть, що хороший веб-програміст має гарно володіти веб-дизайном, знати мову розмітки гіпертекстових документів HTML (HyperText Markup Language), каскадні таблиці стилів CSS (Cascading Style Sheets), мову програмування JavaScript, керувати базою даних MySQL, знати особливості роботи системи управління змістом CMS (Content Management System), базові принципи хостування і ще багато чого. Та мінімальним набором для простенької початкової роботи є знання мов HTML і JavaScript. Тому спробуємо розібратися з мовою гіпертекстової розмітки – інструментом створення гіперпосилань, вставки зображень, таблиць.."
              },
              {
                type: "paragraph",
                text: "А ви бажаєте стати веб-програмістом? !!!"
              },
              {
                type: "paragraph",
                text: "Отже, ми хочемо навчитися робити спеціальну форму з необхідними атрибутами (поле для введення тексту, кнопку відправлення) для відправлення якого-небудь запиту та як скористатися JavaScript для визначення сценарію дій, які слід виконати, щоб одержати бажаний результат запиту."
              }
            ]
          },
          {
            id: 2,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "1. Охарактеризуйте поняття навігація або веб-серфінг у WWW.",
                  "2. Дайте визначення клієнт-серверної взаємодії.",
                  "3. Дайте визначення веб-програмування.",
                  "4. Приведіть приклади мов веб-програмування.",
                  "5. Сформулюйте основні принципи роботи нейрокомп’ютера.",
                  "6. Охарактеризуйте скриптові мови."
                ]
              }
            ]
          }
        ]
      },
      {
        id: 2,
        title: "Створення гіпертекстового документа на основі HTML",
        topics: [
          {
            id: 1,
            title: "Загальна характеристика HTML",
            content: [
              {
                type: "heading",
                text: "Загальна характеристика HTML"
              },
              {
                type: "paragraph",
                text: "HTML (HyperText Markup Language) – описова мова (не мова програмування) розмітки гіпертексту, який використовується для створення документів, незалежних від апаратно-програмної платформи. Гіпертекстовий документ – це документ, який містить пов'язані посилання (гіпертекстові посилання) на інші документи. Користувач має змогу перейти до пов'язаних документів безпосередньо з вихідного (первинного) тексту, активувавши посилання натисканням клавіші миші. Найпопулярнішим зразком гіпертексту є World Wide Web, у якому веб-оглядач переміщує користувача з одного документу на інший. Складові гіпертексту представлені не в лінійній послідовності, а як система блоків із явно вказаними можливостями переходів, зв'язків між ними. Вони дозволяють читачу утворювати різні лінійні тексти за його потребою або рівнем обізнаності. Найпростіший приклад «шкільного гіпертексту» — це коли вчитель дає вам посилання на додаткові навчальні матеріали: книги, статті. У залежності від своїх бажань чи можливостей доступу ви можете вибудувати власну лінійку опанування (читання) цього матеріалу. Загальновідомим прикладом сучасного гіпертексту слугують веб-сторінки. У нашій термінології під гіпертекстом розуміється текст, сформований за допомогою мови розмітки, що потенційно містить у собі гіперпосилання."
              },
              {
                type: "paragraph",
                text: "Гіперпосиланням може бути фрагмент тексту або графічне зображення, виділене кольором або підкресленням. Для його активізації потрібно підвести на нього вказівник (він набуває вигляду скриншот) і натиснувши Ctrl клацнути лівою клавішею мишки. Відбудеться перехід до місця гіпертексту, відміченого вказаним посиланням."
              },
              {
                type: "paragraph",
                text: "Розмітка гіпертексту використовує спеціальний маркер, який називають тегом. Ми спеціально у цій книзі давали опис тегів і їх атрибутів без прив'язки до конкретної версії мови HTML. Це зроблено навмисно, щоб акцентувати увагу на загальних принципах розмітки. Докладні описи можливостей різних версій HTML (на рівні стандартів) можна знайти на сайті http://www.w3.org."
              },
              {
                type: "paragraph",
                text: "Для створення HTML-документа можна скористатися доступним вам текстовим редактором. Наголосимо – текстовим редактором, а не текстовим процесором на кшталт Microsoft Word. Документи, створені за допомогою останніх, зорієнтовані на гарне форматування тексту на основі різних шрифтів, стилів і кольорів з гарною можливістю вставки в текст графічних елементів та просту зміну форматування. Текстовий редактор дозволяє працювати тільки із символами. Серед безкоштовних текстових редакторів є крос-платформні (платформно-незалежні) і зорієнтовані на роботу із окремими операційними системами. Наприклад, редактор Gedit (https://wiki.gnome.org/Apps/Gedit/) відноситься до крос-платформних, тоді ж як текстовий редактор Notepad++ (http://notepad-plus-plus.org/) – для Microsoft Windows, а TextWrangler (http://www.barebones.com/products/textwrangler/) – у Mac OS."
              },
              {
                type: "paragraph",
                text: "Ми обрали крос-платформний текстовий редактор Sublime Text (http://www.sublimetext.com/) за його різнокольоровість розмітки синтаксичних конструкцій. За початкового завантаження він безкоштовний, але з часом потрібно буде придбати ліцензію. Ви ж можете встановити той редактор, який вам до вподоби із вище перерахованих. Робота в них практично не відрізняється. Встановимо Sublime Text, зайшовши на вказаний сайт."
              },
              {
                type: "paragraph",
                text: "Давайте запустимо Sublime Text. Виберемо опцію створення нового файлу File New File, підведемо на неї маркер мишки і натиснемо ліву клавішу мишки. На екрані монітора з’явиться вікно набору нового файлу. Робота по набору тексту файлу проста – її можна опанувати методом спроб і помилок. Потім наберемо текст (зміст пояснимо пізніше) у редакторі. Він прийме вигляд, представлений на рисунку 3.2."
              },
              {
                type: "code",
                code: "<Meta charset = \"UTF-8\">\n<h1>Привіт, внучата! </h1>\n<p>Моя перша веб-сторінка.</p>"
              },
              {
                type: "image",
                src: "/images/image095.png", 
                alt: "Рис. 3.2. Вигляд тексту в редакторі."
              },
              {
                type: "paragraph",
                text: "Збережіть цей файл з ім’ям page_1.html, вибравши File Save на вашому робочому столі або в спеціальній директорії. Все готово для створення веб-сторінки. Запустимо веб-браузер. Відкрийте Chrome і, утримуючи CTRL, натисніть O (в Mac OS замість CTRL використовуйте клавішу COMMAND). У вікні відкриття файлу виберіть файл page_1.html, посунувши маркер на запис з ім’ям цього файлу, та натиснувши ліву клавіші миші. Рядок із ім’ям файлу підсвітиться (рис. 3.3):"
              },
              {
                type: "image",
                src: "/images/image096.png", 
                alt: "Рис. 3.3. Вигляд вікна браузера готового до запуску файла на виконання."
              },
              {
                type: "paragraph",
                text: "Підведіть вказівник мишки на опцію відкриття файлу «Открыть» та натисніть ліву клавішу мишки на неї. Через декілька секунд у браузері ви побачите першу створену вами сторінку (рис. 3.4.)"
              },
              {
                type: "image",
                src: "/images/image097.png", 
                alt: "Рис. 3.4. Вигляд створеної веб-сторінки."
              },
              {
                type: "paragraph",
                text: "Вітання!!! Ви вже початковий веб-програміст."
              }
            ]
          },
          {
            id: 2, 
            title: "Перша повноцінна сторінка",
            content: [
              {
                type: "heading",
                text: "Перша повноцінна сторінка"
              },
              {
                type: "subheading",
                text: "Макет документу"
              },
              {
                type: "paragraph",
                text: "Отже, HTML – це спеціальне кодування структурування і відображення веб-сторінки і її контенту. Воно повідомляє браузер, як відображати веб-сторінки, які ви відвідуєте. HTML-код – спосіб добавити в текст додаткову інформацію. HTML складається з ряду елементів форматування структури і типу контенту, спеціальних тегів, що можуть: зробити слово або зображення посиланням на щось ще; форматування слова певним видом верстки (курсив); обрати шрифт і так далі. Кожний створюваний елемент вмісту будується на основі шаблона створення. Шаблон створення може визначати, які типи простих елементів входять до елемента вмісту. Зовнішній вигляд елемента вмісту, який буде показано на веб-сторінці, залежить від того, за допомогою якого шаблона створення було створено елемент вмісту, і за допомогою якого шаблона представлення відображається вміст. Для визначення точного макету шаблона представлення рекомендується використовувати елементи HTML (наприклад, таблиці), але це не є обов'язковим. Сторінка може мати будь-який макет на ваш вибір."
              },
              {
                type: "paragraph",
                text: "Традиційно, структура веб-сторінки нагадує структуру сторінки звичайного паперового тексту. На рисунку 3.5. зображена ця типова структура, яка використовується в шаблоні представлення і може бути реалізована засобами HTML-коду."
              },
              {
                type: "image",
                src: "/images/image098.jpg", 
                alt: "Рис. 3.5. Структура веб-сторінки"
              },
              {
                type: "paragraph",
                text: "Тобто, перед створення веб-сторінки вручну доцільно створити \"макет\" сторінки в форматі HTML. Код HTML дозволяє визначити макет шаблона представлення так само, як макет веб-сторінки."
              },
              {
                type: "subheading",
                text: "Елемент HTML"
              },
              {
                type: "paragraph",
                text: "Текстовий документ складається із речень. Одне або декілька речень тексту, що представляє собою смислову єдність (присвячене(і) якомусь одному питанню, певному аспекту розглянутої проблеми) і виділене відступом в першому рядку утворює(ють) абзац. Він допомагає в сприйнятті тексту. HTML має спеціальну пару тегів <p> і </p> для явного виділення в тексті абзацу. Ці теги заміняють «виділення відступом в першому рядку»."
              },
              {
                type: "paragraph",
                text: "Наприклад, якщо ми бажаємо наступне речення «Усі діти талановиті» зробити абзацом, маємо заключити його текст в теги визначення абзацу."
              },
              {
                type: "code",
                code: "<р>Усі діти талановиті</р>"
              },
              {
                type: "paragraph",
                text: "Розглянемо на цьому прикладі анатомію елементу HTML, зображену на рис.3.6."
              },
              {
                type: "image",
                src: "/images/image099.png", 
                alt: "Рис. 3.6. Структура елементу абзац HTML."
              },
              {
                type: "paragraph",
                text: "Компонентами нашого елементу будуть:"
              },
              {
                type: "list",
                items: [
                  "1. Тег відкриття (Opening tag): Складається із назви елементу «p», обмеженого кутовими дужками «< >». Позначає початок абзацу.",
                  "2. Тег закриття (Closing tag): Складається із назви елементу «/p», обмеженого кутовими дудками «< >». Позначає кінець абзацу.",
                  "3. Контент (Content): Це зміст елементу, у нашому прикладі – фрагмент тексту.",
                  "4. Елемент (Element): Теги відкриття і закриття та контент утворюють елемент абзац."
                ]
              },
              {
                type: "subheading",
                text: "Атрибути елементу"
              },
              {
                type: "paragraph",
                text: "Елементи можуть мати атрибути."
              },
              {
                type: "paragraph",
                text: "Вони задають додаткову інформацію про елементи, яку ви не бажаєте відображати у основному контенті. Синтаксично атрибут розміщується у тегах перед основною інформацією:"
              },
              {
                type: "code",
                code: "<p атрибут > контент </p>."
              },
              {
                type: "paragraph",
                text: "Наприклад, давайте створимо сторінку, набравши в редакторі такий текст:"
              },
              {
                type: "code",
                code: "<meta charset=\"UTF-8\">\n<h1>Усі діти талановиті!</h1>\n<p>Це моя 2-а веб-сторінка.</p>\n<p><a href=\"http://notepad-plus-plus.org/\">  Натисніть сюди\n    </a>, щоб перейти на сайт підтримки редактора Notepad ++ для подальшого встановлення.</p>"
              },
              {
                type: "paragraph",
                text: "та збережемо його з ім’ям page_2.html. Після виклику цього файлу у браузері, буде створена наша друга веб-сторінка. Її вигляд відображено на рисунку 3.7."
              },
              {
                type: "image",
                src: "/images/image100.png", 
                alt: "Рис. 3.7. Вигляд 2-ї сторінки з елементом, що містить атрибут."
              },
              {
                type: "paragraph",
                text: "Якщо за допомоги миші ініціюємо посилання «Натисніть сюди», то перейдемо на сайт установки відповідного редактору. Атрибут має ім’я та значення."
              },
              {
                type: "paragraph",
                text: "У цьому прикладі у стрічках:"
              },
              {
                type: "code",
                code: "<p><a href=\"http://notepad-plus-plus.org/\">  Натисніть сюди\n        </a>, щоб перейти на сайт підтримки редактора Notepad ++ для подальшого встановлення.</p>"
              },
              {
                type: "paragraph",
                text: "**href** – ім’я атрибута, а **\"http://notepad-plus-plus.org/\"** – значення атрибута."
              },
              {
                type: "paragraph",
                text: "Таке визначення дозволяє відправити вас за довільною веб-адресою, яка зазначена в якості значення атрибута з іменем **href**."
              },
              {
                type: "paragraph",
                text: "Атрибут завжди повинен мати:"
              },
              {
                type: "list",
                items: [
                  "Пропуск (пробіл) між ним і ім'ям елемента HTML (або попереднім атрибутом, якщо елемент вже має один або кілька атрибутів).",
                  "Ім'я атрибута і його значення розділяються знаком рівності «=», а значення атрибута береться з обох боків у лапки «\"»."
                ]
              },
              {
                type: "subheading",
                text: "Вкладені елементи"
              },
              {
                type: "paragraph",
                text: "Елементи HTML можуть розміщатися всередині інших елементів. Наприклад, якщо ми хочемо наголосити, що «усі» діти талановиті, то це ми можемо зробити, заключивши слово «усі» в елемент, використавши тег **<strong>**, який вказує на виділення тексту, який стоїть між цими тегами, жирним шрифтом."
              },
              {
                type: "paragraph",
                text: "Елемент **<em>** відображає свій вміст курсивом. Ці два останні елементи (**strong, em**) відносяться до рядкових елементів, оскільки вони не виводять свій вміст окремим рядком. Щоб відобразити текст одночасно жирним шрифтом і курсивом, помістіть його усередину обох тегів."
              },
              {
                type: "paragraph",
                text: "Важливо при вкладенні дотримуватися вірного закриття тегів. Першим закривається тег, який відкривався останнім:"
              },
              {
                type: "code",
                code: "<h1>  <strong>Усі</strong> діти талановиті!</h1>."
              },
              {
                type: "paragraph",
                text: "Як ви вже зрозуміли, теги бувають парні і одинарні."
              },
              {
                type: "paragraph",
                text: "Типова структура парного тегу:"
              },
              {
                type: "code",
                code: "<Тег [атрибут = \"значення\" [атрибут = \"значення\" [...]]]> вміст </тег>"
              },
              {
                type: "paragraph",
                text: "Типова структура непарного (одиночного) тега:"
              },
              {
                type: "code",
                code: "<Тег [атрибут = \"значення\" [атрибут = \"значення\" [...]]] /> , де квадратні дужки позначають «може бути або не бути»."
              },
              {
                type: "paragraph",
                text: "Переважна більшість тегів HTML – парні, тобто вимагають наявності (присутності) закриваючого тегу. Теги можуть бути вкладеними, при цьому важливо дотримуватися порядку відповідності відкриваючих і закриваючих тегів. Теги HTML не чутливі до регістру. Значення атрибутів вкрай рекомендується закривати в одинарні або подвійні лапки."
              },
              {
                type: "subheading",
                text: "Мета-теги"
              },
              {
                type: "paragraph",
                text: "Основне призначення мета-тегів (**<meta ... />**), це включення додаткової інформації про документ: відомості про автора, дату створення документа або авторські права. Ця інформація орієнтована на сервери, браузери і пошукових роботів. Відвідувачі веб-сторінки її не побачать. У документі може знаходитися будь-яку кількість тегів **<meta>**. Всі вони розміщуються в блоці **<head> ... </head>**."
              },
              {
                type: "paragraph",
                text: "Ми вже використовували один із мета тегів «**<meta charset=\"UTF-8\">**», щоб повідомити браузер про кодування веб-сторінки (можливість працювати із кирилицею)."
              },
              {
                type: "subheading",
                text: "Повноцінний HTML-документ"
              },
              {
                type: "paragraph",
                text: "Повноцінний HTML-документ повинен включати деякі додаткові елементи. Давайте подивимося на наступний закінчений HTML-документ:"
              },
              {
                type: "code",
                code: "<html>\n<head>\n<title>Моя 3-я сторінка</title>\n</head>\n<body>\n<strong>  Ми виходимо у всесвітню паутину!!!</strong>\n<br>\nМенe звати <em>  Андрійко </em>, це моя третя сторінка!\n</body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Браузер, зустрівши тег **<html>**, розуміє його як сигнал до того, що далі буде документ, який необхідно прочитати та проаналізувати і вивести на монітор в потрібному вигляді. Тег **</html>** говорить про те, що документ закінчився. Елемент **<html>** обертає весь контент на всій сторінці. Іноді його називають кореневим елементом."
              },
              {
                type: "paragraph",
                text: "Елемент **<head>** визначає основну інформацію про документ. Цей елемент виступає в якості контейнера для всього того, що не є контентом, який показується користувачам сторінки, і ви побажаєте включити на HTML сторінку. У ньому можуть міститися такі речі, як ключові слова і опис сторінки, які будуть з'являтися в результатах пошуку, CSS стилі нашого контенту, кодування і багато іншого."
              },
              {
                type: "paragraph",
                text: "**<title>** вказує на те, що в шапці вікна потрібно написати його назву «Моя 3-я сторінка». Цей елемент встановлює заголовок для сторінки, який є назвою, що з'являтиметься на вкладці браузера, коли завантажується сторінка, і використовується для опису сторінки, коли ви додаєте її в закладки/обране."
              },
              {
                type: "paragraph",
                text: "Елемент **<body>** визначає «тіло» документа, тобто те, що виставляємо на загальний огляд. У ньому міститься весь контент, який ви хочете показувати користувачам, коли вони відвідують вашу сторінку, будь то текст, зображення, відео, ігри або щось ще."
              },
              {
                type: "paragraph",
                text: "Тег **<br>** – переносимо текст тіла на наступну стрічку."
              },
              {
                type: "paragraph",
                text: "Якщо записати відповідний текст в файл page_3.html і запустити його на виконання у браузері, то відображення створеної сторінки представлено на рисунку 3.8."
              },
              {
                type: "image",
                src: "/images/image101.png", 
                alt: "Рис. 3.8. Вигляд повноцінної сторінки."
              },
              {
                type: "paragraph",
                text: "Тобто, всі HTML документи повинні мати ось такий шаблон коду:"
              },
              {
                type: "code",
                code: "<html> - початок документа\n<head> - початок голови\n...\n</head> - закриття голови\n<body> - початок тіла\n...\n</body> - закриття тіла\n</html> - кінець документа"
              },
              {
                type: "paragraph",
                text: "Усі ці теги є обов'язковими. Писати їх необхідно завжди для кожної нової сторінки, і тільки в такому порядку!"
              }
            ]
          },
          {
            id: 3, 
            title: "Становлення веб-майстра",
            content: [
              {
                type: "heading",
                text: "Становлення веб-майстра"
              },
              {
                type: "subheading",
                text: "Редагування тексту"
              },
              {
                type: "paragraph",
                text: "З текстом на сторінці можна робити більшість речей, притаманних текстовим редакторам. Ми вже трішки розповіли про роботу з текстом на сторінці. Розвинемо їх тут."
              },
              {
                type: "paragraph",
                text: "Згадаємо тег **<p>** для виділення абзаців. Їх ще називають параграфами. Цей тег може мати атрибут **align**, який відповідає за те, що у текстових редакторах називають \"вирівнюванням\". Цей атрибут може приймати значення:"
              },
              {
                type: "list",
                items: [
                  "**center** – вирівнювання по центру;",
                  "**left** – по лівому краю;",
                  "**right** – по правому краю;",
                  "**justify** – обох краях документа."
                ]
              },
              {
                type: "paragraph",
                text: "Для прикладу використання цього атрибуту давайте трішки змінимо нашу попередню сторінку:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <title>Моя 4-та сторінка</title>\n  </head>\n  <body>\n    <p align=\"center\">\n      <strong>  Ми виходимо у всесвітню паутину!!!        </strong> \n    </p>\n    <br>\n    <p align=\"left\">Менe звати <em>Андрійко</em>, це моя 4-та сторінка!</p>\n    <p align=\"justify\">Я вчуся програмуванню. Наразі вивчаю початки веб-програмування. Хочу знайти друзів-однодумців, що мають подібне бажання. Планую сформувати групу для обговорення спірних питань. Приєднуйтеся!!!</p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "З кожним днем у нас збільшується кількість наших сторінок і файлів їх задання. Щоб не заплутатися з різноманіттям файлів на вашому компі, давайте створимо окремий каталог чи директорію, так називаються папки файлової системи вашої операційної системи, на «робочому столі» та назвемо її, наприклад – **web_prog**. До неї будемо заносити наші файли. Для цього вийдемо із текстового редактору. Підведемо маркер мишки на вільне місце «робочого столу» (екран монітору) та натиснемо праву клавішу мишки. На екрані з’явиться вікно з набором опцій. Підведемо указник на опцію «створить». Вона підсвітиться синім кольором і справа з’явиться підвікно, з опціями, назви яких визначають, що можна створити (дивись Рис. 3.9). Ми бажаємо створити нову папку, тому підводимо маркер на опцію «Папка» та натискаємо ліву клавішу мишки. На екрані появиться значок папки з виділеною назвою «Нова папка». Підводимо указник миші на цю папку і натискаємо праву клавішу. Появиться вікно «Відкрить» з назвами його опцій. Підводимо указник на опцію «Перейменувать» і натискаємо на ліву клавішу. Зникне вікно і підпис «Нова папка» поміняє колір. Комп очікує, щоб ви ввели з клавіатури дійсну назву папки, яку ви створили. Наберемо назву «web_prog» і натиснемо ліву клавішу. Папка отримує назву. Залишилося перемістити наші html-файли до нашої нової папки. Для цього підводимо маркер мишки на піктограму з ім’ям файлу, який хочемо перемістити до папки, натискуємо ліву клавішу. Піктограма міняє колір. Натискаємо ще раз ліву клавішу і тримаємо її натиснутою – на піктограмі з’являється прямокутник. Не відпускаючи натиснуту клавішу переміщаємо цей прямокутник на піктограму нашої папки «web_prog» і відпускаємо ліву клавішу. Файл перемістився в нову папку – піктограма із його зображенням зникла з монітора. Проробимо подібні дії з усіма нашими html-файлами. Щоб побачити зміст нашої папки, підведемо маркер на неї і два рази клацнемо ліву клавішу мишки."
              },
              {
                type: "image",
                src: "/images/image102.png",
                alt: "Зображення створення нової папки"
              },
              {
                type: "paragraph",
                text: "Отже, наберемо нашу останню модифікацію сторінки і збережемо її у файлі з ім’ям page_4.html. Знову для кращої ідентифікації у назві файлу «page_4» цифру 4 ми використали для співставлення цього файлу з 4-ю сторінкою. Це не обов’язково робити, але ви оціните цей підхід пізніше. Запустимо файл на виконання. Рисунок 3.10 демонструє запропоноване вирівнювання тексту."
              },
              {
                type: "image",
                src: "/images/image103.png",
                alt: "Рисунок 3.10. Зображення використання тегу вирівнювання тексту"
              },
              {
                type: "paragraph",
                text: "Зробимо декілька зауважень відносно використання елементу **<p>**:"
              },
              {
                type: "list",
                items: [
                  "1) Тег **<p>** не може містити в собі інші абзаци, тобто не можна писати так: **<p>…<p>…</p></p>**.",
                  "2) Елемент **<p>** не може бути пустим, тобто не можна писати так: **<p></p>**.",
                  "3) За замовчуванням текст вирівнюється браузером по лівому краю, тобто якщо таке вирівнювання Вам і потрібно, атрибут **align=\"left\"** можна опустити.",
                  "4) Тег **<p>** робить перенесення стрічок. Якщо перенос не потрібний, використовується тег **<div>** за аналогічного синтаксису написання."
                ]
              },
              {
                type: "paragraph",
                text: "Вирівнювання тексту по центру можна зробити, скориставшись тегом **<center>**. Довільний контекст, обмежений цим тегом, вирівнюється по центру екрана. Спробуйте ці зауваги з вашою сторінкою."
              },
              {
                type: "paragraph",
                text: "Для відображення різних заголовків мова розмітки містить шість варіантів формату їх відображення:"
              },
              {
                type: "list",
                items: [
                  "**<h1>** текст **</h1>**",
                  "**<h2>** текст **</h2>**",
                  "**<h3>** текст **</h3>**",
                  "**<h4>** текст **</h4>**",
                  "**<h5>** текст **</h5>**",
                  "**<h6>** текст **</h6>**."
                ]
              },
              {
                type: "paragraph",
                text: "Для вказівок відносно шрифту і його розміру більшого тексту за заголовок використовують тег **<font>** і атрибут **size** – розмір. Правила їх запису традиційні:"
              },
              {
                type: "list",
                items: [
                  "**<font size=\"+6\">**текст**</font>**",
                  "**<font size=\"+0\">**текст**</font>**",
                  "**<font size=\"-3\">**текст**</font>**."
                ]
              },
              {
                type: "paragraph",
                text: "Спробуйте проекспериментувати разом з нами, використавши різні значення цифр. Добавимо ці теги на нашу сторінку:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <title>Моя 5-та сторінка</title>\n  </head>\n  <body>\n    <center><h3>  <font color=\"blue\"> Ми виходимо у всесвітню паутину!!!  </font> </h3></center>\n    <br>\n    <div align=\" justify \"><font size=\"-1\"> Менe звати <em>  Андрійко  </em>, це моя 5-та    сторінка! </div >\n    <p align=\"justify\">\n      <font size=\"+3\"> Я вчуся програмуванню.  Наразі вивчаю початки веб-програмування.</p>\n    <p> <font size=\"+6\">Хочу  знайти друзів-однодумців, що мають подібне бажання. </p>\n    <p>    <font size=\"+0\">Планую сформувати групу для обговорення спірних питань. Приєднуйтеся!!! </font> </p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Запустивши цей фрагмент тексту на виконання у браузері, отримаємо нове форматування попереднього тексту, відображене на рисунку 3.11."
              },
              {
                type: "image",
                src: "/images/image104.png",
                alt: "Рис 3.11. Зображення нових можливостей форматування тексту"
              },
              {
                type: "subheading",
                text: "Колір"
              },
              {
                type: "paragraph",
                text: "Чорно-білий вигляд наших сторінок не відображає різноманітності світу. Радість сприйняття привносить нам різнобарв’я веселки кольорів. Мова Html має широку палітру вибору фарб. На рисунку 3.12 представлені основні кольори цієї палітри."
              },
              {
                type: "image",
                src: "/images/imageColors.png",
                alt: "Рис 3.12. Зображення основних кольорів палітри фарб HTML"
              },
              {
                type: "paragraph",
                text: "Колір може ідентифікуватися двома способами:"
              },
              {
                type: "list",
                items: [
                  "скориставшись номером кольору в RGB, синтаксис запису – **#число** в шістнадцятирічній системі числення;",
                  "застосувавши константу кольору (**black** –чорний, **white** – білий, **red** –червоний, **orange** – коричневий, **yellow** – жовтий, **green** – зелений, **cyan** –голубий, **blue** –синій, **purple** – фіолетовий)."
                ]
              },
              {
                type: "paragraph",
                text: "Тобто вибір фарби червоного кольору можна зазначити номером «**#ff0000**» або константою «**red**», вказавши їх в атрибуті **color** або **text** тегів **font** або **body**. Наприклад, якщо в попередній сторінці ми хочемо зробити відображення фрагменту тексту «Ми виходимо у всесвітню паутину!!!» шрифтом з синім кольором, то маємо написати так:"
              },
              {
                type: "code",
                code: "<font color=\"#0000ff\"> Ми виходимо у всесвітню паутину!!!!!!</font>"
              },
              {
                type: "paragraph",
                text: "або так:"
              },
              {
                type: "code",
                code: "<font color=\"blue\"> Ми виходимо у всесвітню паутину!!!!!!</font>."
              },
              {
                type: "paragraph",
                text: "Тег **<body>** з атрибутом **text** використовують для заливки відповідним кольром всієї сторінки, крім тих місць, які спеціально виділили іншим кольором. Наприклад, виділення всього тексту окрім заголовку зеленим кольором можна зробити так:"
              },
              {
                type: "code",
                code: "<body text=\"green\">."
              },
              {
                type: "paragraph",
                text: "Змінити колір фарби фону сторінки можна за допомоги атрибуту **bgcolor** тегу **<body>**. Наприклад, щоб зробити фон жовтим, достатньо написати:"
              },
              {
                type: "code",
                code: "<body bgcolor=\"yellow\">."
              },
              {
                type: "paragraph",
                text: "Два останні атрибути можна об’єднати в одному тегу, розділивши їх пробілом:"
              },
              {
                type: "code",
                code: "<body text=\"green\" bgcolor=\"yellow\">."
              },
              {
                type: "paragraph",
                text: "Давайте додамо ці зміни на нашу сторінку. Вона прийме вигляд:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <title>Моя 6-та сторінка</title>\n  </head>\n  <body text=\"green\" bgcolor=\"yellow\">\n    <center>\n      <h3>\n        <font color=\"blue\"> Ми виходимо у всесвітню паутину!!!!!!</font>\n      </h3>\n    </center>\n    <br>\n    <div align=\" justify \"><font size=\"-1\"> Менe звати <em>Андрійко</em>, це моя 6-та сторінка!</div >\n    <p align=\"justify\">\n      <font size=\"+3\"> Я вчуся програмуванню. Наразі вивчаю початки веб- програмування.</p>\n    <p>\n      <font size=\"+6\">Хочу знайти друзів-однодумців, що мають подібне бажання. </p>\n    <p>      <font size=\"+0\"  color=\"red\">Планую сформувати групу для обговорення спірних питань. Приєднуйтеся!!! </font>\n    </p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Цей код породжує сторінку, представлену на рисунку 3.13."
              },
              {
                type: "image",
                src: "/images/image105.png",
                alt: "Рис 3.13. Зображення різнокольорової сторінки"
              },
              {
                type: "subheading",
                text: "Стиль і шрифт тексту"
              },
              {
                type: "paragraph",
                text: "Різні стилі в відображенні на сторінці можна задати за допомоги таких тегів: **<b></b>** – напівжирний; **<i></i>** – похилий; **<u></u>** – підкреслений; **<strike></strike>**, **<s></s>** – перечеркнутий, **<small></small>** – маленький, **<big></big>** – великий, **<sup></sup>** – верхній індекс, **<sub></sub>** – нижній індекс. Випробуйте ці теги самостійно."
              },
              {
                type: "paragraph",
                text: "Явно вибрати шрифт символів фрагменту тексту можна зробити за допомоги тегу **<font>** і його атрибуту **face**. Наприклад, якщо ми хочемо відобразити на сторінці фрагмент тексту «Ми вчимося програмувати» шрифтом «times new roman», маємо скористатися таким кодом:"
              },
              {
                type: "code",
                code: "<font face=\"times new roman\"> Ми вчимося програмувати </font> ."
              },
              {
                type: "paragraph",
                text: "Враховуючи, що браузер не звертає уваги на переноси і кількість пробілів між словами, залишаючи один, для явного зберігання форматування тексту, зробленому в текстовому редакторі, можна скористатися тегом **<pre>**. Відповідний текст заключається в цей елемент. Пограйтесь із новим матеріалом на нових сторінках."
              },
              {
                type: "subheading",
                text: "Рисунки"
              },
              {
                type: "paragraph",
                text: "З текстом ми вже вміємо працювати, та цього замало. Розглянемо можливість привнесення на сторінку графічних об’єктів: рисунків, фотографій. Ця можливість може вам стати у пригоді у багатьох випадках. Мова HTML має значний набір тегів для цього."
              },
              {
                type: "paragraph",
                text: "Файл графічного об’єкту можна вставити в сторінку двома способами. У першому – потрібно цей файл перенести спочатку у папку, де зберігаються ваші html-файли, а потім скористатися одинарним тегом **<img>** з атрибутом **src**. Синтаксис вставки такий:"
              },
              {
                type: "code",
                code: "<img src=\"ім’я фалу\">, де ім’я файлу – це ім’я перенесеного файлу зберігання графічного об’єкту."
              },
              {
                type: "paragraph",
                text: "Спробуємо вставити в нашу останню сторінку рисунок, який знаходиться у файлі **picture_1.gif** на «робочому столі» нашого компа. Спочатку перенесемо цей файл у папку **web_progr**. Потім у html-файлі останньої сторінки зробимо вставку: **<img src=\" picture_1.gif \">**. Код html-файлу прийме вигляд:"
              },
              {
                type: "code",
                code: "<html>\n<meta charset=\"UTF-8\">\n<html>\n  <head>\n    <title>Моя 6-та сторінка</title>\n  </head>\n  <body text=\"green\" bgcolor=\"yellow\">\n    <center>\n      <h3>\n        <font color=\"blue\"> Ми виходимо у всесвітню паутину !!!!!!</font>\n      </h3>\n    </center>\n    <br>\n    <img src=\" picture_1.gif \">\n    <div align=\" justify \"><font size=\"-1\"> Менe звати <em>  Андрійко </em>,  це моя 6-та    сторінка! </div >\n    <p align=\"justify\">\n      <font size=\"+3\"> Я вчуся програмуванню. Наразі вивчаю початки веб-програмування.</p>\n    <p>\n      <font size=\"+6\">Хочу знайти друзів-однодумців, що мають подіб не бажання. </p>\n    <p>      <font size=\"+0\"  color=\"red\">Планую сформувати групу для обговорення спірних питань. Приєднуйтеся!!! </font>\n    </p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Спробуйте проробити аналогічні дії та запустити власну сторінку."
              },
              {
                type: "paragraph",
                text: "У другому способі потрібно скористатися інтернет-ресурсом. Для цього потрібно явно вказати шлях до того файлу, що містить графічний об’єкт: **<img src=\"шлях до папки де міститься графічний об’єкт/ім’я файлу\">**. Давайте спробуємо це продемонструвати на прикладі. Нехай, Андрійко у сторінку хоче вставити фото дідуся. Він «заходить» в гуглівський пошукач, набирає прізвище і ім’я дідуся. Пошукач видає результат пошуку. Андрійко переходить в картинки і серед них вибирає фото, яке йому сподобалося. Підводить маркер на обране фото і натискає ліву клавішу миші. Пошукач перейде на інтернет-ресурс, де зберігається обране фото. Підведемо маркер миші на це фото і натиснемо праву клавішу мишки. З’явиться вікно із різними опціями. Обираємо «копіювати URL картинки» для запам’ятовування адреси фото (картинки). Потім наберемо тег **<img src=\" \">**. Підведемо маркер мишки в середину кавичок і зробимо вставку адреси фото, натискнувши «Ctrl/v». Наш тег прийме вигляд: **<img src= \"https://noospherescience.com/images/uploads/event_user/1/1a41a06d03dd03629e1df6748aa17796/ 629a8596e8eca940daadd39fb6960d36.jpg\">**."
              },
              {
                type: "code",
                code: "<html>\n  <meta charset=\"UTF-8\">\n  <head>\n    <title>Моя 8-а сторінка</title>\n  </head>\n  <body>\n    <strong>  Хочу познайомити світ із моїм дідусем!!! </strong>\n    <br>\n    Ось його фото!\n    <img src= \"https://noospherescience.com/images/uploads/event_user/1/1a41a06d03dd03629e1df6748aa17796/629a8596e8eca940daadd39fb6960d36.jpg\">\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Розміщенням графічного об’єкта на сторінці можна керувати за допомоги атрибутів тегу **<img>**:"
              },
              {
                type: "list",
                items: [
                  "**<img src=\"ім’я файлу_об’єкта\" align=\"left\">** – об’єкт зліва від тексту;",
                  "**<img src=\"ім’я файлу_об’єкта\" align=\"right\">** – об’єкт справа від тексту;",
                  "**<img src=\"ім’я файлу_об’єкта\" align=\"top\">** – текст вище об’єкта;",
                  "**<img src=\"ім’я файлу_об’єкта\" align=\"bottom\">** – текст внизу об’єкта;",
                  "**<img src=\"ім’я файлу_об’єкта\" align=\"middle\">** – об’єкт посередині тексту."
                ]
              },
              {
                type: "paragraph",
                text: "Атрибутом **_space** можна явно задавати відстань від графічного об’єкта до тексту. Відстань вимірюється у пікселях. Піксель – точка підсвітки екрану монітору, елементарна неподільна одиниця зображення. Особливості потрібно перевірити самим на конкретних прикладах. Приведемо основні варіації відповідного атрибуту:"
              },
              {
                type: "list",
                items: [
                  "**<img src=\"ім’я файлу_об’єкта\" vspace=\"20\">** – **vspace** задає відстань в 20 пікселів по вертикалі від об’єкта до текста;",
                  "**<img src=\"ім’я файлу_об’єкта\" hspace=\"10\">** – **hspace** задає відстань в 20 пікселів по горизонталі від об’єкта до текста."
                ]
              },
              {
                type: "paragraph",
                text: "Мова HTML має спеціальні теги уточнення самого зображення об’єкта:"
              },
              {
                type: "list",
                items: [
                  "**<img src=\"ім’я файлу_об’єкта\" width=\"100\">** – ширина графічного об’єкта;",
                  "**<img src=\"ім’я файлу_об’єкта\" height=\"200\">** – висота графічного об’єкта."
                ]
              },
              {
                type: "paragraph",
                text: "За замовчуванням залишаються реальні розміри графічного об’єкта, представлені у файлі. Реальні картини люди обрамляють рамками. Ці рамки ще називають бордюрами. Маємо спеціальні атрибути уточнення зображення рамки графічного об’єкта на сторінці:"
              },
              {
                type: "list",
                items: [
                  "**<img src=\"ім’я файлу_об’єкта\" border=\"4\">** – рамка матиме товщину в 4 пікселі;",
                  "**<img src=\"ім’я файлу_об’єкта bordercolor=\"yellow\">** – колір рамки жовтий."
                ]
              },
              {
                type: "paragraph",
                text: "Можна задавати й опис зображення, який буде з’являтися на сторінці, коли користувач наведе курсор мишки на зображення і потримає його там декілька секунд:"
              },
              {
                type: "list",
                items: [
                  "**<img src=\"ім’я файлу_об’єкта\" alt=\"Опис зображення\">**;",
                  "**<img src=\"ім’я файлу_об’єкта\" title=\" Опис зображення\">**."
                ]
              },
              {
                type: "paragraph",
                text: "Зображення можна зробити фоном сторінки, скориставшись атрибутом **background** тега **<body>**:"
              },
              {
                type: "code",
                code: "<body background=\"ім’я файлу_об’єкта\">."
              },
              {
                type: "paragraph",
                text: "Для розміщення графічного зображення в потрібному місці сторінки можна скористатися тегами вирівнювання, які ми розглядали раніше для вирівнювання тексту на сторінці. Наприклад, для вирівнювання по центру:"
              },
              {
                type: "code",
                code: "<center><img src=\" ім’я файлу_об’єкта \"></center> ."
              },
              {
                type: "paragraph",
                text: "Спробуйте уточнити використання цих атрибутів роботи із зображеннями на якійсь вашій сторінці. Зважте тільки на те, щоб розміри зображень вставок були незначні. Вставка графічних зображень великого розміру приведе до часових затримок загрузки сторінки та потребує велику швидкість каналу зв’язку із Інтернетом."
              },
              {
                type: "subheading",
                text: "Таблиці"
              },
              {
                type: "paragraph",
                text: "У повсякденному житті ми звикли використовувати таблиці для наочності та структурування інформації подання. Тому маємо навчитися, як робити таблиці на сторінці. Як ви вже зрозуміли – для цього потрібно скористатися спеціальними тегами. Розглянемо теги створення таблиці: **<table>** задає початок і кінець таблиці, **<tr>** - визначає рядок таблиці, **<td>** - стовпець таблиці. Продемонструємо використання зазначених тегів для побудови сторінки успішності Андрійка. Нехай, Андрійку потрібно на свою сторінку вставити таблицю, яка буде відображати табель його успішності в школі за останню чверть."
              },
              {
                type: "paragraph",
                text: "Подумаємо про структуру таблиці. Традиційний табель успішності містить три колонки (стовпці). Перша колонка використовується для вказівки предмету навчання, друга – оцінка (відмінно, добре,…), третя – бали рейтингу від 1 до 12. Якщо за чверть навчання вивчається десять предметів, тоді таблиця повинна мати 10 рядків. Для скорочення запису обмежимо кількість предметів вивчення до 5. Тому наша таблиця має складатися із 6-ти рядків. Перший рядок для визначення імен колонок, інші для наповнення предметами та оцінками. Почнемо писати html-код цієї сторінки:"
              },
              {
                type: "code",
                code: "<html>\n  <meta charset=\"UTF-8\">\n  <head>\n    <title>Сторінка-табель успішності</title>\n  </head>\n  <body>\n    <strong>Хочу навчитися працювати із таблицями засобами HTML !!!</strong>\n    <br>\n    <em>  ТАБЕЛЬ УСПІШНОСТІ </em> \n    <table > \n      <tr>\n        <td>РЯДОК1 комірка1</td>\n        <td> РЯДОК1 комірка2</td>\n        <td> РЯДОК1комірка3</td>\n      </tr>\n      <tr>\n        <td>РЯДОК2 комірка1</td>\n        <td> РЯДОК2 комірка2</td>\n        <td> РЯДОК2 комірка3</td>\n      </tr>\n      <tr>\n        <td>РЯДОК3комірка1</td>\n        <td> РЯДОК3 комірка2</td>\n        <td> РЯДОК3 комірка3</td>\n      </tr>\n      <tr>\n        <td>РЯДОК4 комірка1</td>\n        <td> РЯДОК4 комірка2</td>\n        <td> РЯДОК4 комірка3</td>\n      </tr>\n      <tr>\n        <td>РЯДОК5 комірка1</td>\n        <td> РЯДОК5 комірка2</td>\n        <td> РЯДОК5 комірка3</td>\n      </tr>\n      <tr>\n        <td>РЯДОК6комірка1</td>\n        <td> РЯДОК6 комірка2</td>\n        <td> РЯДОК6 комірка3</td>\n      </tr>\n    </table>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Запустивши код на виконання, отримаємо сторінку «Сторінка-табель успішності»:"
              },
              {
                type: "image",
                src: "/images/imageTable.png",
                alt: "Сторінка-табель успішності"
              },
              {
                type: "paragraph",
                text: "Не вистачає виділення таблиці. Скористаємося атрибтом **border** – «рамка». Замість оголошення початку таблиці **<table>** поставимо **<table border=\"2\">**. Спробуємо, що у нас вийшло – запустимо змінений код:"
              },
              {
                type: "image",
                src: "/images/imageTableBorder.png",
                alt: "Зображення таблиці з рамкою"
              },
              {
                type: "paragraph",
                text: "Структура таблиці визначена. Спробуємо наповнити її змістом. Перший рядок визначає назву колонок. Визначимо його так:"
              },
              {
                type: "code",
                code: "<tr>\n  <td><b>НАЗВА ПРЕДМЕТУ</b> </td>\n  <td><center><b><i>  ОЦІНКА</i>  </b></center></td>\n  <td><center><b><i>БАЛ РЕЙТИНГУ</i>  </b></center></td>\n</tr>"
              },
              {
                type: "paragraph",
                text: "Згадали, **<b>** – виділення напівжирним тексту, **<i>** – похилим, **<center>** – центрування. П’ять наступних рядків таблиці заповнимо назвами предметів та їх оцінюванням. Продемонструємо це на прикладі одного предмета – інформатика."
              },
              {
                type: "code",
                code: "<tr>\n  <td> ІНФОРМАТИКА</td>\n  <td><center> ВІДМІННО </center></td>\n  <td><center><b>12</b></center></td>\n</tr>"
              },
              {
                type: "paragraph",
                text: "Після відповідних змін наш код прийме вигляд:"
              },
              {
                type: "code",
                code: "<html>\n  <meta charset=\"UTF-8\">\n  <head>\n    <title>Сторінка-табель успішності</title>\n  </head>\n  <body>\n    <strong>  Хочу навчитися працювати із таблицями засобами HTML !!!      </strong>\n    <br>\n    <em>  ТАБЕЛЬ УСПІШНОСТІ </em> \n    <table border=\"2\"> \n      <tr>\n        <td><b>НАЗВА ПРЕДМЕТУ</b> </td>\n        <td><center><b><i>ОЦІНКА</i>  </b></center></td>\n        <td><center> <b><i>БАЛ РЕЙТИНГУ</i></b></center></td>\n      </tr>\n      <tr>\n        <td>ІНФОРМАТИКА</td>\n        <td><center>ВІДМІННО</center></td>\n        <td> <center><b>12</b></center></td>\n      </tr>\n      <tr>\n        <td> МАТЕМАТИКА </td>\n        <td><center>ВІДМІННО</center></td>\n        <td> <center><b>11</b></center></td>\n      </tr>\n      <tr>\n        <td> УКР.МОВА  </td>\n        <td><center> ДОБРЕ </center></td>\n        <td> <center><b>9 </b></center></td>\n      </tr>\n      <tr>\n        <td> АНГ.МОВА </td>\n        <td><center>ВІДМІННО</center></td>\n        <td> <center><b>12</b></center></td>\n      </tr>\n      <tr>\n        <td  rowspan=\"3\" width=\"150\"> ФІЗКУЛЬТУРА  </td>\n        <td height=\"50\"><center>ВІДМІННО</center></td>\n        <td> <center><b>12</b></center></td>\n      </tr>\n    </table>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Запустивши цей код на виконання, отримаємо сторінку із таблицею:"
              },
              {
                type: "image",
                src: "/images/imageTableLast.png",
                alt: "Зображення таблиці"
              },
              {
                type: "paragraph",
                text: "Мова HTML має ще багато спеціальних атрибутів маніпулювання із рядками, стовпцями, комірками і текстовим наповненням таблиці. Всіх їх ми не зможемо розглянути. Наголосимо тільки на атрибутах зміни розміру таблиці загалом та окремих комірок таблиці. Атрибути **width** – ширина і **height** – висота, вивчені нами раніше, застосовні і до тегів **<table>**, **<tr>** і **<td>**. У цьому випадку відстані можна задавати не тільки у пікселях, а й у процентах. Розглянемо їх застосування на прикладі нашої останньої таблиці. Давайте побавимося із розмірами та кольорами. Вперед!!!"
              },
              {
                type: "paragraph",
                text: "Для цього внесемо такі зміни в код:"
              },
              {
                type: "code",
                code: "<html>\n  <meta charset=\"UTF-8\">\n  <head>\n    <title>Сторінка-табель успішності</title>\n  </head>\n  <body> \n    <strong>  Хочу навчитися працювати із таблицями засобами HTML !!!      </strong>\n    <br>\n    <em>    ТАБЕЛЬ УСПІШНОСТІ  </em> \n    <table  bgcolor=\"yellow\" border=\"4\" width=\"30%\" height=\"200\">\n      <tr>\n        <td> <b> <font size=\"+0\"  color=\"red\" >НАЗВА ПРЕДМЕТУ</font>  </b> </td>\n        <td><center><b><font size=\"+2\" color=\"green\" >ОЦІНКА</font></b></center></td>\n        <td><center> <b><i> <font size=\"+1\"  color=\"blue\" > БАЛ РЕЙТИНГУ </font></i></b></center></td>\n      </tr>\n      <tr>\n        <td> ІНФОРМАТИКА   </td>\n        <td><center>ВІДМІННО</center></td>\n        <td> <center><b>12</b></center></td>\n      </tr>\n      <tr>\n        <td> МАТЕМАТИКА </td>\n        <td><center>ВІДМІННО</center></td>\n        <td> <center><b>11</b></center></td>\n      </tr>\n      <tr>\n        <td>УКР.МОВА</td>\n        <td><center> ДОБРЕ </center></td>\n        <td> <center><b>9 </b></center></td>\n      </tr>\n      <tr>\n        <td>АНГ.МОВА</td>\n        <td><center>ВІДМІННО</center></td>\n        <td> <center><b>12</b></center></td>\n      </tr>\n      <tr>\n        <td  rowspan=\"3\" width=\"150\">ФІЗКУЛЬТУРА</td>\n        <td height=\"50\"><center>ВІДМІННО</center></td>\n        <td> <center><b>12</b></center></td>\n      </tr>\n    </table>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Запустивши код на виконання, отримаємо таблицю, представлену на рисунку 3.14."
              },
              {
                type: "image",
                src: "/images/image106.png",
                alt: "Рис. 3.14. Зображення заповненої таблиці"
              },
              {
                type: "subheading",
                text: "Посилання"
              },
              {
                type: "paragraph",
                text: "Як ми вже зазначали на початку цього розділу, основою навігації у вебі є поняття гіпертексту на основі використання спеціальних маркерів, що дістали назву посилань. Посилання забезпечують переходити з однієї веб-сторінки на іншу та доступ до файлів будь-якого типу, які розміщуються в різних місцях, наприклад, на іншому сайті. Файл має бути відкритий до доступу із зовнішнього середовища. Гіперпосилання – це слово, речення, картинка або дещо інше, при натисканні на які вам відкриється інша частина документа (сторінка). Веб-посилання (html-посилання) - спеціальний тег, який забезпечує перехід з однієї веб-сторінки на іншу або надає можливість створення контексту (змісту) сторінки. Ініціалізація посилання відбувається наведенням на нього маркера мишки і натисканням її лівої клавіші. Запуск веб-посилання може призвести в залежності від значень відповідних атрибутів до: переходу з однієї веб-сторінки на іншу; створення листа е-пошти; запуску програми та інше. Веб-посиланням може бути якась виділена кольором частина тексту або рисунку, або навіть рисунок. Текст-посилання має синій колір та підкреслення лінією (традиційне налаштування за замовчуванням). При наведенні на нього маркера «мишки», маркер змінює вигляд - перетворюється на руку, а саме посилання на сторінку змінює колір з синього на фіолетовий (за замовчуванням)."
              },
              {
                type: "paragraph",
                text: "Для створення посилання використовується тег **<a>**. Загальний синтаксис створення посилань наступний:"
              },
              {
                type: "code",
                code: "<a href=\"URL\"> текст посилання </a>."
              },
              {
                type: "paragraph",
                text: "Атрибут **href** визначає URL (Universal Resource Locator, універсальний покажчик ресурсу), іншими словами, адресу документа, на який слід перейти, а вміст контейнера **<a>** є посиланням. В якості універсального покажчика ресурсу може бути: адреса веб-сторінки, на яку потрібно перейти; шлях і назва файлу на комп'ютері, на який потрібно перейти; шлях і назва файлу на інтернетівському ресурсі, де розміщене зображення (рисунок), на який потрібно перейти. Посилання, зазначені в атрибуті **href**, можуть бути двох типів: абсолютні (**https://uk.wikipedia.org/wiki/Трапеція**) і відносні (**name.html**)."
              },
              {
                type: "paragraph",
                text: "Відносні зорієнтовані на вірне використання файлової структури документів на вашому компі або веб-сайті. Для приведеного прикладу сторінка **name.html** повинна бути в тій самій папці, що й код сторінки з якої посилаються."
              },
              {
                type: "paragraph",
                text: "Атрибут **target** визначає спосіб відкриття документа. По замовчуванню сторінка завантажується в тій самій вкладці браузера. Якщо ж надати атрибуту значення **target=\"_blank\"**, то сторінка завантажиться в новій вкладці. Наприклад, наберіть код:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n    <title>Посилання на сторінці</title>\n  </head>\n  <body>\n    <p><a href=\"https://uk.wikipedia.org/wiki/Трапеція\" target=\"_blank\">Перейти до Вікіпедії</a> \n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Запустіть на виконання та спробуйте натиснути: Перейти до Вікіпедії. Атрибут **title** задає спливаючу підказку, яка відображається при наведенні. Посилання в HTML мають три стани:"
              },
              {
                type: "list",
                items: [
                  "не відвідане посилання (по замовчуванню, синій текст з підкресленням),",
                  "відвідане посилання (пурпурний колір з підкресленням),",
                  "активне посилання (затиснена клавіша миші над посиланням)."
                ]
              },
              {
                type: "paragraph",
                text: "Подивимося, як використовувати зазначені атрибути і теги на практиці."
              },
              {
                type: "paragraph",
                text: "1. **Створення гіпертекстового документа.** Для створення гіпертекстових посилань у документі (сторінці, сайті) використовуються внутрішні закладки, які дістали назву «якорів». Традиційно закладками (певним іменем) позначають місця на сайті, до яких потрібно швидко переміщатись, і зміст розтягнутий по вертикалі та містить багато тексту і зображень."
              },
              {
                type: "paragraph",
                text: "У потрібному місці потрібно вказати закладку, надавши їй унікальне ім'я за допомоги атрибуту **id**. Наприклад, закладку з ім’ям «Розділ_1» можна створити так:"
              },
              {
                type: "code",
                code: "<a id=\"rozdil_1\">Розділ 1</a>"
              },
              {
                type: "paragraph",
                text: "Після цього створюється зміст цього розділу. Далі створюємо закладку для другого розділу і формуємо текст розділу і т.д. В кінці документу (сторінки) формуємо посилання на створені закладки:"
              },
              {
                type: "code",
                code: "<a href=\"#rozdil_1\">Прочитайте розділ 1</a>\n<a href=\"#rozdil_2\">Прочитайте розділ 2</a>\n…                                                      \n<a href=\"#rozdil_N\">Прочитайте розділ N</a>."
              },
              {
                type: "paragraph",
                text: "або посилання на закладку з іншої сторінки:"
              },
              {
                type: "code",
                code: "<a href=\"http://.../links.html#rozdil_1\">Прочитайте розділ 1</a>."
              },
              {
                type: "paragraph",
                text: "Приклад створення двох закладок приводиться тут:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n    <title>Закладки на сторінці</title>\n  </head>\n  <body>\n    <p><a id=\"rozdil_1\">Розділ 1</a>\n    <center>  \n      <h3> <font color=\"blue\"> Ми виходимо у всесвітню павутину !!!!!!</font>   </h3>\n    </center>\n    <br>\n    <div align=\" justify \"><font size=\"-1\"> Менe звати <em>  Андрійко </em>,     це моя 6-та    сторінка! </div >\n    <p align=\"justify\">\n      <font size=\"+3\"> Я вчуся програмуванню. Наразі вивчаю початки веб- програмування. </p>\n    <p> <font size=\"+6\">Хочу знайти друзів-однодумців, що мають подібне бажання. </p>\n    <p>   <font size=\"+0\"  color=\"red\">Планую сформувати групу для об-говорення спірних питань. Приєднуйтеся!!! </font>       </p>\n    <p><a id=\"rozdil_2\">Розділ 2</a>\n      <strong>  Хочу познайомити світ із моїм дідусем!!! </strong>\n      <br>\n      Ось його фото!\n      <img src= \"https://noospherescience.com/images/uploads/event_user/1/1a41a06d03dd03629e1df6748aa17796/629a8596e8eca940daadd39fb6960d36.jpg\">\n\n    <p><a href=\"#rozdil_1\">Прочитайте розділ 1</a>\n    <p><a href=\"#rozdil_2\">Прочитайте розділ 2</a>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Спробуйте зробити щось подібне своє та перевірити."
              },
              {
                type: "paragraph",
                text: "2. **Веб-посилання у вигляді рисунка.** Посиланням корисно робити і зображення (фото, рисунок). Синтаксичне оформлення такого посилання подібно до текстів:"
              },
              {
                type: "code",
                code: "<a href=\"https://scholar.google.com.ua/citations?user=R8D6c4EAAAAJ&hl=uk\">  <img src= https://noospherescience.com/images/uploads/event_user/1/1a41a06d03dd03629e1df6748aa17796/629a8596e8eca940daadd39fb6960d36.jpg/> </a>"
              },
              {
                type: "paragraph",
                text: "Наступна сторінка демонструє його застосування. Посилання з фото дідуся веде на нову сторінку."
              },
              {
                type: "code",
                code: "<html>\n  <meta charset=\"UTF-8\">\n  <head>\n    <title>Моя 8-а сторінка</title>\n  </head>\n  <body>\n    <strong>  Хочу познайомити світ із моїм дідусем!!! </strong>\n    <br>\n    Ось його фото! \n    <a href=\"https://scholar.google.com.ua/citations?user=R8D6c4EAAAAJ&hl=uk\">  <img src= https://noospherescience.com/images/uploads/event_user/1/1a41a06d03dd03629e1df6748aa17796/629a8596e8eca940daadd39fb6960d36.jpg/> </a>\n  </body>\n</html>"
              },
              {
                type: "subheading",
                text: "Рухомий рядок"
              },
              {
                type: "paragraph",
                text: "Іноді, для звернення уваги, нам потрібно на сторінці відобразити рух тексту. Це можна зробити, скориставшись тегом **<marquee>**. Якщо помістити в нього текст, тоді він буде на сторінці рухатися. Можна задавати різні варіанти скролінга. Скролінг - форма подання інформації, при якій вміст (текст, зображення) рухається у вертикальному або горизонтальному напрямку. Виділяють три типи скролінгу: лінійний або «звичайний» (об'єкти, що рухаються, з'являються у одного краю екрана і зникають у іншого), циклічний (об'єкт, зникнувши з одного краю, з'являється в іншого), відскакуючий (об'єкт, дійшовши до краю екрану, змінює напрямок руху на протилежне)."
              },
              {
                type: "paragraph",
                text: "Тип скролінга задається за допомоги атрибуту **behavior**. Він може приймати значення: **alternate** – коливальні рухи від краю до краю, **scroll** – лінійний, **slide** – циклічний із зупинкою."
              },
              {
                type: "paragraph",
                text: "Атрибут **scrollamount** приймає значення від 1 до 10 і визначає швидкість прокрутки. Атрибут **loop** задає кількість прокруток. Для визначення напряму руху використовується атрибут **direction**: **up** - угору, **down** - униз, **left** - вліво, **right** - вправо."
              },
              {
                type: "paragraph",
                text: "Зауважимо, що з текстом рухомого рядка можна робити все те, що можна робити зі звичайним текстом (змінювати розмір, колір, стиль, шрифт, зробити фразу із рядка посиланням), використовуючи потрібні атрибути всередині тега **<marquee>**."
              },
              {
                type: "code",
                code: "<html>\n<meta charset=\"UTF-8\">\n<head>\n<title>Моя 10-та сторінка</title>\n</head>\n<body text=\"green\" bgcolor=\"yellow\">\n    <div align=\"center\"><h2>Рухомі рядки</h2></div>  \n    <center><h3> <font color=\"blue\"> <marquee>Рухома стрічка по замовченню. Ми виходимо у всесвітню паутину!!!!!!</marquee></font>\n    </h3></center>\n    <br>\n    <div align=\" justify \"><font size=\"-1\"><marquee direction=\"right\">РР зліва-направо. Менe звати <em>  Андрійко </em>, це моя 6-та        сторінка!</marquee>   </div >\n    <p align=\"justify\">\n        <font size=\"+3\"> <marquee behavior=\"alternate\">РР, що рухається від краю до краю. Я вчуся програмуванню. Наразі вивчаю початки веб-програмування. </marquee></p>\n    <p> <font size=\"+6\"><marquee scrollamount=\"10\" direction=\"right\" loop=\"3\">РР із швидкістю 5 тільки 3 рази.   Хочу знайти друзів-однодумців.</marquee>  </p>\n    <p>       <font size=\"+10\"  color=\"red\"> <marquee    direction=\"up\">РР із рухом знизу до верху. Приєднуйтеся!!! </marquee>  </font>\n\n    </p>\n    <p> <font size=\"+5\"  bgcolor=\"#b40000\"> <marquee behavior=\"slide\" direction=\"down\">РР із зупинкою. До зустрічі у віртуальному світі!!! </marquee>  </font>\n\n    </p>\n</body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Запустивши цей фрагмент тексту на виконання у браузері, отримаємо нове форматування попереднього тексту, відображене на рисунку 3.13."
              },
              {
                type: "subheading",
                text: "Заголовок <!DOCTYPE>"
              },
              {
                type: "paragraph",
                text: "Існує спеціальний засіб повідомлення браузера про стандарт, відповідно до якого була написана сторінка. Існує декілька стандартів:\nHTML 3.2 (www.w3.org/TR/REC-html32), HTML 4.0 (www.w3.org/TR/REC-html40-971218), HTML 4.01 (www.w3.org/TR/html401), HTML5 (www.w3.org/TR/html5)."
              },
              {
                type: "paragraph",
                text: "Заголовок **<!DOCTYPE>**, який ставиться перед тегом **<html>**, указує тип документа - **DTD** (document type definition), тобто повідомляє браузер, згідно яких стандартів потрібно обробляти сторінку. Існує чотири основні варіанти його використання:"
              },
              {
                type: "list",
                items: [
                  "**<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">** - (жорсткий DTD), подальша веб-сторінка має дотримуватися специфікації HTML 4.01 і не використовувати «небажані» теги і атрибути та фрейми;",
                  "**<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">** - (перехідний синтаксис HTML), подальша веб-сторінка має дотримуватися специфікації HTML 4.01, але може використовувати «небажані» теги;",
                  "**<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">** - повідомляє, що в оформленні веб-сторінки приймають участь фрейми;",
                  "**<!DOCTYPE html>** - позначає використання специфікації HTML 5."
                ]
              }
            ]
          },
          {
            id: 4, 
            title: "Створення графіки за допомогою елемента HTML Canvas",
            content: [
              {
                type: "heading",
                text: "Створення графіки за допомогою елемента HTML Canvas"
              },
              {
                type: "paragraph",
                text: "Можливості JavaScript не обмежуються роботою з текстом і числами. Також можна писати код для малювання картинок за допомогою HTML-елемента canvas, який являє собою щось на зразок чистого полотна або аркуша паперу. Ви можете малювати на цьому «полотні» практично все що завгодно: креслити лінії, контури, виводити текст - меж немає, крім вашої уяви!"
              },
              {
                type: "paragraph",
                text: "Canvas - елемент HTML5, що використовується для створення растрового двомірного зображення за допомоги скрипта на мові JS. Найбільше використовується для побудови графіків залежностей і малювання поля у браузерних іграх. У цьому випадку завантажується не рисунок, а набір точок (алгоритм відмальовки), за яким браузер відмальовує рисунок (капчу). Робоча група по вебу, гіпертексту, застосункам і технологіям (Web Hypertext Application Technology Working Group) WHATWG пропонує використовувати canvas як стандарт створення графіки в нових поколіннях веб-застосунків."
              },
              {
                type: "paragraph",
                text: "Перевагами canvas є зручність роботи із значним числом елементів, використання апаратного прискорення, можливість маніпулювання із окремим пікселем і значна кількість бібліотек підтримки. До недоліків відносять значне завантаження процесора і оперативної пам’яті, погану можливість очистки пам’яті, потребу власної обробки подій із об’єктами, необхідність відмалювання окремо кожного елемента."
              },
              {
                type: "paragraph",
                text: "Розглянемо детальніше використання цього елемента."
              },
              {
                type: "subheading",
                text: "Створюємо «полотно»"
              },
              {
                type: "paragraph",
                text: "Перш ніж почати роботу з елементом canvas, створіть новий HTML-документ з наступним кодом і збережіть його у файлі canvas.html:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n<head>\n\t<title>Canvas</title>\n</head>\n<body>\n\t<canvas id=\"canvas\" width=\"200\" height=\"200\"></canvas>\n\t<script>\n\t\t// Тут буде JavaScript-код\n\t</script>\n</body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Як бачите, ми створили елемент canvas, давши атрибуту id значення «canvas», щоб потім звертатися до нього за допомогою цього id. Атрибути width і height задають ширину і висоту «полотна» - в даному випадку його розмір 200 × 200 пікселів."
              },
              {
                type: "subheading",
                text: "Малювання на «полотні»"
              },
              {
                type: "paragraph",
                text: "Тепер, коли у нас є сторінка з елементом canvas, спробуємо за допомогою JavaScript-коду намалювати на «полотні-прямокутнику» квадрат."
              },
              {
                type: "paragraph",
                text: "Введіть наступний код в файл canvas.html між тегів <script>:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.fillRect(0, 0, 10, 10);"
              },
              {
                type: "paragraph",
                text: "Що ж задають ці команди?"
              },
              {
                type: "paragraph",
                text: "Насамперед знаходимо елемент canvas за допомогою **document.getElementById(\"canvas\")**. Метод **getElementById** повертає об'єкт DOM для елемента з вказаним id. Тому збережемо цей об'єкт у змінній з ім'ям **canvas**:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById ( \"canvas\");"
              },
              {
                type: "paragraph",
                text: "Тепер потрібно отримати контекст малювання для елемента canvas. Контекст малювання - це JavaScript-об'єкт, який володіє методами і властивостями, за допомогою яких можна малювати на «полотні». Щоб отримати цей об'єкт, ми викликаємо для canvas метод **getContext**, передаючи йому рядок \"2d\", – це означає, що ми збираємося сформувати на «полотні» двомірне зображення. Збережемо контекст у змінній **ctx** за допомогою команди:"
              },
              {
                type: "code",
                code: "var ctx = Canvas.getContext ( \"2d\");"
              },
              {
                type: "paragraph",
                text: "І нарешті, в останньому рядку ми малюємо на «полотні» рівносторонній прямокутник (тобто квадрат), викликаючи метод контексту малювання **fillRect**, який приймає чотири аргументи: це x- і y-координати верхнього лівого кута квадрата (0, 0), а також його ширина і висота (10, 10). У цьому випадку ми просимо JavaScript намалювати прямокутник 10 × 10 пікселів в координатах (0, 0) - тобто в верхньому лівому кутку «полотна»."
              },
              {
                type: "paragraph",
                text: "Запустивши код:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n<head>\n\t<title>Canvas</title>\n</head>\n<body>\n\t<canvas id=\"canvas\" width=\"200\" height=\"200\"></canvas>\n\t<script>\n\t\t// JavaScript-код\n\t\tvar canvas = document.getElementById(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tctx.fillRect(0, 0, 10, 10);\n\t</script>\n</body>\n</html>"
              },
              {
                type: "paragraph",
                text: "ви повинні побачити на екрані чорний квадратик, як на рисунку 3.15."
              },
              {
                type: "image",
                src: "/images/square.png",
                alt: "Рис. 3.15. Малюнок “квадрат” на “полотні”"
              },
              {
                type: "subheading",
                text: "Малюємо кілька квадратів"
              },
              {
                type: "paragraph",
                text: "Тепер спробуємо дещо більш цікаве. Замість малювання єдиного квадратика зобразимо в циклі безліч квадратів, розташованих по діагоналі. Замініть код в нашому документі між тегами <script> наступним кодом:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nfor (var i = 0; i < 8; i++) {\n\tctx.fillRect(i * 10, i * 10, 10, 10);\n}"
              },
              {
                type: "paragraph",
                text: "Запустивши його, ви повинні побачити вісім чорних квадратиків (рисунок 3.16):"
              },
              {
                type: "image",
                src: "/images/image108.png",
                alt: "Рис. 3.16. Створення декількох квадратиків за допомогою циклу for"
              },
              {
                type: "paragraph",
                text: "Перші два рядки коду залишаються незмінними. У третьому рядку ми задаємо цикл, який повторюється вісім разів. У тілі цього циклу ми викликаємо метод контексту малювання **fillRect**."
              },
              {
                type: "paragraph",
                text: "Х і Y координати лівого верхнього кута кожного з квадратів вираховуються на основі значення змінної циклу **i**. При першому повторі циклу, коли **i = 0**, координатами квадрата є (0, 0), оскільки **0 × 10 = 0**. Тому, команда **ctx.fillRect (i * 10, i * 10, 10, 10)** намалює квадрат зі стороною 10 пікселів в координатах (0, 0). Це лівий верхній квадрат на рисунку."
              },
              {
                type: "paragraph",
                text: "Другий повтор циклу, коли **i = 1**, відповідає координатам (10, 10), оскільки **1 × 10 = 10**. На цей раз команда **ctx.fillRect (i * 10, i * 10, 10, 10)** намалює квадрат, починаючи з координат (10, 10), проте розмір його сторін буде як і раніше дорівнювати 10 пікселям (адже аргументи для ширини і висоти залишаються колишніми). Це другий зверху квадрат на рисунку."
              },
              {
                type: "paragraph",
                text: "Оскільки при кожному повторі циклу **i** збільшується на 1, координати x і y кожен раз збільшуються на 10 пікселів, а розмір сторони залишається рівним 10. В ході решти шести повторів будуть намальовані шість нижніх квадратів."
              },
              {
                type: "subheading",
                text: "Вибір кольору"
              },
              {
                type: "paragraph",
                text: "За замовчуванням при виклику **fillRect** JavaScript малює чорний квадрат. Щоб змінити колір, потрібно змінити у контексті малювання властивість **fillStyle**. Після того як **fillStyle** прийме значення нового кольору, наступні фігури будуть малюватися цим кольором до тих пір, поки ви знову не зміните значення **fillStyle**. Найпростіший спосіб задати колір для **fillStyle** - привласнити йому назву кольору у вигляді рядка. Наприклад:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.fillStyle = \"Red\";\nctx.fillRect(0, 0, 100, 100);"
              },
              {
                type: "paragraph",
                text: "У рядку «**ctx.fillStyle = \"Red\";**» ми вказуємо контексту малювання, що з цього моменту все, що малюється, має бути червоним (Red). Якщо запустити цей код, на екрані з'явиться яскраво-червоний квадрат, як на рис. 3.17."
              },
              {
                type: "image",
                src: "/images/image109.png",
                alt: "Рис. 3.17. Червоний квадрат"
              },
              {
                type: "paragraph",
                text: "JavaScript розуміє англійські назви понад 100 кольорів, наприклад Green, Blue, Orange, Red, Yellow, Purple, White, Black, Pink, Turquoise, Violet, SkyBlue, PaleGreen і ін. Повний список можна знайти на сайті CSS-Tricks: http://css-tricks.com/snippets/css/named-colors-and-hex-equivalents/"
              },
              {
                type: "subheading",
                text: "Створення контурів прямокутників"
              },
              {
                type: "paragraph",
                text: "Метод **fillRect** малює заповнені прямокутники. Добре, якщо саме це вам і потрібно, але іноді потрібно зобразити лише контур прямокутника, так, ніби він обведений ручкою або олівцем. Для цього призначений метод **strokeRect**. Наприклад, якщо запустити наступний код:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.strokeRect(20, 20, 150, 50);"
              },
              {
                type: "paragraph",
                text: "на екрані з'явиться контур невеликого прямокутника (рис. 3.18):"
              },
              {
                type: "image",
                src: "/images/image110.png",
                alt: "Рис. 3.18. Контур прямокутника, намальований за допомогою методу strokeRect"
              },
              {
                type: "paragraph",
                text: "Метод **strokeRect** приймає ті ж аргументи, що і **fillRect**: x- і y-координати верхнього лівого кута, а потім ширина і висота прямокутника. В цьому випадку прямокутник зображений з відступом в 20 пікселів від лівого верхнього кута «полотна», ширина якого дорівнює 150 пікселів, а висота 50 пікселів. Змінити колір контуру можна за допомогою властивості **strokeStyle**, а щоб задати товщину лінії, потрібна властивість **lineWidth**."
              },
              {
                type: "paragraph",
                text: "Наприклад:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.strokeStyle = \"Green\";\nctx.lineWidth = 8;\nctx.strokeRect(20, 20, 150, 50);"
              },
              {
                type: "paragraph",
                text: "Тут в рядку **ctx.strokeStyle = \"Green\";** ми задали колір лінії Green (зелений), а в рядку **ctx.lineWidth = 8;** встановили ширину лінії 8 пікселя. Результат зображений на рис. 3.19."
              },
              {
                type: "image",
                src: "/images/image111.png",
                alt: "Рис. 3.19. Зелений контур прямокутника шириною 8 пікселя"
              },
              {
                type: "subheading",
                text: "Створення ліній або шляхів"
              },
              {
                type: "paragraph",
                text: "Шляхом називають послідовність ліній на «полотні». Щоб намалювати шлях на елементі canvas, потрібно задати x- і y-координати початку і кінця кожної зі складових ліній шляху. Використовуючи продумані комбінації початкових і кінцевих координат, можна малювати різні фігури. Наприклад, можна зобразити синій хрестик, показаний на рис. 3.20:"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.strokeStyle = \"Blue\";\nctx.lineWidth = 16;\nctx.beginPath();\nctx.moveTo(20, 20);\nctx.lineTo(80, 80);\nctx.moveTo(80, 20);\nctx.lineTo(20, 80);\nctx.stroke();"
              },
              {
                type: "image",
                src: "/images/image112.png",
                alt: "Рис. 3.20. Синій хрестик, намальований командами moveTo і lineTo"
              },
              {
                type: "paragraph",
                text: "У рядках **ctx.strokeStyle = \"Blue\";** і **ctx.lineWidth = 16;** ми задали колір лінії і її товщину. У рядку **ctx.beginPath();** ми викликаємо для контексту малювання (який зберігається в **ctx**) метод **beginPath**, який визначає початок малювання нового шляху. У рядку **ctx.moveTo(20, 20);** виклик методу **moveTo** c двома аргументами – координатами x і y призводить до того, що наше віртуальне JavaScript-перо відривається від «полотна» і, не залишаючи за собою сліду, переміщається в точку з цими координатами."
              },
              {
                type: "paragraph",
                text: "Щоб намалювати лінію, ми викликаємо в рядку **ctx.lineTo(80, 80);** метод **lineTo** з координатами x і y. В результаті віртуальне перо опускається на «полотно» і, рухаючись до заданих координат, накреслює за собою лінію. В цьому випадку ми малюємо лінію з точки (20, 20) в точку (80, 80) - це діагональ, що йде від верхнього лівого кута «полотна» до його нижнього правого кута, яка є першою лінією нашого хрестика. У рядку **ctx.moveTo(80, 20);** ми знову викликаємо **moveTo**, встановлюючи нову позицію для малювання, і в рядку **ctx.lineTo(20, 80);** викликаємо **lineTo**, щоб накреслити лінію з (80, 20) в (20, 80). Ця діагональ, що йде з верхнього правого кута «полотна» в нижній лівий кут, завершуючи фігуру."
              },
              {
                type: "paragraph",
                text: "Однак, ми лише описали те, що збираємося намалювати, а «полотно» як і раніше порожнє. Тому в рядку **ctx.stroke();** ми викликаємо метод **stroke**, завдяки якому фігура нарешті з'являється на екрані."
              },
              {
                type: "subheading",
                text: "Заливка шляхів кольором"
              },
              {
                type: "paragraph",
                text: "Ми вже знайомі з методом для малювання прямокутних контурів **strokeRect**, методом **fillRect** для малювання заповнених кольором прямокутників, а також методом **stroke** для обведення шляхів. Еквівалентом **fillRect** для шляхів є метод **fill**. Якщо вам потрібно заповнити замкнутий шлях кольором, а не просто обвести його, використовуйте **fill** замість **stroke**. Наприклад, наступний код малює будинок червоного кольору, обведений синім контуром (рис. 3.21):"
              },
              {
                type: "code",
                code: "var canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.strokeStyle = \"Blue\";\nctx.lineWidth = 16;\nctx.fillStyle = \"Red\";\nctx.beginPath();\nctx.moveTo(100, 100);\nctx.lineTo(100, 60);\nctx.lineTo(130, 30);\nctx.lineTo(160, 60);\nctx.lineTo(160, 100);\nctx.lineTo(100, 100);\nctx.fill();\nctx.stroke();"
              },
              {
                type: "image",
                src: "/images/image113.png",
                alt: "Рис. 3.21. Будинок, створений за допомогою методу fill"
              },
              {
                type: "paragraph",
                text: "Розберемо код. Встановивши синій колір малювання контуру, ми встановлюємо червоний колір заповнення замкнутого контуру, а потім задаємо шлях контуру за допомогою **beginPath**, а потім методом **moveTo** пересуваємо точку початку малювання в позицію (100, 100). Далі ми п'ять разів (По разу для кожного кута будиночка) викликаємо **lineTo** з різними наборами координат. Останній з викликів **lineTo** замикає шлях, повертаючись до первісної точки (100, 100)."
              },
              {
                type: "paragraph",
                text: "На рис. 3.22 показаний той же самий будиночок з підписаними значеннями координат."
              },
              {
                type: "image",
                src: "/images/image114.png",
                alt: "Рис. 3.22. Координати точок будинку"
              },
              {
                type: "paragraph",
                text: "І нарешті, в рядку **ctx.fill();** викликом **fill** ми заповнили шлях обраним раніше червоним кольором, а командою **ctx.stroke()** заповнили синім кольором контур."
              },
              {
                type: "subheading",
                text: "Малювання ламаної за масивом точок"
              },
              {
                type: "paragraph",
                text: "Напишемо функцію **drawPoints**, яка приймає масив з координатами точок:"
              },
              {
                type: "code",
                code: "var points = [[50, 50], [50, 100], [100, 100], [100, 50], [50, 50]];\ndrawPoints(points);"
              },
              {
                type: "paragraph",
                text: "і малює лінію, яка з'єднує ці точки, тобто вона має накреслити лінію від (50, 50) до (50, 100) і далі до (100, 100), до (100, 50) і назад до (50, 50). Потім передамо в цю функцію наступний масив:"
              },
              {
                type: "code",
                code: "var mysteryPoints = [[50, 50], [50, 100], [25, 120], [100, 50],[70, 90],[100, 90], [70, 120]];"
              },
              {
                type: "paragraph",
                text: "(в **points[0][0]** знаходиться перша х-координата, а в **points[0][1]** перша y-координата) та повторимо малювання **drawPoints(mysteryPoints)**."
              },
              {
                type: "paragraph",
                text: "Тоді запустивши на виконання наступний код:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n<head>\n\t<title>Canvas</title>\n</head>\n<body>\n\t<canvas id=\"canvas\" width=\"200\" height=\"200\"></canvas>\n\t<script>\n\tvar canvas = document.getElementById(\"canvas\");\n\tvar ctx = canvas.getContext(\"2d\");\n\tvar drawPoints = function (points) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(points[0][0], points[0][1]);\n\t\tfor (var i = 1; i < points.length; i++) {\n\t\t\tctx.lineTo(points[i][0], points[i][1]);\n\t\t}\n\t\tctx.stroke();\n\t};\n\tvar mysteryPoints = [[50, 50], [50, 100], [25, 120], [100, 50], [70, 90], [100, 90], [70, 120]];\n\tdrawPoints(mysteryPoints);\n\t</script>\n</body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Отримаємо зображення, представлене на рисунку 3.23."
              },
              {
                type: "image",
                src: "/images/image115.png",
                alt: "Рис. 3.23. Ламана"
              },
              {
                type: "paragraph",
                text: "Розглянута техніка малювання прямокутника та ламаних ліній дозволяє створювати і складніші зображення."
              },
              {
                type: "paragraph",
                text: "Наприклад, намалюємо «веселого чоловічка» (рис. 3.24) за допомогою методів **beginPath, moveTo, lineTo** і **stroke**. Зобразити голову (це квадрат 20 × 20 пікселів з шириною лінії 4 пікселя) можна методом **strokeRect**. Після, визначимося із координатами перетину та довжинами ламаних. Цей малюнок використовується в"
              },
              {
                type: "image",
                src: "/images/image116.png",
                alt: "Рис. 3.24. Веселий чоловічок"
              },
              {
                type: "paragraph",
                text: "багатьох навчальних посібниках і дістав назву «шибениця». Заключний код прийме вигляд:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n<head>\n\t<title>Шибениця</title>\n</head>\n<body>\n\t<canvas id=\"canvas\" width=\"200\" height=\"200\"></canvas>\n\t<script>\n\tvar canvas = document.getElementById(\"canvas\");\n\tvar ctx = canvas.getContext(\"2d\");\n\tvar drawSegment = function () {\n\t\tctx.lineWidth = 4;\n\t\tctx.strokeRect(20, 20, 20, 20);\n\t\tctx.beginPath();\n\t\tctx.moveTo(30, 40);\n\t\tctx.lineTo(30, 80);\n\t\tctx.stroke();\n\t\tctx.beginPath();\n\t\tctx.moveTo(30, 80);\n\t\tctx.lineTo(10, 110);\n\t\tctx.stroke();\n\t\tctx.beginPath();\n\t\tctx.moveTo(30, 80);\n\t\tctx.lineTo(50, 110);\n\t\tctx.stroke();\n\t\tctx.beginPath();\n\t\tctx.moveTo(30, 60);\n\t\tctx.lineTo(10, 50);\n\t\tctx.stroke();\n\t\tctx.beginPath();\n\t\tctx.moveTo(30, 60);\n\t\tctx.lineTo(50, 50);\n\t\tctx.stroke();\n\t};\n\tdrawSegment();\n\t</script>\n</body>\n</html>"
              },
              {
                type: "subheading",
                text: "Створення дуг і кіл"
              },
              {
                type: "paragraph",
                text: "Крім прямих ліній на «полотні» можна малювати дуги і кола - для цього призначений метод **arc**. Щоб зобразити коло, потрібно задати його центр і радіус (відстань від центру до контуру), а також вказати, яку частину кола потрібно намалювати, задавши початковий і кінцевий кут. Таким чином, можна намалювати як повне коло, так і його частину – дугу."
              },
              {
                type: "paragraph",
                text: "Початковий і кінцевий кути вимірюються в радіанах. Повне коло починається з кута 0 (від його правого краю) і триває до кута π × 2 радіан. Тобто, щоб намалювати повне коло, потрібно передати методу arc кути 0 і π × 2. На рисунку 3.25 показане коло з підписаними значеннями кутів у радіанах, а також у градусах. Як 360 °, так і π × 2 радіан відповідають повному колу."
              },
              {
                type: "image",
                src: "/images/image117.png",
                alt: "Рис. 3.25. Градуси і радіани, які беруть відлік від правого краю кола за годинниковою стрілкою"
              },
              {
                type: "paragraph",
                text: "Наступний код малює на екрані половину кола і повне коло, як показано на рисунку 3.26."
              },
              {
                type: "code",
                code: "<body>\n<canvas id=\"canvas\" width=\"300\" height=\"200\" style=\"border-style:  solid;\"></canvas>\n<script type=\"text/javascript\">\n\tvar canvas = document.getElementById('canvas');\n\tvar ctx = canvas.getContext('2d');\n\tctx.lineWidth = 8;\n\tctx.strokeStyle = \"Blue\";\n\tctx.beginPath();\n\tctx.arc(125, 50, 30, 0, Math.PI, false);\n\tctx.stroke();\n</script>\n</body>"
              },
              {
                type: "image",
                src: "/images/image118.png",
                alt: "Рис. 3.26. Малюнок половини кола"
              },
              {
                type: "subheading",
                text: "Половина кола"
              },
              {
                type: "paragraph",
                text: "Створюємо половину кола. При виклику методу **arc** в рядку **ctx.arc(125, 50, 30, 0, Math.PI, false);** ми вказали центр в точці (125, 50). Радіус дорівнює 30 пікселям, і починаємо малювати з кута в 0 радіан, проте кінцевий кут тепер дорівнює **Math.PI**, що відповідає половині кола. В якості останнього аргументу ми вказали **false** – це означає, що дугу потрібно малювати за годинниковою стрілкою. Якщо вам знадобиться малювати проти годинникової стрілки - передайте останнім аргументом **true**."
              },
              {
                type: "paragraph",
                text: "Початковий і кінцевий кути показані на рисунку 3.27."
              },
              {
                type: "image",
                src: "/images/image119.png",
                alt: "Рис. 3.27. Початковий і кінцевий кути половини кола"
              },
              {
                type: "subheading",
                text: "Створення декількох кіл за допомогою функцій"
              },
              {
                type: "paragraph",
                text: "Якщо потрібно малювати тільки повні кола, метод **arc** доволі складний для використання: кола завжди малюють від 0 до π × 2 радіан (360 градусів), а напрям (за годинниковою стрілкою або проти) не має значення. Крім того, щоб зобразити коло на екрані, кожен раз доведеться викликати **ctx.beginPath** перед методом **arc** і **ctx.stroke** після нього. Тому має сенс написати функцію, яка дозволяє малювати кола, не заглиблюючись в деталі, а вказуючи лише значення x, y і радіус."
              },
              {
                type: "code",
                code: "var circle = function (x, y, radius) {\n\tctx.beginPath();\n\tctx.arc(x, y, radius, 0, Math.PI * 2, false);\n\tctx.stroke();\n};"
              },
              {
                type: "paragraph",
                text: "У тілі функції ми відразу ж викликаємо **ctx.beginPath**, вказуючи цим, що збираємося створити шлях. Потім викликаємо метод **ctx.arc**, передаючи йому значення аргументів x, y і radius. Як і раніше, ми використовуємо 0 для початкового і **Math.PI * 2** для кінцевого кутів, а також **false** для малювання за годинниковою стрілкою. Тепер за допомогою цієї функції можна зобразити будь-яку кількість кіл, задаючи лише координати їх центрів і радіуси. Наприклад, наступний код малює набір різнокольорових кіл одне в одному:"
              },
              {
                type: "code",
                code: "<body>\n<canvas id=\"canvas\" width=\"300\" height=\"200\" style=\"border-style: solid;\"></canvas>\n\n<script type=\"text/javascript\">\n\tvar canvas = document.getElementById('canvas');\n\tvar ctx = canvas.getContext('2d');\n\n\tvar circle = function (x, y, radius,fillCircle) {\n\t\tctx.beginPath();\n\t\tctx.arc(x, y, radius, 0, 2 * Math.PI, false);\n\t\tif (fillCircle) {\n\t\t\tctx.fill();\n\t\t} else {\n\t\t\tctx.stroke();\n\t\t}\n\t};\n\n\tctx.lineWidth = 4;\n\tctx.strokeStyle = \"Red\";\n\tcircle(100, 100, 10);\n\tctx.strokeStyle = \"Orange\";\n\tcircle(100, 100, 20);\n\tctx.strokeStyle = \"Yellow\";\n\tcircle(100, 100, 30);\n\tctx.strokeStyle = \"Green\";\n\tcircle(100, 100, 40);\n\tctx.strokeStyle = \"Blue\";\n\tcircle(100, 100, 50);\n\tctx.strokeStyle = \"Purple\";\n\tcircle(100, 100, 60);\n\n</script>\n</body>"
              },
              {
                type: "paragraph",
                text: "Результат представлений на рисунку 3.28. Спочатку ми задаємо ширину лінії - 4 пікселя. Потім встановлюємо **strokeStyle** в Red (червоний колір) і викликаємо функцію **circle**, щоб намалювати коло в точці (100, 100) з радіусом 10 пікселів. Це центральне червоне кільце."
              },
              {
                type: "image",
                src: "/images/image120.png",
                alt: "Рис. 3.28. Кольорові кола, створені за допомогою функції circle"
              },
              {
                type: "paragraph",
                text: "Таким же чином ми малюємо помаранчеве коло - координати залишаються колишніми, але радіус тепер дорівнює 20 пікселям. Потім жовте коло - знову там же, але з радіусом 30 пікселів. Три останні кола (зелене, синє і фіолетове) також мають загальний центр, а їх радіуси послідовно зростають."
              },
              {
                type: "paragraph",
                text: "Комбінуванням різних кіл окремим вмістом можна отримувати потрібні змістовні зображення. Наприклад, давайте напишемо код, який малює сніговика (рисунок 3.29)."
              },
              {
                type: "image",
                src: "/images/image121.png",
                alt: "Рис. 3.29. Зображення сніговика"
              },
              {
                type: "paragraph",
                text: "Згідно техніки попередньої вправи, створимо для малювання сніговика функцію **drawSnowman**, яка малює сніговика шляхом малювання двох кіл різного радіуса і наповнення у зазначеній позиції на «полотні» так, щоб в результаті виклику **drawSnowman(50, 50)** сніговик з'явився в позиції (50, 50) «полотна». Для цього трішки підправимо нашу функцію **circle** та її виклик. Відповідний код приводиться тут:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title>Canvas snowman</title>\n\t</head>\n\n\t<body>\n\t\t<canvas id=\"canvas\" width=\"200\" height=\"200\" style=\"border-style: solid;\"></canvas>\n\n\t\t<script type=\"text/javascript\">\n\t\t\tvar canvas = document.getElementById('canvas');\n\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\t\n\t\t\tvar circle = function (x, y, radius,fillCircle) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, radius, 0, 2 * Math.PI, false);\n\t\t\t\tif (fillCircle) {\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else {\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tvar drawSnowman = function (x, y) {\n\t\t\t\tctx.fillStyle = \"Black\";\n\t\t\t\tctx.lineWidth = 4;\n\t\t\t\t\n\t\t\t\tcircle(x + 50, y + 110, 40, false);\n\t\t\t\tcircle(x + 50, y + 40, 30, false);\n\t\t\t\tcircle(x + 40, y + 35, 5, true);\n\t\t\t\tcircle(x + 60, y + 35, 5, true);\n\t\t\t\t\n\t\t\t\tcircle(x + 50, y + 90, 5, true);\n\t\t\t\tcircle(x + 50, y + 110, 5, true);\n\t\t\t\tcircle(x + 50, y + 130, 5, true);\n\t\t\t\t\n\t\t\t\tctx.fillStyle = \"Orange\";\n\t\t\t\tcircle(x + 50, y + 45, 5, true);\n\t\t\t};\n\t\t\t\n\t\t\tdrawSnowman(0, 0);\n\t\t\tdrawSnowman(100, 20);\n\t\t</script>\n\t</body>\n</html>"
              }
            ]
          }
        ]
      },
      {
        id: 3,
        title: "Декілька складніших прикладів",
        topics: [
          {
            id: 1,
            title: "Анімація тексту",
            content: [
              {
                type: "heading",
                text: "Анімація тексту"
              },
              {
                type: "paragraph",
                text: "Ми навчимося працювати зі стрічками і зробимо цікавий ефект анімації тесту \"хвилькою\"."
              },
              {
                type: "paragraph",
                text: "Для початку зробимо заготовку html-сторінки:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <title>Анімація тексту</title>\n  </head>\n  <body>\n    // TODO: implement\n    <script language=\"JavaScript\">\n      // TODO: implement\n    </script>\n  </body>\n</html>"
              },
              {
                type: "subheading",
                text: "Модуль HTML-компонента"
              },
              {
                type: "paragraph",
                text: "У цьому прикладі ми використовуватимемо дуже мало розмітки, нам потрібна лише форма з полем вводу, в яке ми будемо вставляти наш текст просто для зручності роботи."
              },
              {
                type: "code",
                code: "<form name=\"wow\">\n  <input type=\"text\" name=\"display\" size=\"22\">\n</form>"
              },
              {
                type: "paragraph",
                text: "Тут назва форми **wow** і єдине поле вводу з явно заданим розміром шрифту **size=22**."
              },
              {
                type: "subheading",
                text: "Модуль JS-компонента"
              },
              {
                type: "paragraph",
                text: "В результаті ми хочемо зробити таку анімацію:\nTEXT\ntEXT\nTeXT\nTExT\nTEXt.\nЗверніть увагу на розмір літер у слові text. Таким чином ми пропонуємо реалізувати «анімацію». Тобто, при достатньо швидкій зміні рядка у користувача складатиметься враження, що по слову «проходить хвилька», яка зменшує розмір літери."
              },
              {
                type: "paragraph",
                text: "Проініціалізуємо змінні:"
              },
              {
                type: "code",
                code: "// лічильник циклу\nvar count = -1; \n// лічильник часу\nvar counter;\n// частота оновлення\nvar frequency = 1/100;"
              },
              {
                type: "paragraph",
                text: "В явному вигляді ми не будемо використовувати **frequency**. Тобто, ми застосовуватимемо період оновлення тексту, а не частоту, однак оскільки звичніше оперувати частотою (часто чуємо «кадри за секунду»), то період оновлення задаватимемо як 1 / **frequency**."
              },
              {
                type: "paragraph",
                text: "Зробимо декілька зауваг відносно регістрів. Регістр літери визначає її вигляд - вона велика (верхнього регістру) або мала (нижнього регістру). Саме перемикач регістру, клавіша Shift, визначає вигляд літери при наборі. Тому саме з цим регістром ми і будемо працювати:"
              },
              {
                type: "code",
                code: "// текст для відображення\nvar text = \"Анімація Тeксту\";\nvar uppercasedText = text.toUpperCase(); /*буде \"АНІМАЦІЯ ТЕКСТУ\" (великі літери) */\nvar lowercasedText = text.toLowerCase();  /*буде \"анімація тексту\" (малі літери) */"
              },
              {
                type: "paragraph",
                text: "Тут ми використовуємо дві функції: **toUpperCase();** та **toLowerCase();**. Перша приводить будь-який рядок у верхній регістр (читаємо «робить всі літери великими»), а друга – навпаки у нижній («робить всі літери маленькими»)."
              },
              {
                type: "paragraph",
                text: "Задекларуємо головну функцію **capswitch()**, що не приймає параметрів:"
              },
              {
                type: "code",
                code: "// головна функція\nfunction capswitch() {\n  // TODO: implement\n}"
              },
              {
                type: "paragraph",
                text: "На кожному кроці функції ми будемо збільшувати лічильник, щоб за ним орієнтуватись, яку саме літеру заміняти на літеру з нижнього регістру. Щойно лічильник зрівняється з довжиною рядка, ми повернемо його на початок (-1)."
              },
              {
                type: "code",
                code: "// головна функція\nfunction capswitch() {\n  count++; \n  // TODO: implement\n  if(count == text.length){\n    count = -1;\n  }\n}"
              },
              {
                type: "paragraph",
                text: "Тепер згадаймо оператор switch:"
              },
              {
                type: "code",
                code: "switch(value)\n{\n  case 'a':\n    // зробити щось для 'a'\n    break;\n  case 'b':\n    // зробити щось для 'b'\n    break;\n  default:\n    // зробити щось для default\n    break;\n}"
              },
              {
                type: "paragraph",
                text: "Зауважимо, що вкінці інструкцій для кожного **case** треба писати **break**, інакше після завершення виконання одного **case**, програма почне виконувати інструкції для наступного. Інколи саме так і треба зробити за логікою програми, але зазвичай потрібно не забувати про **break**. Також, завжди потрібно писати **default**, якщо ми не передбачили всі можливі значення **value**. У нашому випадку їх безліч, тому ми і не можемо цього зробити. Інколи його пишуть порожнім, щоб сторонній розробник не подумав, що про нього забули. Тому нерідко можна зустріти **default: break; // intentionally nothing**."
              },
              {
                type: "paragraph",
                text: "Повертаємося до нашої задачі. Тут використання **switch** дуже підходить. Маємо три випадки: якщо лічильник 0 – покажемо всі великі літери, якщо 1 – малу і решту великих, в іншому випадку великі і малу (за номером лічильника) та решту великих."
              },
              {
                type: "paragraph",
                text: "Так і запрограмуємо:"
              },
              {
                type: "code",
                code: "switch(count)\n{\n  case 0:\n    document.wow.display.value = uppercasedText;\n    break;\n  case 1:\n    document.wow.display.value = lowercasedText.substring(0, 1) + uppercasedText.substring(1, text.length);\n    break;\n  default:\n    var textToDisplay = uppercasedText.substring(0, count - 1) + lowercasedText.substring(count - 1, count) + uppercasedText.substring(count, text.length);\n    document.wow.display.value = textToDisplay;\n    break;\n}"
              },
              {
                type: "paragraph",
                text: "Тут ми використовуємо функцію **substring()**, щоб взяти частину рядку, вказуючи параметри «від» і «до»."
              },
              {
                type: "paragraph",
                text: "Додамо повторне виконання функції **capswitch()**:"
              },
              {
                type: "code",
                code: "counter = setTimeout(\"capswitch()\", 1 / frequency);"
              },
              {
                type: "paragraph",
                text: "Та головне, потрібно не забути викликати **capswitch()** в кінці блоку **<script>**."
              },
              {
                type: "paragraph",
                text: "Відкриємо файл у браузері і... Ура, вийшло!"
              },
              {
                type: "image",
                src: "/images/image122.png",
                alt: "Зображення анімації тексту"
              },
              {
                type: "paragraph",
                text: "Далі буде..."
              }
            ]
          },
          {
            id: 2,
            title: "Створення свого календаря",
            content: [
              {
                type: "heading",
                text: "Створення свого календаря"
              },
              {
                type: "paragraph",
                text: "Наразі створимо власний простий календар, який можна легко інтегрувати у свій сайт."
              },
              {
                type: "paragraph",
                text: "Почнемо із заготовки сторінки:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <title>calendar</title>\n  </head>\n  <body>\n    <CENTER>\n      <script>\n        // TODO: implement\n      </script>\n    </CENTER> \n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Для цієї задачі не будемо використовувати статичні HTML-компоненти, натомість будемо динамічно створювати їх, дописуючи в DOM. Нагадаємо, що DOM об'єктна модель документа, тобто та сама розмітка HTML, але коли говоримо про DOM, то розглядаємо її з точки зору вкладених об'єктів, що формують дерево."
              },
              {
                type: "paragraph",
                text: "HTML-компонентом **<body>**, у нашому коді виступає єдиний тег **<center>**. Він вирівнює всі вкладені об'єкти так, щоб вони розміщувались по центру."
              },
              {
                type: "subheading",
                text: "Модуль JS-компонента"
              },
              {
                type: "paragraph",
                text: "Вся логіка нашого календаря полягає в тому, що ми будемо брати системний час і виокремлювати день та місяць, відображаючи відповідні картинки що їх позначають на сторінці."
              },
              {
                type: "paragraph",
                text: "Спочатку проініціалізуємо змінні для ресурсів. Візьмемо поточну дату:"
              },
              {
                type: "code",
                code: "var theDate= new Date();"
              },
              {
                type: "paragraph",
                text: "Проініціалізуємо ресурси для місяців:"
              },
              {
                type: "code",
                code: "var months = new Array();\nmonths[1] =\"jan.gif\";\nmonths[2] =\"feb.gif\";\n// ...\nmonths[12] =\"dec.gif\";"
              },
              {
                type: "paragraph",
                text: "і для днів:"
              },
              {
              type: "code",
              code: "var days = new Array();\ndays[1] =\"1.gif\";\ndays[2] =\"2nd.gif\";\n// ...\ndays[31] =\"31st.gif\";"
              },
              {
                type: "paragraph",
                text: "Запрограмуємо функцію **printDate()**, що створюватиме html-компоненти для нашого календаря:"
              },
              {
                type: "code",
                code: "function printDate()  \n/* беремо картинку для місяця відповідно до поточного місяця і генеруємо компонент */\n  document.write('<img src=\"' + months[theDate.getMonth()+1] + '\">');\n  // додаємо line break\n  document.write('<br>');\n  /* беремо картинку для дня відповідно до поточного дня і генеруємо компонент */\n  document.write('<img src=\"' + days[theDate.getDate()] + '\">');\n}"
              },
              {
                type: "paragraph",
                text: "Вкінці викликаємо нашу фунцію в **<script>*-тезі і перевіряємо. Після запуску коду отримаємо на сторінці зображення, представлене на рис. 3.30:"
              },
              {
                type: "image",
                src: "/images/image123.png", 
                alt: "Рис. 3.30. Зображення дня місяця календаря"
              },
              {
                type: "paragraph",
                text: "Отже, ми зробили свій календар і тепер його можна легко використовувати на власній сторінці."
              }
            ]
          },
          {
            id: 3,
            title: "Створення простого годинника",
            content: [
              {
                type: "heading",
                text: "Створення простого годинника"
              },
              {
                type: "paragraph",
                text: "Навчимося створювати простий цифровий годинник за допомоги JS. Для початку потрібно створити каркас компонента:"
              },
              {
                type: "code",
                code: "<html>\n  <head>\n    <title>My digital clock</title>\n  </head>\n  <body>\n    <!-- Тут буде візуальний компонент -->\n    <script Language=\"JavaScript1.1\">\n      // Тут буде логіка годинника\n    </script>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Зауважимо, що в html завантаження сторінки відбувається у кілька етапів і head завантажується швидше за body, тому важливо передбачити, як сторінку побачить користувач з повільним інтернетом. Загальне правило констатує – підключати css в head, а javascript в body. Тоді, у разі повільного підключення інтернету, користувач побачить компоненти тільки після того, як провантажились стилі, а за складної логіки javascript він зможе побачити вже красиву сторіночку навіть якщо програмна логіка ще не готова."
              },
              {
                type: "subheading",
                text: "Модуль html-компонента"
              },
              {
                type: "paragraph",
                text: "Наш годинник складатиметься з картинок цифр, представлених на рисунку 3.31."
              },
              {
                type: "image",
                src: "/images/image124.gif", 
                alt: "Рис. 3.31. Приклад зображення цифри"
              },
              {
                type: "paragraph",
                text: "Час будемо показувати в форматі **hh : MM : ss d**, де **hh** - години (12-годинний формат), **MM** – хвилини, **ss** – секунди, **d** - маркер am/pm для 12-годинного формату часу. Створимо в розмітці картинки для кожного компонента:"
              },
              {
                type: "code",
                code: "<img src=\"cb.gif\" name=\"a\">    <!-- H -->\n<img src=\"cb.gif\" name=\"b\">    <!-- H -->\n<img src=\"colon.gif\" name=\"c\">  <!-- : -->\n<img src=\"cb.gif\" name=\"d\">    <!-- M -->\n<img src=\"cb.gif\" name=\"e\">    <!-- M -->\n<img src=\"colon.gif\" name=\"f\">  <!-- : -->\n<img src=\"cb.gif\" name=\"g\">    <!-- s -->\n<img src=\"cb.gif\" name=\"h\">    <!-- s -->\n<img src=\"cam.gif\" name=\"j\">    <!-- d -->"
              },
              {
                type: "paragraph",
                text: "Тут **cb.gif** - це порожня картинка. Отримаємо результат, відображений на рис. 3.32."
              },
              {
                type: "image",
                src: "/images/image125.png",
                alt: "Рис. 3.32. Зображення порожньої картинки"
              },
              {
                type: "paragraph",
                text: "Для кожної картинки ми будемо брати ресурс за відповідною назвою (**a, b**, і т.д.). Тобто, вся логіка компонента «під капотом» полягатиме в правильному підборі картинок для відображення поточного часу."
              },
              {
                type: "paragraph",
                text: "Тепер перейдемо до цієї самої логіки компонента."
              },
              {
                type: "subheading",
                text: "Модуль javascript"
              },
              {
                type: "paragraph",
                text: "Визначимо змінні:"
              },
              {
                type: "code",
                code: "var dn;  // day/night (pm/am) \nvar c1 = new Image(); c1.src=\"c1.gif\""
              },
              {
                type: "paragraph",
                text: "Тут **c1** це ресурс, картинка з цифровою 1. На початку ініціалізуємо саму картинку, а потім присвоюємо їй конкретний ресурс. Зазначимо, що **dn** на початку неявно отримує значення **undefined**, тому потрібно бути обачним і у випадку неявної ініціалізації переконатися, що програма його правильно ініціалізує пізніше. Далі за аналогією:"
              },
              {
                type: "code",
                code: "var c2 = new Image(); c2.src=\"c2.gif\"\nvar c3 = new Image(); c3.src=\"c3.gif\"\nvar c4 = new Image(); c4.src=\"c4.gif\"\nvar c5 = new Image(); c5.src=\"c5.gif\"\nvar c6 = new Image(); c6.src=\"c6.gif\"\nvar c7 = new Image(); c7.src=\"c7.gif\"\nvar c8 = new Image(); c8.src=\"c8.gif\"\nvar c9 = new Image(); c9.src=\"c9.gif\"\nvar c0 = new Image(); c0.src=\"c0.gif\"\nvar cb = new Image(); cb.src=\"cb.gif\"\nvar cam = new Image(); cam.src=\"cam.gif\"\nvar cpm = new Image(); cpm.src=\"cpm.gif\""
              },
              {
                type: "paragraph",
                text: "Пізніше ми розглянемо, як покращити код і уникнути повторень. Однак слід підмітити, що така ініціалізація є максимально наочною. Створімо функцію **extract()**, що буде приймати на вхід години, хвилини, секунди та пору доби."
              },
              {
                type: "code",
                code: "function extract(h,m,s,type) {\n  // TODO: implement\n}"
              },
              {
                type: "paragraph",
                text: "Розглянемо випадок з годинами. Якщо маємо годину 0 - 9, то формат годин буде H, інакше для 10-12 маємо HH. Так і зробимо:"
              },
              {
                type: "code",
                code: "if (h <= 9) {\n  // картинка '0'\n  document.images.a.src=c0.src  \n  // картинка для години\n  document.images.b.src=eval(\"c\"+h+\".src\") \n} else {\n  // ділимо к-сть годин на 10 та округлюємо в меншу сторону\n  document.images.a.src=eval(\"c\"+Math.floor(h/10)+\".src\")\n  // беремо остачу від ділення годин на 10\n  document.images.b.src=eval(\"c\"+(h%10)+\".src\")\n}"
              },
              {
                type: "paragraph",
                text: "Справді, у нашому випадку не обов'язково ділити націло кількість годин на 10, можна просто написати 1, бо інших значень не буде для 10, 11 та 12. Однак написавши код таким чином, ми передбачаємо можливість покращення нашого годинника для відображення 24-годинного формату. Простими словами, його не треба буде переписувати. Аналогічно робимо і для хвилин, і для секунд. Отримаємо:"
              },
              {
                type: "code",
                code: "// хвилини\nif (m<=9) {\n  document.images.d.src=c0.src\n  document.images.e.src=eval(\"c\"+m+\".src\")\n} else {\n  document.images.d.src=eval(\"c\"+Math.floor(m/10)+\".src\")\n  document.images.e.src=eval(\"c\"+(m%10)+\".src\")\n}\n// секунди\nif (s<=9) {\n  document.g.src=c0.src\n  document.images.h.src=eval(\"c\"+s+\".src\")\n} else {\n  document.images.g.src=eval(\"c\"+Math.floor(s/10)+\".src\")\n  document.images.h.src=eval(\"c\"+(s%10)+\".src\")\n}"
              },
              {
                type: "paragraph",
                text: "Для маркера пори доби все ще простіше:"
              },
              {
                type: "code",
                code: "// маркер пори доби\ndocument.j.src = (dn==\"AM\") ? cam.src : cpm.src"
              },
              {
                type: "paragraph",
                text: "Тепер створимо функцію **showTime()**, яка буде брати системний час комп'ютера та подавати на вхід функції **extract()** вже у вигляді окремих компонентів."
              },
              {
                type: "code",
                code: "function showTime() {\n  // TODO: implement\n}"
              },
              {
                type: "paragraph",
                text: "Спершу візьмемо системний час покомпонентно:"
              },
              {
                type: "code",
                code: "// беремо системний час\nvar digitalTime = new Date()\n// ... покомпонентно\nvar hours = digitalTime.getHours()\nvar minutes = digitalTime.getMinutes()\nvar seconds = digitalTime.getSeconds()"
              },
              {
                type: "paragraph",
                text: "Наразі потрібно вирішити проблему з поданням 12 годин дня та 12 годин ночі в 12-годинному форматі незалежно від того, в якому форматі поверне нам час система. Попри наявність міжнародного стандарту ISO 8601, 12 годин ночі та 12 годин дня позначаються в різних країнах по-різному. Це пов'язано з тим, що в латинських словосполученнях лат. ante meridiem та лат. post meridiem слово «meridiem» означає «середина дня» чи «опівдні», і є неоднозначність у позначенні полудня: його можна позначити як «12 a.m.» («12 ante meridiem», чи «12 годин до середини дня»), так і «12 p.m.» («12 post meridiem», чи «12 годин після середини дня»). З іншого боку, опівночний час також можна позначити і як «12 p.m.» (12 post meridiem, 12 годин після [попередньої] середини дня) і як «12 a.m.» (12 ante meridiem, 12 годин до [наступної] середини дня)."
              },
              {
                type: "paragraph",
                text: "Ми візьмемо за основу міжнародний стандарт ISO 8601 та будемо позначати 12 годин ночі 12 AM, а 12 годин дня 12 PM. Запрограмуємо це:"
              },
              {
                type: "code",
                code: "var dn=\"AM\" \n// починаючи з 12 години дня \nif ( (hours>=12) && (minutes>=1) || (hours>=13) ) {\n  dn=\"PM\"\n  hours -= 12\n}\n// окремий випадок для півночі\nif (hours == 0) hours=12"
              },
              {
                type: "paragraph",
                text: "Залишилося викликати функцію **extract()**, яка відображає часові компоненти картинками:"
              },
              {
                type: "code",
                code: "// покажемо картинками\nextract(hours,minutes,seconds,dn)."
              },
              {
                type: "paragraph",
                text: "І насамкінець додаємо виклик функції **showTime()** щосекунди, щоб годинник «пішов»:"
              },
              {
                type: "code",
                code: "// оновлюємо щосекунди\nsetTimeout(\"showTime()\", 1000)."
              },
              {
                type: "paragraph",
                text: "Відкриємо нашу сторінку в браузері, отримаємо: Порожній компонент. Овва! Нічого не працює, все пропало! Насправді це очікуваний результат, адже ми тільки визначили функції, але не викликали жодну жодного разу. Додамо до документа виклик ф-ції на моменті, як щойно провантажиться наше body:"
              },
              {
                type: "code",
                code: "<body onload=\"showTime()\">"
              },
              {
                type: "paragraph",
                text: "Перезавантажимо сторінку і... вуаля, працює як годинник! Робочий компонент (рис.3.33)"
              },
              {
                type: "image",
                src: "/images/image126.png", 
                alt: "Рис.3.33. Зображення цифрового годинника"
              },
              {
                type: "paragraph",
                text: "Отже, ми зробили свій цифровий годинник (майже як в Київському метрополітені!) і вивчили багато нового про форматування часу та роботу з javascript."
              }
            ]
          },
          {
            id: 4,
            title: "Створення простого Drag&Drop функціоналу",
            content: [
              {
                type: "heading",
                text: "3.3.4. Створення простого Drag&Drop функціоналу"
              },
              {
                type: "paragraph",
                text: "Тут ми зробимо наголос на реалізацію технології Drag&Drop засобами JS, а також ознайомимось з js-подіями."
              },
              {
                type: "paragraph",
                text: "Спершу створимо каркас проекту:"
              },
              {
                type: "code",
                code: "<!DOCTYPE HTML>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Drag&Drop</title>\n  </head>\n  <body style=\"position: relative;\">\n    // TODO: implement\n    <script>\n      //TODO: implement\n    </script>\n  </body>\n</html>"
              },
              {
                type: "subheading",
                text: "HTML-компонент"
              },
              {
                type: "paragraph",
                text: "Для виконання нашого завдання нам достатньо лише одного елемента – це зображення м'яча. Саме ним ми будемо рухати по екрану."
              },
              {
                type: "code",
                code: "<img src=\"ball.gif\" style=\"cursor: pointer\" width=\"50\" height=\"50\" id=\"ball\" />"
              },
              {
                type: "paragraph",
                text: "Тут **style=\"cursor: pointer\"** робить курсор схожим на руку при наведенні на зображення, що дозволяє користувачу зрозуміти, що зображення можна рухати. **id=\"ball\"** задає ідентифікатор html-компонента, щоб його можна було однозначно знайти на сторінці. Хоча здається, – у цьому нема потреби, бо в нас і так один елемент, але при ускладненні логіки це стане в пригоді, навіть коли компонентів стане два (:"
              },
              {
                type: "subheading",
                text: "JS-компонент"
              },
              {
                type: "paragraph",
                text: "Створимо відсилку на об'єкт нашого м'яча за **id**."
              },
              {
                type: "code",
                code: "var ball = document.getElementById('ball');"
              },
              {
                type: "paragraph",
                text: "Запрограмуємо логіку, яка має спрацювати при натисненні на об'єкт. В JS для цього є спеціальні події (**events**). Ми використаємо спершу **onmousedown**, а тоді **onmousemove** та **onmouseup**:"
              },
              {
                type: "code",
                code: "// що робити при натисненні клавіші мишки на об'єкт\nball.onmousedown = function (e) {\n  // фіксуємо значення `this`\n  var self = this;\n  /*визначаємо абсолютну систему координат (відносно всього документа, а не якогось елемента) */\n  this.style.position = 'absolute';\n  // \"підсуваємо\" об'єкт, щоб правильно почати drag\n  moveAt(e);\n  // додаємо наш елемент\n  document.body.appendChild(this);\n  // додаємо його поверх всього іншого\n  this.style.zIndex = 1000;\n  // логіка руху об'єкта\n  function moveAt(e) {\n    // TODO: implement\n  }\n\n  // що робити при рухах мишки на об'єкті\n  document.onmousemove = function (e) {\n    moveAt(e);\n  }\n\n  // що робити при відпусканні клавіші мишки з об'єкту\n  this.onmouseup = function () {\n    document.onmousemove = self.onmouseup = null;\n  }\n}"
              },
              {
                type: "paragraph",
                text: "Кожній події ми присвоюємо функцію, яка буде щоразу на цю подію викликатись. На вхід функції щоразу подається відповідна подія (**event**). При натисканні клавіші мишки ми ініціалізуємо всю логіку **drag**."
              },
              {
                type: "paragraph",
                text: "В JS буває досить складно розібратись, де який **this** (указник на поточний об'єкт контексту), особливо коли маємо багато вкладених функцій. Це якраз наш випадок, тому фіксуємо **this** в **onmousedown**, записуючи в змінну **self**."
              },
              {
                type: "paragraph",
                text: "Також важливо, що ми рухаємо об'єкт по всьому документу HTML, а не по якійсь частині, тому варто явно задати це через **this.style.position = 'absolute';**."
              },
              {
                type: "paragraph",
                text: "При натисканні на об'єкт хочемо, щоб він під'їхав до курсора так, щоб став готовим до слідування за курсором, – додамо **moveAt(e)**. Ця функція ще не реалізована (це буде трішки пізніше), але можемо точно поки сказати, що в неї ми будемо передавати поточну подію **e**."
              },
              {
                type: "paragraph",
                text: "Додаємо елемент поверх всіх інших елементів в DOM, вказуючи велике значення **zIndex**. **zIndex** визначає, який з об'єктів буде відмальовуватись поверх іншого, якщо вони накладаються. Чим більше це значення, тим вище буде відмальовуватись об'єкт."
              },
              {
                type: "paragraph",
                text: "Задекларуємо функцію руху **moveAt()**."
              },
              {
                type: "paragraph",
                text: "Вкажемо, що при русі мишки ми рухаємо за нею об'єкт. Тут важливо, що **onmousemove** ми декларуємо відносно документа, а не відносно об'єкта, бо для руху об'єкта нам треба знати розміщення курсора відносно екрана, а не відносно нашого м'яча."
              },
              {
                type: "paragraph",
                text: "Укажемо, що при відпусканні нажатої клавіші мишки ми більше не будемо рухати об'єкт за курсором."
              },
              {
                type: "paragraph",
                text: "Запрограмуємо реалізацію функції **moveAt()**:"
              },
              {
                type: "code",
                code: "function moveAt(e) {\n  self.style.left = e.pageX - 25 + 'px';\n  self.style.top = e.pageY - 25 + 'px';\n}"
              },
              {
                type: "paragraph",
                text: "У ній ми беремо координати події (в нашому випадку це координати кінчика курсора) і вказуємо їх як координати нашого об'єкта. Однак тут є одна хитрість. **style.left** та **style.top** визначають координати лівого верхнього кута об'єкта, тому щоб курсор був посередині об'єкта під час руху, зміщуємо лівий верхній кут вліво і вверх на 25 пікселів (пам'ятаємо, що розміри м'яча 50.0 x 50.0)."
              },
              {
                type: "paragraph",
                text: "Насамкінець додамо **ondragstart**-подію, щоб нівелювати можливі сторонні ефекти при перетягуванні."
              },
              {
                type: "code",
                code: "ball.ondragstart = function () {\n  return false;\n};"
              },
              {
                type: "paragraph",
                text: "Це все, тепер ми можемо рухати м'ячем по сторінці!"
              }
            ]
          },
          {
            id: 5,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "1. Охарактеризуйте HTML (HyperText Markup Language) – описову мову розмітки гіпертексту.",
                  "2. Дайте визначення гіперпосилання.",
                  "3. Як встановити текстовий редактор Sublime Text (http://www.sublimetext.com/).",
                  "4. Створіть веб-сторінку з текстом «Добрий день».",
                  "5. Як створити \"макет\" сторінки в форматі HTML.",
                  "6. Охарактеризуйте теги елемента HTML: виділення абзацу, відкриття, закриття, контенту.",
                  "7. Охарактеризуйте атрибути тегів елемента HTML.",
                  "8. Приведіть приклад створення вкладених елементів.",
                  "9. Опишіть структуру повноцінного HTML-документа.",
                  "10. Створіть повноцінну веб-сторінку з інформацією про ваші хобі.",
                  "11. Розкажіть про засоби редагування тексту на веб-сторінці.",
                  "12. Модифікуйте веб-сторінку про ваші уподобання, застосувавши різні шрифти, вирівнювання та різні кольори для окремих абзаців сторінки.",
                  "13. Модифікуйте веб-сторінку про ваші уподобання, застосувавши різні стилі окремих абзаців сторінки і додавши до неї вашу улюблену світлину (фото), що зберігається на вашому компі.",
                  "14. Модифікуйте веб-сторінку про ваші уподобання, додавши до неї рисунок про предмет вашого хобі, що зберігається десь в Інтернеті.",
                  "15. Модифікуйте веб-сторінку про ваші уподобання, додавши до неї таблицю із заголовком «Час, виділений для хобі за тиждень» і колонками (стовпцями): № по порядку, назва уподобання, кількість годин. Заголовок, назви колонок і рядки таблиці мають мати різний колір фону і тексту та різні шрифти й розмір символів тексту.",
                  "16. Модифікуйте веб-сторінку про ваші уподобання, додавши до неї посилання із рисунку про предмет вашого хобі, яке забезпечить при відповідному виділенні рисунку на сторінці за допомоги маркера мишки, перехід на веб-сторінку, де зберігався раніше цей рисунок і приводився його опис в Інтернеті.",
                  "17. Модифікуйте веб-сторінку про ваші уподобання, зробивши декілька рядків сторінки рухомими.",
                  "18. Модифікуйте веб-сторінку про ваші уподобання, додавши до одного із елементів сторінки анімацію згідно методики, запропонованої в темі 'Анімація тексту'",
                  "19. Охарактеризуйте Canvas - елемент HTML5.",
                  "20. Як створюється початкове «полотно» Canvas в HTML.",
                  "21. Намалюйте «полотно» Canvas в HTML із структурним зображенням грузовика сніговика.",
                  "22. Як можна брати системний час і виокремлювати день та місяць, відображаючи відповідні картинки що їх позначають на веб-сторінці.",
                  "23. Запропонуйте вирішення проблеми з подання 12 годин дня та 12 годин ночі в 12-годинному форматі незалежно від того, в якому форматі поверне нам час система.",
                  "24. Яким чином реалізується технологія Drag&Drop засобами JS?"
                ]
              }
            ]
          }
        ]
      },
      {
        id: 4,
        title: "Каскадні таблиці стилів CSS",
        topics: [
          {
            id: 1,
            title: "Вступ до CSS", 
            content: [
              {
                type: "heading",
                text: "Вступ до CSS"
              },
              {
                type: "paragraph",
                text: "CSS (англ. Cascading Style Sheets – каскадні таблиці стилів) – формальна мова опису зовнішнього вигляду документа, написаного з використанням мов HTML і XHTML, але може також застосовуватися до будь-яких XML-документів. CSS застосовується для стилізації і верстки веб-сторінок з наголосом на зручність задання потрібних шрифтів, кольору, відстані між блоками, розділу контенту на колонки, анімації та інших декоративних елементів. Концепція каскадних таблиць стилів була запропонована Хоконом Віум Лі – норвезьким вченим і фахівцем в області інформаційних технологій. Він працював в той час на консорціум W3C."
              },
              {
                type: "paragraph",
                text: "Спочатку для створення веб-сторінок в основному використовувався HTML. З часом запити веб-програмістів зросли і виникла необхідність у створення спеціалізованої мови, яка б надала ширші можливості по дизайну сторінок і оптимізації, модифікації табличної верстки документа (методу із використанням тегу **<table>**). В HTML тільки за рахунок використання цього тегу можна точно розташувати елементи на сторінці. Дизайн веб-сторінки, стилізація і форматування створювався безпосередньо всередині HTML-документа. Це призводило до того, що HTML-код ставав неймовірно великим по довжині і для модифікації сайту доводилося опрацьовувати вручну кожну зі сторінок окремо."
              },
              {
                type: "paragraph",
                text: "Поява CSS була спрямована на усунення цих вад. Ми маємо використовувати HTML тільки як мову розмітки, призначену для структурування і впорядкування даних документа, а за допомоги засобів CSS додавати сторінкам привабливого вигляду – «шарму». Загально прийнятою є рекомендація заміни атрибутів типу **color, bgcolor, align** і HTML-теги **<table>** та **<font>** замінювати стилями CSS. Тобто HTML створює шаблон структури документа, а форму заповнення і заповнення заготовлених ніш (прикрашення) виконує CSS."
              },
              {
                type: "paragraph",
                text: "Засобів стандартного HTML, які допомагають краще описати вміст, часто не вистачає. Тоді на допомогу приходять модифікації мови розмітки, наприклад теги HTML5 типу **<header>, <nav>, <footer>**. Вони не впливають на зовнішній вигляд, але допомагають орієнтуватися у документі."
              },
              {
                type: "paragraph",
                text: "Документ зазвичай є текстовим файлом, який структурований за допомогою мови розмітки HTML, але можуть використовуватися й інші (SVG або XML). Подання документа користувачеві потребує його конвертацію в зрозумілу для користувача форму. Візуалізацію цього подання на екрані комп'ютера, проектора або принтера виконують браузери. Браузер застосовує CSS правила до документа, щоб зрозуміти, як він відображатиметься. CSS-правила формуються з набору властивостей, які мають значення, що встановлюють, як буде відображатися вміст (HTML) і селектора. Селектор (англ. Selects) вибирає елемент або елементи, до яких будуть застосовуватися змінені значення. Набір правил CSS, що містяться в таблиці стилів (англ. stylesheet), визначає вигляд веб-сторінки."
              },
              {
                type: "paragraph",
                text: "Розглянемо загальний формат каскадних таблиць стилів, правила їх створення і способи встановлення зв'язків з html-документом."
              },
              {
                type: "paragraph",
                text: "Структурно CSS задається наступним чином:"
              },
              {
                type: "code",
                code: "<Селектор> {\n\t<Атрибут стилю 1>: <значення атрибута>;\n\t<Атрибут стилю 2>: <значення атрибута>;\n\t...\n\t<Атрибут стилю N>: <значення атрибута>;\n}"
              },
              {
                type: "paragraph",
                text: "Селектором називається формальний опис елемента, або групи, до якого повинні бути застосовані описані правила стилю. Атрибутом стилю називається один з параметрів елемента веб-сторінки (в окремих випадках схожі з атрибутами тегів, але слід пам'ятати, що це різні речі)."
              },
              {
                type: "paragraph",
                text: "Розглянемо можливі види селекторів, способи їх опису та подання до html - документа. У таблиці 3.1 коротко приводяться основні конструкції."
              },
              {
                type: "image",
                src: "/images/imageTableCSS.png",
                alt: "Таблиця 3.1. Основні конструкції CSS"
              },
              {
                type: "paragraph",
                text: "Допускається створення однакових стилів, шляхом послідовного перерахування їх селекторів. Наприклад:\n**p, .classname, td strong {color: red}**. За такого визначення створюються три однакових стилі: перевизначення тега **<p>**, стильовий клас **classname** і комбінований стиль для тега **<strong>**, що знаходиться в рамках тега **<td>**."
              },
              {
                type: "subheading",
                text: "Зв'язок CSS і HTML"
              },
              {
                type: "paragraph",
                text: "Як уже згадувалося, бажаною є умова зовнішності CSS-файла, у відношенню до html-документа. Існує кілька способів такого закріплення («прив'язки») певного файлу стилів до конкретного документа. Найпростішим бачиться використання тега **<link>**, що знаходиться в рамках парного тега **<head>**:"
              },
              {
                type: "code",
                code: "<Head>\n  ...........\n  <Link rel = \"stylesheet\" type = \"text / css\" href = \"style.css\">\n</ Head>"
              },
              {
                type: "paragraph",
                text: "Атрибут **rel** вказує на тип підключення файлу, **type** - вказує MIME тип файлу, **href** - вказує шлях до файлу стилів. Також можна скористатися директивою **@import**, що знаходиться в рамках парного тега **<style>**:"
              },
              {
                type: "code",
                code: "<Head>\n  .............\n  <Style type = \"text / css\">\n  @import url (style.css)\n  </ Style>\n</ Head>"
              },
              {
                type: "paragraph",
                text: "Незважаючи на явну рекомендацію щодо розміщення стилю в окремих файлах, є можливість визначити таблицю стилів в рамках самого html-документа в середині парного тега **<style>**:"
              },
              {
                type: "code",
                code: "<Head>\n  .............\n  <Style type = \"text / css\">\n    p {color: red}\n    ..............\n  </ Style>\n</ Head>"
              },
              {
                type: "paragraph",
                text: "Тут таблиця стилів розташовується в тілі окремого тега: **<P style = \"color: red\"> ........ </ p>**."
              },
              {
                type: "paragraph",
                text: "Тому таке оформлення таблиці стилів називається внутрішнім. Внутрішні таблиці корисніші тим, що є невід'ємною частиною самого html-документа, тобто вигляд веб-сторінки не буде залежати від доступності зовнішньої таблиці стилів. Та цей підхід має і недоліки. Внутрішній стиль поширюється тільки на один веб-документ та застосування внутрішніх стилів суперечить загальній концепції про необхідність відділення структури документа від його представлення."
              },
              {
                type: "subheading",
                text: "Правила і каскадність CSS"
              },
              {
                type: "paragraph",
                text: "Отже, існує кілька способів завдання зв'язку між CSS і html-документом. До одного і того ж елементу веб - сторінки можуть призначатися кілька стилів (наприклад, в рамках самого елемента і у зовнішній таблиці стилів). При цьому фактичне відображення елемента регулюється правилами каскадності:"
              },
              {
                type: "list",
                items: [
                  "Зовнішня таблиця стилів, посилання на яку зустрічається в html - документі пізніше, має пріоритет по відношенню до зовнішньої таблиці стилів, посилання на яку зустрічається раніше.",
                  "Внутрішні таблиці стилів пріоритетніші зовнішніх.",
                  "Таблиці стилів, що розташовуються в рамках самого елемента (**<p style = \"...\">**), мають пріоритет, по відношенню до всіх інших стилів.",
                  "Більш конкретні стилі мають пріоритет перед менш конкретними (наприклад, **p.classname {...}** пріоритетніше **p {..}**), тобто стильовий клас пріоритетніший за перевизначення тега, комбінований клас пріоритетніший стильового.",
                  "У разі прив'язки до тегу кількох стильових класів, пріоритетнішими вважаються ті, що вказані правіше.",
                  "Атрибути стилю, оголошені як «**! Important**», мають пріоритет перед усіма іншими значеннями. Таким чином, стиль **p { color: red! important}** зробить весь текст в рамках тегів **<p>** червоним незалежно від будь-яких інших перевизначень стилю для **<p>**."
                ]
              },
              {
                type: "subheading",
                text: "Одиниці виміру в CSS"
              },
              {
                type: "paragraph",
                text: "При заданні значень атрибутів стилю в CSS можуть використовуватися різні одиниці виміру. Вони дозволяють точно контролювати розміри та положення елементів на веб-сторінці. Основні одиниці виміру:"
              },
              {
                type: "list",
                items: [
                  "**Пікселі (px)**: найчастіше використовувана абсолютна одиниця, відповідає одному пікселю на екрані.",
                  "**Пункти (pt)**: абсолютна одиниця, яка часто використовується в друкарні, 1pt = 1/72 дюйма.",
                  "**Дюйми (in)**: абсолютна одиниця, 1in = 96px.",
                  "**Сантиметри (cm)**: абсолютна одиниця, 1cm = 37.8px.",
                  "**Міліметри (mm)**: абсолютна одиниця, 1mm = 3.78px.",
                  "**Відсотки (%)**: відносна одиниця, яка базується на розмірі батьківського елемента або розмірі шрифту.",
                ]
              },
              {
                type: "paragraph",
                text: "Способи визначення значень кольору:"
              },
              {
                type: "list",
                items: [
                  "**колір (rgb)**: наприклад, `rgb(255, 0, 0)` для червоного.",
                  "**шістнадцятковий код (#rrggbb)**: наприклад, `#FF0000` для червоного.",
                  "**скорочений шістнадцятковий код (#rgb)**: наприклад, `#F00` для червоного.",
                ]
              },
              {
                type: "paragraph",
                text: "Константи задання розмірів шрифту:"
              },
              {
                type: "list",
                items: [
                  "xx-large",
                  "x-large",
                  "large",
                  "medium",
                  "small",
                  "x-small",
                  "xx-small",
                ]
              },
              {
                type: "subheading",
                text: "Робота з кольором і фоном"
              },
              {
                type: "paragraph",
                text: "Кольорове виділення інформації та фон, на якому вона розміщена, мабуть, перше, що кидається в очі при завантаженні веб-сторінки. За керування кольором і фоном в CSS відповідають такі атрибути стилів, підтримувані абсолютною більшістю елементів:"
              },
              {
                type: "list",
                items: [
                  "**color** – задає колір переднього плану ( **color: #00FF00**);",
                  "**background-color** – задає колір фону елемента (**background-color: brown**);",
                  "**background-image** – задає фонове зображення для елемента (**background-image: url(\"image.gif\")**);",
                  "**background-repeat** – задає тип повторення зображення, встановленого за допомогою атрибута стилю **background-image** (**background-repeat: no-repeat**), може набувати таких значень:\n  * **repeat-x** – зображення повторюється по горизонталі;\n  * **repeat-y** – зображення повторюється по вертикалі;\n  * **repeat** – зображення повторюється по горизонталі і вертикалі;\n  * **no-repeat** – зображення не повторюється (значення за замовчуванням).",
                  "**background-attachment** – визначає, чи буде фонове зображення прокручуватися разом з елементом (**background-attachment: fixed**), може набувати таких значень:\n  * **scroll** – зображення буде прокручуватися разом з елементом;\n  * **fixed** – прокрутка зображення заблокована.",
                  "**background-position** – визначення координат позиціонування фонового зображення, містить два значення: положення по горизонталі і положення по вертикалі (**background-position: 5cm 4cm**). Крім числових, може набувати таких значень:\n  * **left** – горизонтальне позиціонування «по лівому краю»;\n  * **center** – горизонтальне позиціонування «по центру»;\n  * **right** – горизонтальне позиціонування «по правому краю»;\n  * **top** – вертикальне позиціонування «зверху»;\n  * **center** – вертикальне позиціонування «по центру»;\n  * **bottom** – вертикально позиціонування «знизу»."
                ]
              },
              {
                type: "paragraph",
                text: "Можна задати всі атрибути стилю, що відносяться до фонового зображення, скориставшись короткою формою запису, наприклад:"
              },
              {
                type: "code",
                code: "background: #00FF00 url ( \"image.gif\" ) no-repeat fixed 5cm 4cm."
              },
              {
                type: "subheading",
                text: "Робота зі шрифтом"
              },
              {
                type: "paragraph",
                text: "Перед тим, як почати розгляд атрибутів стилів, призначених для управління шрифтами, зауважимо, що відображатися у користувача будуть тільки ті шрифти, які встановлені на його компу, тому рекомендується користуватися стандартним набором шрифтів при створенні сайту."
              },
              {
                type: "paragraph",
                text: "Атрибут стилю CSS **font-family** - задає сімейство використовуваного шрифту (**font-family: arial**). Для задання шрифту використовують два типи імен: ім'я сімейства (**family-name**) і родове ім'я (**generic family**). До імен сімейства відносяться, власне, назви шрифтів (**Camria, Arial** і т.п.). Кількість родових імен менша:"
              },
              {
                type: "list",
                items: [
                  "**serif** - шрифти із зарубками;",
                  "**sans-serif** - рубані шрифти;",
                  "**cursive** - курсивні шрифти;",
                  "**fantasy** - декоративні шрифти;",
                  "**monospace** - моноширинні шрифти."
                ]
              },
              {
                type: "paragraph",
                text: "Атрибут **font-style** - задає стиль шрифту (**font-style: normal**). Він може приймати значення:"
              },
              {
                type: "list",
                items: [
                  "**normal** - звичайний шрифт;",
                  "**italic** - курсивний шрифт;",
                  "**oblique** - похилий шрифт."
                ]
              },
              {
                type: "paragraph",
                text: "Атрибут **font-variant** - задає тип представлення малих літер (**font-variant: normal**). Набуває таких значень:"
              },
              {
                type: "list",
                items: [
                  "**normal** - малі літери представляються у вихідному регістрі;",
                  "**small-caps** - малі літери модифікуються в заголовні, але меншого розміру."
                ]
              },
              {
                type: "paragraph",
                text: "Атрибут **font-weight** - визначає насиченість шрифту (**font-weight: bold**). Набуває таких значень:"
              },
              {
                type: "list",
                items: [
                  "**normal** - стандартна насиченість шрифту;",
                  "**bold** - напівжирний шрифт."
                ]
              },
              {
                type: "paragraph",
                text: "Ряд браузерів підтримує числові значення насиченості шрифту в межах від 100 до 900, де 100 - світле насичення шрифту, 400 - стандартне, 700 - напівжирне."
              },
              {
                type: "paragraph",
                text: "Атрибут **font-size** - визначає розмір шрифту (**font-size: 12pt**). Може бути представлений у вигляді констант, абсолютних, або відносних значень."
              },
              {
                type: "paragraph",
                text: "Можна задати всі атрибути стилю, що відносяться до шрифту, скориставшись короткою формою запису, наприклад: **font: normal bold 10pt camria**."
              },
              {
                type: "paragraph",
                text: "Для уточнення описаного вище розглянемо такий приклад. Нехай для HTML- документа, що містить **<h1>** і **<p>**, потрібно застосувати таблицю стилів із використанням елемента **<link>**:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Перший експеримент із CSS</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n  </head>\n  <body>\n    <h1>Hello World!</h1>\n    <p>Це мій перший CSS-приклад</p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "А таблиця стилів складається із двох правил:"
              },
              {
                type: "list",
                items: [
                  "**h1 { color: blue; background-color: yellow; border: 1px solid black; };**",
                  "**p { color: red; }**."
                ]
              },
              {
                type: "paragraph",
                text: "Перше правило починається із селектора **h1**, що позначає застосування правила до елемента **<h1>**. У правилі задекларовано три властивості із значеннями. Властивість із значенням називають оголошенням. Перше оголошення міняє колір тексту на синій, друге визначає жовтий фон тексту, а третє – створює обрамлення тексту шириною 1 піксель типу solid чорного кольору. Друге правило починається із селектора **p** містить одне оголошення про заміну кольору тексту на червоний. Ці два правила стилю мають бути записані в **style.css** файл у тій же папці, де розміщений і HTML-код сторінки. Так можна підключити таблицю до всіх необхідних веб-сторінок, використовуючи тег **<link>** c атрибутом **rel** (визначає зв’язок між веб-сторінкою та файлом з потрібним стилем) і значенням **stylesheet**. Останнє означає, що в цьому файлі міститься таблиця стилів. Атрибут **href** – це шлях (URL) до файлу з розширенням **.css**."
              },
              {
                type: "paragraph",
                text: "Приведений документ в браузері відобразиться так:"
              },
              {
                type: "image",
                src: "/images/cssExample.png", 
                alt: "Зображення першого експерименту з CSS"
              },
              {
                type: "paragraph",
                text: "Уточнимо складові будь-якого стилю. Головним серед них є «селектор». Пишучи його, ми вказуємо браузеру місце розмітки, до якого саме хочемо застосувати стиль. У нашому випадку селектором є **h1** і **p**. Блоком оголошень називають весь вміст, що обмежується фігурними дужками «**{}**», які розміщуються після селектора. Для визначення бажаного варіанту форматування обраного фрагмента застосовується стильова властивість. Після імені властивості необхідно ставити двокрапку, яка відмежовує її від значення властивості, за допомоги яких і створюється власний стиль сторінки. Для кожної властивості є окремо визначений набір значень. Закінчення визначення властивості стилю позначає крапка з комою."
              },
              {
                type: "paragraph",
                text: "CSS не чутливий до перенесення рядків, пробілів, символів табуляції і регістру. Це дозволяє набирати код у вигляді зручному для читання. Та зловживати цим не бажано. Наприклад, одним із неписаних правил запису стилю є використання компактної форми запису. У ній всі властивості для одного селектора пишуться в одному блоці. Отже, до переваг використання CSS можна віднести:"
              },
              {
                type: "list",
                items: [
                  "централізоване управління відображенням безлічі документів за допомогою однієї таблиці стилів;",
                  "спрощений контроль зовнішнього вигляду веб - сторінок;",
                  "наявність розроблених дизайнерських технік;",
                  "можливість використання різних стилів для одного документа, в залежності від пристрою, за допомогою якого здійснюється доступ до веб - сторінці."
                ]
              },
              {
                type: "paragraph",
                text: "Та вибір форми запису стилю має обирати програміст – головне тут, щоб було легше орієнтуватися в коді. Для цього рекомендується записувати кожну властивість на новому рядку і використовувати табуляцію або пробіли при перерахуванні властивостей."
              },
              {
                type: "paragraph",
                text: "Для підсилення читабельності тексту використовуються коментарі до нього. Коментарі в CSS обмежуються символами «**/* »** і «**\*/»**. Вони не відображаються на веб-сторінці в браузері і тому часто використовуються для тимчасово незадіяної ділянки коду CSS при налаштуванні стилю."
              },
              {
                type: "paragraph",
                text: "Коли браузер відображає документ, він поєднує вміст документа з інформацією про стилі і обробляє документ у два етапи: Конвертує HTML і CSS в DOM (англ. Document Object Model). DOM представляє документ в пам'яті комп'ютера і застосовує до вмісту стилі. Відображає вміст DOM."
              },
              {
                type: "paragraph",
                text: "Об’єктно-орієнтована модель документа DOM має деревовидну структуру в якій кожний елемент, атрибут і фрагмент тексту мови розмітки утворюють вузол DOM. Співрозміщення цих вузлів в дереві визначає їх «родинні» взаємовідносини (батько, син, брат)."
              },
              {
                type: "paragraph",
                text: "Як ми вже зазначали, є три основні варіанти застосування CSS до HTML-документу: зовнішня таблиця стилів, внутрішня таблиця стилів, та вбудовані стилі. Поки що розглянемо їх на прикладах. Зовнішня таблиця стилів оформляється у вигляді окремого файлу з розширенням **.css**, в якому і розміщуються потрібні стилі. Розробник посилається на нього з HTML за допомогою елемента **<link>**. Ми вже розглядали цей варіант у прикладі. Перевага цього методу полягає у можливостях використання однієї таблиці стилів для декількох документів та модифікації стилю шляхом внесення змін лише в один CSS-файл."
              },
              {
                type: "paragraph",
                text: "У другому варіанті (внутрішня таблиця) таблиця стилів розміщується всередині елемента **<style>** тегу HTML «head». У цьому випадку HTML-код потрібно змінити ось так:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Перший експеримент із CSS</title>\n    <style>\n      h1 {\n        color: blue;\n        background-color: yellow;\n        border: 1px solid black;\n      }\n      p {\n        color: red;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>Hello World!</h1>\n    <p>Це мій перший CSS-приклад</p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Тобто, тут ми замінили стрічку: **<link rel=\"stylesheet\" href=\"style.css\">** на:"
              },
              {
                type: "code",
                code: "<style>\n  h1 {\n    color: blue;\n    background-color: yellow;\n    border: 1px solid black;\n  }\n  p {\n    color: red;\n  }\n</style>"
              },
              {
                type: "paragraph",
                text: "Внутрішню таблицю стилю корисно використовувати у випадках, коли неможливо міняти CSS-файли безпосередньо."
              },
              {
                type: "paragraph",
                text: "У третьому варіанті – вбудований стиль оформляється у вигляді оголошення CSS, яке може бути застосовано тільки до одного елементу, і міститься в атрибуті **style**. У цьому варіанті рівносильний HTML-код для цього прикладу прийме вигляд:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title> Перший експеримент із CSS </title>\n  </head>\n  <body>\n    <h1 style=\"color: blue;background-color: yellow;border: 1px solid   black;\">Hello World!</h1>\n    <p style=\"color:red;\">\n      Це мій перший CSS-приклад \n    </p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "Використання вмонтованого стилю не бажане. Використовуйте його тільки у крайньому випадку, наприклад, ви можете використовувати тільки HTML-редактор тексту. Змішання CSS і HTML робить код нечитабельним."
              }
            ]
          },
          {
            id: 2,
            title: "Особливості синтаксису",
            content: [
              {
                type: "heading",
                text: "Особливості синтаксису"
              },
              {
                type: "paragraph",
                text: "CSS є декларативною мовою з простим синтаксисом. Особливістю мови є нейтралізація помилок. Наявність помилки у фрагменті коду не призводить до поломки всього коду. Не розпізнані оголошення зазвичай просто ігноруються. Правда, це ускладнює пошук джерела помилки."
              },
              {
                type: "paragraph",
                text: "Структура мови CSS дуже проста. Властивості (properties) і їх значення (values) утворюють оголошення (declarations). Набори оголошень утворюють блоки оголошень (declaration blocks), а блоки оголошень разом з селекторами (selectors) утворюють правила CSS (rules CSS )."
              },
              {
                type: "paragraph",
                text: "Для позначення властивості використовуються ідентифікатори. При зіставленні CSS-властивості з конкретними значеннями CSS обчислює, які оголошення відносяться до кожного елементу сторінки окремо, щоб надати їй відповідний вигляд і стиль. Властивість і значення в кожній парі розділяються двокрапкою «:»."
              },
              {
                type: "paragraph",
                text: "Існує більше трьохсот різних властивостей і мало не нескінченна кількість значень. Для кожної властивості визначено певний список допустимих значень. У випадку, якщо властивості приписане недопустиме, то все оголошення вважається неприпустимим і повністю ігнорується двигунцем браузера."
              },
              {
                type: "paragraph",
                text: "Блок визначень обмежується фігурними дужками. Кожне визначення блоку відокремлюється крапкою з комою «;»."
              },
              {
                type: "paragraph",
                text: "Блоки іноді можуть бути вкладеними; в цьому випадку відкривають та закривають дужки повинні йти в логічному порядку, аналогічно тегам вкладених HTML-елементів. Блок оголошень може бути порожнім."
              },
              {
                type: "paragraph",
                text: "Для визначення до яких елементів застосовуються наші блоки оголошень використовуються селектори, які стоять перед відповідним блоком. Оголошення цього блоку будуть застосовуватися тільки до цих елементів. Селектор плюс блок декларацій називають набором правил, або просто правилом."
              },
              {
                type: "paragraph",
                text: "Ускладнюючи набори селекторів можливо створювати правила, що застосовуються відразу до кількох елементів, використовуючи в них списки розділених комами селектор (групу). Селектори можна об'єднувати в ланцюжки для уточнення елементів до яких вони будуть застосовуватися."
              },
              {
                type: "paragraph",
                text: "Елементу можна зіставити кілька селекторів, так що одна властивість може входити в безліч різних правил. CSS визначає, які правила мають пріоритет і повинні застосуватися: це називається алгоритмом каскадувания."
              },
              {
                type: "paragraph",
                text: "Якщо в ланцюжку або групі є хоча б один хибний селектор, що буває, наприклад, при використанні невідомого псевдо-елемента або псевдо-класу, то вся група селекторів залишається робочою, за винятком помилкового селектора, який буде ігноруватися."
              },
              {
                type: "paragraph",
                text: "Розрізняють наступні категорії селекторів: прості, селектори атрибути, псевдокласи, псевдоелементи, комбінатори, групові."
              },
              {
                type: "paragraph",
                text: "Прості селектори (Simple selectors) ідентифікують один або кілька елементів на підставі типу елемента, класу (class), або id елемента. Селектори атрибутів (Attribute selectors) вказують на один або кілька елементів на підставі їх атрибутів або значень атрибутів. Псевдокласи (Pseudo-classes) визначають один або кілька елементів на підставі їх знаходження в певному стані, наприклад ті, на які наведений курсор миші. Псевдоелементи (Pseudo-elements) виділяють одну або кілька частин вмісту сторінки, певним чином розташованих по відношенню до елементу: наприклад, останнє слово в кожному параграфі. Комбінатори самі по собі не є селекторами. Вони визначають спосіб об'єднання селекторів для вибору по декільком умовам одночасно. Наприклад, можна вибрати тільки ті параграфи, які є прямими нащадками елементів div або які слідують відразу за заголовком. Групи селектор (Multiple selectors) дозволяють застосовувати в одному CSS-правилі кілька селекторів, відокремивши їх один від одного комами – тоді відповідний набір оголошень застосовується відразу до всіх елементів, на які вказують ці селектори."
              },
              {
                type: "paragraph",
                text: "CSS-правила є одним з типів так званих CSS-конструкцій (CSS statements). Серед конструкцій важливе місце займають At-правила (At-rules). Вони використовуються для передачі метаданих, умовної інформації або інших описів. At-правила починаються з символу (@), за яким слідує ідентифікатор, який вказує, до якого виду належить це правило, потім деякий синтаксичний блок, який закінчується крапкою з комою (;). Кожен тип at-правила, що визначається цим ідентифікатором, має свій власний синтаксис і семантику. наприклад:"
              },
              {
                type: "list",
                items: [
                "@charset і @import (metadata)",
                "@media або @document (умовна інформація, її ще називають вкладеними конструкціями)",
                "@ font-face (описова інформація)"
                ]
              },
              {
                type: "paragraph",
                text: "Наприклад, at-правило:"
              },
              {
                type: "paragraph",
                text: "**@import 'custom.css';** - імпортує зовнішній файл CSS в поточний. Ще один розповсюджений тип конструкцій – вкладені конструкції. Це підмножина at-правил, у яких є вкладений блок CSS-правил, що будуть застосовуватися до документа тільки при наявності певної умови:"
              },
              {
                type: "list",
                items: [
                "Вміст правила **@media** застосовується тільки якщо пристрій, що управляє браузером, відповідає встановленій умові;",
                "Вміст правила **@supports** застосовується тільки якщо браузер дійсно підтримує цю функцію;",
                "Вміст правила **@document** застосовується тільки якщо поточна сторінка задовольняє певним умовам."
                ]
              },
              {
                type: "code",
                code: "@media (min-width: 801px) {\n\tbody {\n\t\tmargin: 0 auto;\n\t\twidth: 800px;\n\t}\n}"
              },
              {
                type: "paragraph",
                text: "вкладене правило застосовується тільки у випадку, якщо ширина сторінки більша 800 пікселів."
              },
              {
                type: "paragraph",
                text: "Повернемося до особливості синтаксису мови. Розподільники мови традиційно включають в себе власне пробіли, символи табуляції і переведення рядка та використовуються для покращення сприйняття тексту кода. Наприклад, браузер ігнорує більшу частину символів пробілу. Та все ж є місце в правилах, де використовувати пробіли потрібно обережно – це пробіли біля властивостей і значень. Потрібно розділяти всі значення принаймні одним пробілом, а імена властивостей і їх значення повинні знаходиться в одному нерозривному рядку. Деякі властивості, наприклад **font, background, padding, border,** і **margin** допускають скорочений запис, а саме, дозволяють задавати кілька значень властивості одним рядком, що економить час і робить код більш лаконічним."
              }
            ]
          },
          {
            id: 3,
            title: "Селектори", 
            content: [
              {
                type: "heading",
                text: "Селектори"
              },
              {
                type: "subheading",
                text: "Селектори типу, вони ж селектори"
              },
              {
                type: "paragraph",
                text: "Селектор типу - це просте (і не залежить від регістра) відображення імені HTML-елемента в ім'я відповідного селектора. Це найпростіший спосіб вибрати всі елементи певного типу. Розглянемо приклад;"
              },
              {
                type: "paragraph",
                text: "Нехай маємо фрагмент HTML-коду:"
              },
              {
                type: "code",
                code: "<p>Який улюблений ваш колір?</p>\n<div>Я люблю червоний.</div>\n<p>Я віддаю  перевагу зеленому red!</p>"
              },
              {
                type: "paragraph",
                text: "І просту таблицю стилів:"
              },
              {
                type: "code",
                code: "/* Усі p елементи – червоні */\np {\n  color: red;\n}\n/* Усі div елементи – зелені */\ndiv {\n  color: green;\n}"
              },
              {
                type: "image",
                src: "/images/coloredText.png",
                alt: "Вигляд тексту в браузері"
              },
              {
                type: "paragraph",
                text: "Тобто, згідно першого правила весь текст повідомлення робиться червоним, та враховуючи друге правило – маємо виключення для другого речення."
              },
              {
                type: "subheading",
                text: "Селектори класів (Class selectors)"
              },
              {
                type: "paragraph",
                text: "Селектор класу складається з точки «.», за якою слідує ім'я класу. Ім'я класу – це будь-яке значення, що не містить пробілів в HTML-атрибуті **class**. Зауважимо, що різні елементи можуть належати до одного і того ж класу, і, в той же час, окремий елемент може належати відразу до декількох класів, імена яких розділяються пропуском. Невеликий приклад (4.2):"
              },
              {
                type: "paragraph",
                text: "Нехай маємо такий документ HTML:"
              },
              {
                type: "code",
                code: "<ul>\n\t<li class=\"first done\">Створіть HTML-документ</li>\n\t<li class=\"second done\">Створіть CSS style sheet</li>\n\t<li class=\"third\">Зв’яжіть їх всі разом</li>\n</ul>"
              },
              {
                type: "paragraph",
                text: "І проста таблиця стилів:"
              },
              {
                type: "code",
                code: "/* Елемент з класу \"first\" має бути «напівжирним» (bold) */\n.first {\n\tfont-weight: bold;\n}\n/* Усі інші елементи з інших класів (класу \"done\" */\n.done {\n\ttext-decoration: line-through;\n}"
              },
              {
                type: "subheading",
                text: "Селектори за ID"
              },
              {
                type: "paragraph",
                text: "ID-селектор складається з символу решітки «#», за яким розміщується ID потрібного елемента. Кожен елемент може мати унікальний ідентифікатор, який призначається атрибутом **id**. Що вибирати в якості значення ID, залежить від потреб розробника. Такий селектор є найефективнішим способом позначити окремий елемент."
              },
              {
                type: "paragraph",
                text: "Ім'я ID повинно бути унікальним. Якщо ID у різних елементів збігаються, наслідки непередбачувані - в деяких браузерах, наприклад, в розрахунок приймається тільки перший екземпляр, а інші ігноруються."
              },
              {
                type: "subheading",
                text: "Універсальний селектор"
              },
              {
                type: "paragraph",
                text: "Універсальний селектор визначається символом «*». Це граничний джокер. Він дозволяє вибрати всі елементи сторінки. Оскільки необхідність вибирати відразу всі елементи сторінки трапляється рідко, його зазвичай використовують у поєднанні з іншими селекторами. Будьте обережні при використанні універсального селектора. Його використання стосовно до великих веб-документів надає відчутний вплив на продуктивність. Існує не так вже й багато ситуацій, коли його можна буде використовувати."
              },
              {
                type: "subheading",
                text: "Комбінатори"
              },
              {
                type: "paragraph",
                text: "Комбінатори дозволяють об'єднати безліч селекторів, що дає можливість вибирати елементи всередині інших елементів, або суміжні елементи. Є чотири доступних типи:"
              },
              {
                type: "list",
                items: [
                  "Селектор нащадку – «пробіл» - дозволяє вибрати елемент, вкладений в інший елемент (не обов'язково прямого нащадку, це може бути, наприклад, «онук»)",
                  "Селектор прямого нащадку «->» – дозволяє вибрати безпосереднього нащадка іншого елемента.",
                  "Селектор суміжного сіблінгу « + » – дозволяє вибрати елемент, який є безпосереднім сиблингом іншого елемента (тобто йде слідом за ним і знаходиться на тому ж рівні в ієрархії).",
                  "Загальний селектор сіблінга « ~ » дозволяє вибрати будь-який елемент, який є сіблінгом іншого (тобто такого, що знаходиться на тому ж рівні ієрархії, але не обов'язково відразу ж слідом)."
                ]
              },
              {
                type: "subheading",
                text: "Селектори за атрибутами"
              },
              {
                type: "paragraph",
                text: "Селектори за атрибутами дозволяють шукати елементи за їх атрибутами (**attributes**) і значенням цих атрибутів. Виглядають вони так: квадратні дужки «[]», всередині яких записано ім'я атрибута та, якщо потрібно, умова, якій має відповідати значення атрибута. Селектори атрибутів, в залежності від типу перевірки значення атрибутів, діляться на дві категорії: селектори наявності значення атрибута і селектори підрядка в значенні атрибута."
              },
              {
                type: "paragraph",
                text: "Селектори наявності значення атрибута виділяють елементи на основі точного значення атрибута:"
              },
              {
                type: "list",
                items: [
                  "**[attr]** – вибирає всі елементи з атрибутом **attr**, незалежно від його значення,",
                  "**[attr = val]** – вибирає всі елементи з атрибутом **attr**, що мають значення **val**.",
                  "**[attr ~ = val]** – вибирає всі елементи з атрибутом **attr**, значення якого потрапляє в список розділених пробілами значень **val**, наприклад є одним з класів у списку класів, розділених пробілами."
                ]
              },
              {
                type: "paragraph",
                text: "Селектори підрядка в значенні атрибута ще називають «селектори типу регулярних виразів», оскільки вони пропонують гнучкий спосіб перевірки умов, подібно до того, як це роблять регулярні вирази (**regular expression**) (тут слід уточнити, що ці селектори все ж не є регулярними виразами як такими):"
              },
              {
                type: "list",
                items: [
                  "**[attr- = val]** – вибирає всі елементи з атрибутом **attr**, що мають значення, яке в точності дорівнює **val** або починається з **val-** (зверніть увагу, що символ «-» це не помилка, він потрібен для роботи з мовним кодуванням).",
                  "**[attr ^ = val]** – вибирає всі елементи з атрибутом **attr**, значення якого починається з **val**.",
                  "**[attr $ = val]** – вибирає всі елементи з атрибутом **attr**, значення якого закінчується на **val**.",
                  "**[attr * = val]** – вибирає всі елементи з атрибутом **attr**, значення яких містить рядок (на відміну від **[attr ~ = val]**, цей селектор розглядає прогалини не як роздільник значень, а як частина значення атрибута.)"
                ]
              },
              {
                type: "subheading",
                text: "Псевдокласи"
              },
              {
                type: "paragraph",
                text: "Псевдоклас CSS визначається двокрапкою «:», що стоїть перед ключовим словом, яке додається в кінці інших селекторів, щоб показати, що стиль до відповідних елементів слід застосовувати тільки якщо вони знаходяться в певному стані. Наприклад, ви можливо хочете застосувати стиль лише до тих елементів, які знаходяться під вказівником миші, або до чек-боксу, коли він обраний або не активний, або до першого нащадку деякого елемента в дереві DOM:"
              },
              {
                type: "list",
                items: [
                  "**:active**,",
                  "**:dir()**,",
                  "**:fullscreen**,",
                  "**:lang()**,",
                  "**:scope**,",
                  "**:target**."
                ]
              },
              {
                type: "paragraph",
                text: "Ми не будемо детально розбирати їх усі. Розглянемо тільки один приклад. Нехай у нас є фрагмент HTML-коду:"
              },
              {
                type: "code",
                code: "<a href=\"https://developer.mozilla.org/\" target=\"_blank\">Mozilla Developer Network</a>"
              },
              {
                type: "paragraph",
                text: "і CSS-правила:"
              },
              {
                type: "code",
                code: "/* Ці правила стилізують наші посилання  у всіх станах */\na {\n  color: blue;\n  font-weight: bold;\n}\n/* Ми хочемо, щоб відвідані посилання були такого ж кольору як і невідвідані */\na:visited {\n  color: blue;\n}\n/* Ми хочемо підкреслити наше посилання коли на неї наводиться курсор мишки, коли вона активна, коли вона береться в фокус за допомогою клавіатури */\na:hover,\na:active,\na:focus\n{\n  color: darkred;\n  text-decoration: none;\n}"
              },
              {
                type: "subheading",
                text: "Псевдоелементи"
              },
              {
                type: "paragraph",
                text: "Псевдоелементи дуже схожі на псевдокласи, але є і відмінності. Вони являють собою ключові слова, перед якими стоять дві двокрапки «::» – які можна додавати до селекторів, щоб виділити певну частину елемента:"
              },
              {
                type: "list",
                items: [
                  "**::after**",
                  "**::before**",
                  "**::first-letter**",
                  "**::first-line**",
                  "**::selection**",
                  "**::backdrop**."
                ]
              },
              {
                type: "paragraph",
                text: "У них є дуже цікаві особливості, але детально ми їх вивчати не будемо. Приведемо лише один приклад. Нехай потрібно всі елементи з атрибутом \"href\", значення якого починається з \"http\", доповнити стрілочкою в кінці їх змісту, щоб позначити їх як зовнішні посилання. Це зробить наступний CSS-код:"
              },
              {
                type: "code",
                code: "[href^=http]::after\n{\n  content: '⤴';\n}"
              },
              {
                type: "subheading",
                text: "Комбінування селекторів"
              },
              {
                type: "paragraph",
                text: "Селектори можна використовувати і по одному, але іноді це не досить зручно. Вони стають кориснішими, коли ви починаєте комбінувати їх один з одним, щоб конкретизувати свій вибір. Існує кілька способів вибирати елементи на підставі того, як вони співвідносяться один з одним. Ці взаємозв'язки виражаються за допомогою комбінаторів (A і B тут - це два будь-яких селектори):"
              },
              {
                type: "image",
                src: "/images/comb.png",
                alt: "Комбінатори"
              },
              {
                type: "paragraph",
                text: "Вітаємо, ось і підійшло до кінця наше знайомство із CSS. Навіть найдосвідченіші веб розробники не перестають дивуватися, як багато можна робити з їх допомогою – не турбуйтеся, якщо не змогли запам'ятати все – збережіть під рукою довідник по CSS і повертайтеся до нього в міру потреби. Ми не змогли розповісти багато інших тем, наприклад, ми не розглядали окремо усі види значень, що можуть мати значення властивостей. Ми знову відсилаємо вас до довідника по CSS."
              }
            ]
          },
          {
            id: 4,
            title: "Декілька прикладів застосування", 
            content: [
              {
                type: "heading",
                text: "Декілька прикладів застосування"
              },
              {
                type: "paragraph",
                text: "Нехай потрібно для html сторінки:"
              },
              {
                type: "code",
                code: "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Призвище Ім’я По-батькові</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n  </head>\n  <body>\n    <h1>Практичне завдання</h1>\n    <p>Приклад тексту</p>\n  </body>\n</html>"
              },
              {
                type: "paragraph",
                text: "зробити текст «Практичне завдання» білого кольору, фон - сірого, границя - 2, а текст «Приклад тексту» – зеленого кольору, фон - світло-сірого, границя - 1. Скористаємося таким CSS-кодом:"
              },
              {
                type: "code",
                code: "h1 {\n  color: white;\n  background-color: grey;\n  border-widtch: 2;\n}\np {\n  color: green;\n  background-color: #999999;\n  border-widtch: 1;\n}"
              },
              {
                type: "paragraph",
                text: "Сторінка прийме наступний вигляд:"
              },
              {
                type: "image",
                src: "/images/image128.png",
                alt: "Зображення прикладу застосування CSS"
              },
              {
                type: "paragraph",
                text: "Якщо ж потрібно створити новий заголовок **<h2>** за назвою «Список предметів» і список курсів цього семестру (3-4 елементи), використовуючи класи, застосувавши для кожного рядку свій стиль тексту: підкреслений, жирний, курсив або інший, тоді для цього підійде такий код:"
              },
              {
                type: "code",
                code: ".bold {\n  font-weight: bold;\n}\n.underline {\n  text-decoration: underline;\n}\n.italic {\n  font-style: italic;\n}"
              },
              {
                type: "paragraph",
                text: "У результаті матимемо таку сторінку:"
              },
              {
                type: "image",
                src: "/images/image129.png",
                alt: "Зображення сторінки зі стилізованим списком предметів"
              },
              {
                type: "paragraph",
                text: "Якщо ж виникне потреба замінити шрифт всієї сторінки, наприклад на Arial, тоді потрібно зробити заміну лише в одному місці:"
              },
              {
                type: "code",
                code: "body {\n  font-family: Arial;\n}."
              },
              {
                type: "paragraph",
                text: "Тепер, будемо вважати, що кожний із зазначених курсів має електронний курс розміщений на навчальній платформі **my.ukma.edu.ua**. При натисканні, посилання повинно відкритися у новому вікні. Тоді це можна реалізувати наступним чином:"
              },
              {
                type: "code",
                code: "<h2>Список предметів</h2>\n<ul>\n  <a href=https://my.ukma.edu.ua/course/227700 target=\"_blank\">\n    <li class=\"italic\">Безпека інформаційних систем</li>\n  </a>\n  <a href=\"https://my.ukma.edu.ua/course/227070\" \n          taget=\"_blank\">\n    <li class=\"underline\" >Еволюційне програмування</li>\n  </a>\n  <a href=\"https://my.ukma.edu.ua/course/227081\"\n          target=\"_blank\">\n    <li class=\"bold\">Методика викладання інформатики у вищій школі</li>\n  </a>\n</ul>"
              }
            ]
          },
          {
            id: 5,
            title: "Завдання для самоконтролю", 
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю"
              },
              {
                type: "list",
                items: [
                  "1. Дайте загальну характеристику таблиць каскадних стилів.",
                  "2. Охарактеризуйте загальний формат каскадних таблиць стилів (CSS).",
                  "3. Сформулюйте правила створення CSS.",
                  "4. Назвіть особливості встановлення зв'язків з html-документом у CSS.",
                  "5. Приведіть приклад встановлення зв'язків з html-документом у CSS з використання тега `<link>`.",
                  "6. Приведіть приклад встановлення зв'язків з html-документом у CSS з використання директиви `@import`.",
                  "7. Приведіть приклад визначення таблиці стилів в рамках самого html-документа в середині парного тега `<style>`.",
                  "8. Приведіть методику роботи з кольорами сторінки у CSS.",
                  "9. Приведіть методику роботи з фоном сторінки у CSS.",
                  "10. Побудуйте веб-сторінку для сайту вашого фан-клубу, застосувавши таблицю стилів із використанням елемента `<link>` та атрибуту шрифту **font-style**.",
                  "11. Модифікуйте сайт фан-клубу, додавши до нього другу сторінку, застосувавши таблицю стилів, яка розміщується всередині елемента `<style>` тегу HTML «head» та атрибут шрифта **font-variant**.",
                  "12. Модифікуйте сайт фан-клубу, додавши до нього третю сторінку, застосувавши вбудований стиль, що оформляється у вигляді оголошення CSS, яке може бути застосовано тільки до одного елементу, і міститься в атрибуті **style** та атрибут шрифта **font-weight**.",
                  "13. Дайте характеристику основних категорій селекторів CSS.",
                  "14. Приведіть приклад використання CSS-правила.",
                  "15. Приведіть приклад використання вкладеної конструкції.",
                  "16. Розкажіть про селектори типів.",
                  "17. Розкажіть про селектори класів.",
                  "18. Охарактеризуйте відмінність ID-селектора від універсального селектора.",
                  "19. Приведіть приклад використання комбінатора CSS.",
                  "20. Приведіть приклад використання селектору за атрибутами CSS.",
                  "21. Приведіть приклад використання псевдокласу CSS.",
                  "22. Приведіть приклад використання комбінаторів CSS.",
                ]
              }
            ]
          }
        ]
      },
      {
        id: 5,
        title: "Бібліотека jQuery",
        topics: [
          {
            id: 1,
            title: "Загальна характеристика",
            content: [
              {
                type: "heading",
                text: "Загальна характеристика"
              },
              {
                type: "paragraph",
                text: "З розвитком технологій функціональність веб-сторінок постійно зростає й наближається до функціональності настільних прикладних програм. Ця зростаюча функціональність реалізується за допомогою Javascript. І зовсім не обов'язково особисто прописувати всі необхідні ефекти, якщо для цього вже написано кілька десятків або навіть сотень бібліотек, що дозволяють реалізовувати ці ефекти. Серед безлічі цих бібліотек по праву найбільш зручною й доступною для розуміння є бібліотека jQuery. Вона фокусується на взаємодії Javascript і HTML."
              },
              {
                type: "paragraph",
                text: "Ключовою функцією в jQuery є функція **$()** - вона тим чи іншим способом викликається всіма методами jQuery. Згідно із заявами віце-президента по розробці Скотта Гутрі (Майкрософт), бібліотека jQuery, стане основою ASP.Net Ajax Control Toolkit і буде поставлятися в складі Visual Studio."
              },
              {
                type: "paragraph",
                text: "Завдяки тому, що обсяг програмного коду jQuery менший, ніж обсяг стандартного коду Javascript, скорочуються часові витрати на розробку елементів веб-сторінки. Сам програмний код більш зрозумілий у порівнянні з Javascript. Наведемо приклад. Нехай існує деяка таблиця, непарні рядки якої розфарбовані відмінним від основного кольором. Припустимо, що існує також якась таблиця стилів CSS, у якій уже визначений клас (у прикладі, «odd») для такого стилю."
              },
              {
                type: "paragraph",
                text: "Для реалізації цього ефекту необхідно наділити непарні рядки таблиці даним класом. У реалізації на чистому Javascript програмний код буде виглядати так:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var tables = document.getElementsByTagName(\"table\");\nfor ( var t = 0; t < tables.length; t++ ) {\n\tvar rows = tables[t].getElementsByTagName(\"tr\");\n\tfor ( var i = 1; i < rows.length; i += 2 )\n\t\tif ( !/(|s)odd(s|$)/.test( rows[i].className ) ) rows[i].className += \" odd\";\n}"
              },
              {
                type: "paragraph",
                text: "Із застосуванням jQuery реалізація матиме наступний вигляд:"
              },
              {
                type: "code",
                code: "$(\"tr:nth-child(odd)\").addClass(\"odd\");"
              },
              {
                type: "paragraph",
                text: "Важливою ознакою інтерактивних HTML-сторінок є можливість реакції на дії користувача. Наприклад, натиск на кнопці повинен викликати появу діалогового вікна, або виконання перевірки правильності введених користувачем даних. В JavaScript інтерактивність реалізована за допомогою перехвату та обробки подій, викликаних в результаті дій користувача. Для цього в теги деяких елементів введені параметри обробки подій. Ім’я параметру обробки події починається з префіксу **on**, за яким йде назва події. Наприклад, події клік кнопкою миші **Click**, відповідає параметр обробки події з назвою **onClick**."
              },
              {
                type: "paragraph",
                text: "jQuery - бібліотека JavaScript, яка дозволяє отримувати доступ до будь-якого елементу моделі DOM, звертатися до атрибутів і вмісту, а також маніпулювати ними. Вміє працювати з подіями, легко здійснювати різні візуальні ефекти. Бібліотека також надає зручний API для роботи з технологією AJAX. Має величезну кількість JavaScript плагінів, призначених для створення елементів інтерфейсів."
              },
              {
                type: "paragraph",
                text: "Плаґін (англ. plug-in – підключати) — застосунок, що вноситься до загального класу програмних застосунків і який динамічно підключається до основної програми, призначений для розширення або використання її можливостей. Плаґіни, зазвичай, реалізуються у вигляді динамічних бібліотек."
              },
              {
                type: "paragraph",
                text: "Основна програма надає сервіси (можливість зареєструвати себе в основному додатку, протокол обміну даними з іншими плаґінами) для плаґіна. Тому плаґіни самостійно практично не використовуються. В той же час, основний додаток може незалежно оперувати плаґінами, надаючи кінцевим користувачам можливість динамічно додавати й оновлювати плаґіни без необхідності внесення змін в основний додаток. Наприклад, у браузерах плаґіни використовуються для забезпечення показу форматів даних, які не мають вбудованої підтримки браузером (наприклад Adobe Flash або SVG), для налаштування можливостей під вимоги користувача, і навіть для відлагодження (англ. debugging) скриптових програм JavaScript всередині браузера (Firebug, додаток Firefox), плаґіни для поштових програм, а саме спам-фільтри, плаґіни для перевірки листів антивірусом. Так широке застосування для Google Chrome дістали плагіни Adblock (блокує рекламу), Forecastfox Weather (показує погоду в інтерфейсі браузера). В комп’ютерних іграх плаґіни використовуються для налаштування різноманітних параметрів, зміни правил гри."
              },
              {
                type: "paragraph",
                text: "Команди jQuery засновані на селекторах і класах CSS."
              },
              {
                type: "paragraph",
                text: "Бібліотеку jQuery можна завантажити з сайту http://jquery.com/. Розмір бібліотеки в мінімальному варіанті становить приблизно 60 Кб."
              },
              {
                type: "paragraph",
                text: "Перед початком роботи бібліотеку треба підключити:"
              },
              {
                type: "code",
                code: "<script src =”jquery.min.js” type =”text / javascript”> </ script>."
              },
              {
                type: "paragraph",
                text: "Також є можливість використання CDN (content delivery network – мережа доправлення і розповсюдження контенту), деталі доступні за посиланням."
              },
              {
                type: "paragraph",
                text: "Вся робота з бібліотекою ведеться з використанням функції **$**, але за умови використання інших бібліотек, можливо працювати через jQuery за умови попереднього виклику методу **jQuery.noConflict()**."
              },
              {
                type: "paragraph",
                text: "Загальна ідея використання: 1) вибирається елемент або група елементів, 2) виконуються дії над виділеними елементами."
              },
              {
                type: "heading",
                text: "Селектори"
              },
              {
                type: "paragraph",
                text: "Розглянемо на прикладах варіанти селекторів доступу до елементів. Звертаємо вашу увагу, що тут справджується і використовується синтаксис CSS, але є селектори що доступні лише в рамках роботи з jQuery."
              },
              {
                type: "paragraph",
                text: "Серед CSS селекторів можна виділити:"
              },
              {
                type: "list",
                items: [
                  "**$ (‘p’)** – вибирає всі посилання, розташовані в абзацах,",
                  "**$ (‘#myId’)** – вибір елемента з вказаним ідентифікатором,",
                  "**$ (‘.myClass’)** – вибір об’єктів з класом **myClass**,",
                  "**$ ('body > div')** – вибір елементів **div**, що є прямими нащадками елемента **body**," /* Fixing space before > */,
                  "**:first-child** – перший дочірній елемент,",
                  "**:last-child** – останній дочірній елемент,",
                  "**:nth-child (n)** – n-й елемент,",
                  "**:nth-child (even | odd)** – парні або непарні дочірні елементи."
                ]
              },
              {
                type: "paragraph",
                text: "Найбільш вживаними jQuery селекторами є:"
              },
              {
                type: "list",
                items: [
                  "**$(‘p:even’)** – обирає парні абзаци.",
                  "**$(‘a[href^=”http://”]’)** – цьому селектору відповідають усі посилання, які починаються з символів **http://**, на це вказує символ **^**.",
                  "**$(‘a[href$=”.pdf”]’)** – посилання закінчуються на «pdf».",
                  "**$(‘a[href*=”ukma.com”]’)** – посилання містить згадку **ukma.com** в довільному місці.",
                  "**:has** – є можливість вибору певних елементів за умови, що вони містять інші елементи (у прикладі нижче двокрапка як у математиці означає \"таке що\"). Наприклад, селектор **li:has(a)**, вибирає елементи **<li>**, які містять елемент **<a>**.",
                  "**:first** – перший збіг на сторінці.",
                  "**:last** – останній збіг на сторінці.",
                  "**:even** – парні елементи.",
                  "**:odd** – непарні елементи.",
                  "**:input** – вибирає елементи форми.",
                  "**:selected** – вибрані елементи option.",
                  "**:visible** – вибір видимих елементів.",
                  "**:hidden** – вибір невидимих елементів."
                ]
              },
              {
                type: "heading",
                text: "Оброблювач готовності документу"
              },
              {
                type: "paragraph",
                text: "Передбачено два способи оброблення. Перший спосіб – це запуск обробника, коли завантажилася сторінка:"
              },
              {
                type: "code",
                code: "$(window).load(function () {\n  $(\"Table tr: nth-child (even)\").addClass (\"even\");\n});"
              },
              {
                type: "paragraph",
                text: "Недоліком цього методу є те, що нічого не буде змінено, поки все не завантажиться, включаючи картинки. Але, з іншого боку, це можна вважати і перевагою. Адже користувач може угледіти як все змінюється, тобто побачити як вихідний варіант, так і перетворений."
              },
              {
                type: "paragraph",
                text: "Другий спосіб – дочекатися лише завантаження структури документа, а саме:"
              },
              {
                type: "code",
                code: "$(document).ready(function () {\n  $(\"Table tr: nth-child (even)\").addClass (\"even\");\n});"
              },
              {
                type: "paragraph",
                text: "Тобто читаємо буквально – «Запуск функції після завантаження». У цієї конструкції є скорочена форма:"
              },
              {
                type: "code",
                code: "$(function () {\n  $(\"Table tr: nth-child (even)\").addClass (\"even\");\n});"
              },
              {
                type: "heading",
                text: "Створення елементів DOM"
              },
              {
                type: "paragraph",
                text: "Створення елемента задається так:"
              },
              {
                type: "code",
                code: "$ ('<div> Hi </div>')."
              },
              {
                type: "paragraph",
                text: "Дозволяється створення і порожнього елемента:"
              },
              {
                type: "code",
                code: "$ ('<div>')."
              },
              {
                type: "paragraph",
                text: "У записі можна використовувати лапки або апострофи. Але наявність тегів обов'язкова. Задавати просто текст теж можна. Згадайте скільки було команд, щоб створити гілочку елементів без jQuery. Сама по собі ця команда нічого не виведе, треба цю гілочку знову ж прив'язати до батьківського елементу."
              },
              {
                type: "paragraph",
                text: "Робиться це так:"
              },
              {
                type: "code",
                code: "$ ('<div> Hi </div>').insertAfter ('#a1');"
              },
              {
                type: "paragraph",
                text: "тут **a1** – ідентифікатор об'єкта, після якого необхідно вставити елемент. Також є аналогічна функція **insertBefore**, яка вставляє контент до вказаного аргументом елементу. Для доповненням вже існуючих DOM елементів новими використовують здебільшого дві аналогічні команди:"
              },
              {
                type: "list",
                items: [
                  "**append(content)** – додати новий елемент в кінець дочірніх елементів",
                  "**prepend(content)** – додати новий елемент на початок дочірніх елементів"
                ]
              },
              {
                type: "paragraph",
                text: "У якості змінної **content** може виступати як стрічка, так і функція, що в результаті своєї роботи поверне стрічку."
              },
              {
                type: "heading",
                text: "Робота з отриманим набором значень"
              },
              {
                type: "paragraph",
                text: "У термінах jQuery ці набори називають обгорнутими. Визначення розміру. Для цього можна використовувати метод **size()**. Заміна вмісту елемента з ідентифікатором **a1** на кількість елементів класу **b2** виглядатиме так:"
              },
              {
                type: "code",
                code: "$ (“#a1”).html ($ (“.b2”).size ())."
              },
              {
                type: "paragraph",
                text: "Отриманий обгорнутий набір значень розглядається як масив, з яким далі можна працювати. Отримати будь-який елемент в обгорнутому наборі можна за індексом. Наприклад, для отримання другого елементу в наборі всіх гіперпосилань можна скористатися методом **get()**, тобто останню команду можна записати так:"
              },
              {
                type: "code",
                code: "$ ('a').get (1)."
              },
              {
                type: "paragraph",
                text: "За допомогою методу **get()** можна отримати звичайний масив JavaScript, що містить усі загорнуті елементи:"
              },
              {
                type: "code",
                code: "var allanchors = $ ('a').get (). "
              },
              {
                type: "heading",
                text: "Маніпулювання об'єктами на сторінці"
              },
              {
                type: "paragraph",
                text: "Команди jQuery дозволяють маніпулювати властивостями, атрибутами, стилями і вмістом елементів. Для звернення до властивостей і їх значень використовуються методи JavaScript. Наприклад:"
              },
              {
                type: "code",
                code: "$ ('.b2').each (function (n) {$(this).attr('title', “New” + n); });"
              },
              {
                type: "paragraph",
                text: "змінює властивість **title** у всіх елементах класу **b2**. Тут використана команда **each (функція)**. Вона виконує обхід всіх елементів у наборі і викликає для них функцію. Як параметр функції передається індекс елемента в наборі."
              },
              {
                type: "paragraph",
                text: "Різні браузери по-своєму обробляють події. jQuery намагається згладити ці неприємності. Тому звертаємося тільки до методів jQuery, а бібліотека вже сама дивиться, що за браузер і застосовує ту чи іншу властивість."
              },
              {
                type: "paragraph",
                text: "Модель подій jQuery підтримує єдиний метод установки подій, дозволяє встановлювати кілька обробників для події, використовує стандартні назви типів подій і надає єдині методи скасування події й блокування дій за замовчуванням."
              },
              {
                type: "subheading",
                text: "Підключення обробників"
              },
              {
                type: "paragraph",
                text: "Розглянемо приклад функції, яка буде спрацьовувати при клацанні (підвести маркер на малюнок і натиснути клавішу мишки) по будь-якому малюнку:"
              },
              {
                type: "code",
                code: "$ ('img').bind ('click', function (event) {alert ('Вітаю!');});"
              },
              {
                type: "paragraph",
                text: "Для видалення обробника використовується команда **unbind()**."
              },
              {
                type: "paragraph",
                text: "Для роботи з тригерами в jQuery передбачені такі функції:"
              },
              {
                type: "list",
                items: [
                  "**bind (type, data, fnc)** - додає обробник подій;",
                  "**one (type, data, fnc)** - додає обробник подій, який спрацює лише раз;",
                  "**trigger (event, data)** - викликає обробники подій;",
                  "**triggerHandler (event, data)** - викликає обробники подій, без виклику події браузера;",
                  "**unbind (type, fnc)** - видаляє всі обробники подій з елемента."
                ]
              },
              {
                type: "paragraph",
                text: "Є також обробник **on()**, який долучається до існуючих та майбутніх DOM елементів."
              },
              {
                type: "paragraph",
                text: "Також jQuery має спрощені обробники, наприклад:"
              },
              {
                type: "list",
                items: [
                  "**click()** – натиснення на елемент;",
                  "**hover()** – наведення на елемент;",
                  "**load()** – завершення завантаження елементу (на ньому базуються прелоадери)."
                ]
              },
              {
                type: "paragraph",
                text: "Весь перелік обробників доступний за посиланням [16]."
              },
              {
                type: "heading",
                text: "Співпраця з AJAX"
              },
              {
                type: "paragraph",
                text: "Почнемо з найпростішого. Розглянемо завантаження HTML коду в необхідний нам DOM елемент на сторінці. Для цієї мети нам підійде метод **load**."
              },
              {
                type: "paragraph",
                text: "Цей метод може приймати такі параметри:"
              },
              {
                type: "list",
                items: [
                  "url сторінки,",
                  "передані дані (необов'язковий параметр),",
                  "функція для обробки отриманого результату (необов'язковий параметр)."
                ]
              },
              {
                type: "paragraph",
                text: "Наприклад:"
              },
              {
                type: "code",
                code: "// По закінченню завантаження сторінки\n$(document).ready(function () {\n  // Підключаємо на клік по елементу з id = example-1\n  $('#example-1').click(function () {\n    // Завантаження HTML коду з файлу example.html\n    $(this).load('ajax/example.html');\n  })\n});"
              },
              {
                type: "paragraph",
                text: "Приклад підвантажених даних (вміст файлу **example.html**) виглядатиме:"
              },
              {
                type: "code",
                code: "Example <br/>\nData Loaded By AJAX\n<br/>Bye-Bye"
              },
              {
                type: "subheading",
                text: "jQuery.ajax"
              },
              {
                type: "paragraph",
                text: "Це основний метод, а всі наступні методи лише обгортки для методу **jQuery.ajax**. У методу лише один вхідний параметр – об'єкт, що включає в себе всі налаштування (виділені параметри, які варто запам'ятати):"
              },
              {
                type: "list",
                items: [
                  "**async** – асинхронність запиту, за замовчуванням true",
                  "**cache** – вкл/викл кешування даних браузером, за замовчуванням true",
                  "**сontentType** – за умовчанням «application / x-www-form-urlencoded»",
                  "**data** – передані дані: рядок або об'єкт",
                  "**dataFilter** – фільтр для вхідних даних",
                  "**dataType** – тип даних, що повертаються в callback функцію (**xml, html, script, json, text, _default**);",
                  "**global** – тригер, що відповідає за використання глобальних AJAX Event'ів, за замовчуванням true",
                  "**ifModified** – тригер, що перевіряє, чи були зміни у відповіді сервера, щоб не слати ще запит, за замовчуванням false",
                  "**jsonp** - перевстановити ім'я callback функції для роботи з JSONP (за замовчуванням генерується по ходу)",
                  "**processData** – за умовчанням дані, що відправляються, загортаються в об'єкт, і відправляються як «application/x-www-form-urlencoded», якщо треба інакше – відключаємо",
                  "**scriptCharset** – кодування, що актуально для JSONP і підвантаження JavaScript'ів;",
                  "**timeout** – час таймаут в мілісекундах;",
                  "**type** – GET або POST;",
                  "**url** – url сторінки;",
                  "**headers** – об’єкт з додатковими заголовками;"
                ]
              },
              {
                type: "paragraph",
                text: "Для організації HTTP авторизації використовуються:"
              },
              {
                type: "list",
                items: [
                  "**username** – логін,",
                  "**password** – пароль."
                ]
              },
              {
                type: "paragraph",
                text: "Використовуються і локальні AJAX Event:"
              },
              {
                type: "list",
                items: [
                  "**beforeSend** – спрацьовує перед відправленням запиту,",
                  "**error** – якщо відбулася помилка,",
                  "**success** – якщо помилок не виникло,",
                  "**complete** – спрацьовує по закінченню запиту."
                ]
              },
              {
                type: "paragraph",
                text: "Приведемо приклад використання:"
              },
              {
                type: "code",
                code: "$.ajax ({\n  url: '/ajax/example.html', // вказуємо URL \n  dataType: \"json\", // тип завантажуваних даних\n  success:function (data, textStatus) {\n    // додаємо свій обробник на функцію success\n    $.each (data, function (i, val) {\n      // обробляємо отримані дані /* ... */\n    });\n  }\n});"
              },
              {
                type: "paragraph",
                text: "Можливі і спрощені виклики **.get()** та **.post()** для відповідних запитів."
              },
              {
                type: "paragraph",
                text: "Важливим аспектом у роботі AJAX з іншими доменами є використання методу **CORS**, або **JSONP**."
              },
              {
                type: "paragraph",
                text: "**CORS**, або **Cross-Origin Resource Sharing**, є ще одним методом, що забезпечує крос-доменність JSON. CORS використовує стандартний механізм, який може бути ініційований у всіх браузерах для реалізації крос-доменних запитів. Ця специфікація визначає набір заголовків, які дозволяють браузеру і серверу спілкуватися з приводу запитів (які дозволені, а які - ні). CORS - це open web, API доступне для всіх."
              },
              {
                type: "paragraph",
                text: "**JSONP (JSON with padding)** використовується, коли потрібно отримати JSON-дані з зовнішнього домену. Це корисно, коли використання звичайного JSON неможливе через загрозу безпеки. JSONP - це спосіб використовувати cross-domain JSON-дані, не турбуючись, якщо браузер заважає вам вчинити так само. Перевага JSONP в тому, що браузери не реалізують політику єдності походження тегів скриптів."
              }
            ]
          },

          {
            id: 2,
            title: "Розробка гри «П'ятнашки» з використанням jQuery",
            content: [
              {
                type: "heading",
                text: "1.5.2. Розробка гри «П'ятнашки» з використанням jQuery"
              },
              {
                type: "paragraph",
                text: "П'ятнашки — популярна головоломка, придумана у 1878 році Ноєм Чепменом. Складається з 15 однакових квадратних пластинок з нанесеними числами від 1 до 15. Пластинки поміщаються в квадратну коробку, довжина сторони якої в чотири рази більша довжини сторони пластинок, відповідно в коробці залишається незаповненим одне квадратне поле. Мета гри – переміщаючи пластинки по коробці добитися впорядковування їх по номерах, бажано зробивши якомога менше переміщень (рис. 3.34)."
              },
              {
                type: "image",
                src: "/images/image130.png", 
                alt: "Рис. 3.34. Зображення результату гри «П'ятнашки»"
              },
              {
                type: "paragraph",
                text: "Для розв’язання задачі можна застосувати такі роздуми. Якщо позначити пусту клітину числом 16, тоді всі властивості головоломки можна одержувати із властивостей перестановок чисел 1..16. Тобто, кожне переміщення пластинок у коробці буде відповідати деякій транспозиції (перестановці) числа 16 і деякого іншого числа. Кожна така транспозиція змінює парність перестановки чисел. Якщо в початковому розміщенні пуста клітина розташована у нижньому правому куті, то на своє місце вона може повернутися за парну кількість кроків, тобто парність у цьому випадку не зміниться. Тому якщо початкова перестановка є непарною (як наприклад на рис. 3.35) то головоломка розв'язку не має. У загальному випадку розв'язку не існує, якщо непарним є число n+i+j,"
              },
              {
                type: "image",
                src: "/images/image131.png", 
                alt: "Рис. 3.35. Зображення прикладу неможливого упорядкування"
              },
              {
                type: "paragraph",
                text: "де **n** – рівно нулю для парних початкових перестановок чисел 1..16 і одиниці для непарних, **i, j** – позиція пустої клітини. Натомість кожне початкове розміщення, для якого число **n+i+j** є парним, має розв'язок головоломки."
              },
              {
                type: "paragraph",
                text: "В нашій модифікації додатково буде зроблено таймер по закінченню відліку якого гра автоматично завершується програшом. Тобто, гра буде відображатися у вигляді, представленому на рисунку 3.36."
              },
              {
                type: "image",
                src: "/images/image132.png", 
                alt: "Рис. 3.36. Зображення загального вигляду гри «П'ятнашки»"
              },
              {
                type: "subheading",
                text: "Розробка HTML відображення гри"
              },
              {
                type: "paragraph",
                text: "Найперше потрібно розробити HTML представлення цієї гри. Побудуємо таблицю, що містить 4 рядки:"
              },
              {
                type: "list",
                items: [
                  "Назва гри",
                  "Ігрове поле",
                  "Статистичні дані про поточну гру",
                  "Кнопка запуску нової гри та виклик двох JavaScript функцій: newGame() та move(n)."
                ]
              },
              {
                type: "code",
                code: "<table border=\"2\" align=\"center\" width=\"292\">\n  <tbody>\n    <tr>\n      <td bgcolor=\"green\" align=\"center\" height=\"50\">\n        П'ятнашки\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <img src=\"level1/1.png\" onclick=\"move(0)\" name=\"1\" width=\"70\" height=\"70\"><img src=\"level1/2.png\" onclick=\"move(1)\" name=\"2\" width=\"70\" height=\"70\"><img src=\"level1/3.png\" onclick=\"move(2)\" name=\"3\" width=\"70\" height=\"70\"><img src=\"level1/4.png\" onclick=\"move(3)\" name=\"4\" width=\"70\" height=\"70\"><br>\n        <img src=\"level1/5.png\" onclick=\"move(4)\" name=\"5\" width=\"70\" height=\"70\"><img src=\"level1/6.png\" onclick=\"move(5)\" name=\"6\" width=\"70\" height=\"70\"><img src=\"level1/7.png\" onclick=\"move(6)\" name=\"7\" width=\"70\" height=\"70\"><img src=\"level1/8.png\" onclick=\"move(7)\" name=\"8\" width=\"70\" height=\"70\"><br>\n        <img src=\"level1/9.png\" onclick=\"move(8)\" name=\"9\" width=\"70\" height=\"70\"><img src=\"level1/10.png\" onclick=\"move(9)\" name=\"10\" width=\"70\" height=\"70\"><img src=\"level1/11.png\" onclick=\"move(10)\" name=\"11\" width=\"70\" height=\"70\"><img src=\"level1/12.png\" onclick=\"move(11)\" name=\"12\" width=\"70\" height=\"70\"><br>\n        <img src=\"level1/13.png\" onclick=\"move(12)\" name=\"13\" width=\"70\" height=\"70\"><img src=\"level1/14.png\" onclick=\"move(13)\" name=\"14\" width=\"70\" height=\"70\"><img src=\"level1/15.png\" onclick=\"move(14)\" name=\"15\" width=\"70\" height=\"70\"><img src=\"level1/0.jpg\" onclick=\"move(15)\" name=\"0\" width=\"70\" height=\"70\">\n      </td>\n    </tr>\n    <tr>\n      <td align=\"center\">\n        <p id=\"id\"></p>\n        Кількість кроків:\n        <p id=\"point\"></p>\n      </td>\n    </tr>\n    <tr>\n      <td align=\"center\">\n        <input type=\"button\" onclick=\"newGame()\" value=\"Нова гра\">\n      </td>\n    </tr>\n  </tbody>\n</table>"
              },
              {
                type: "subheading",
                text: "Розробка додатку ігрової механіки"
              },
              {
                type: "paragraph",
                text: "Реалізуючи гру, введемо глобальну змінну, що відповідатиме за таймер гри (**stopTimer**), і 4 функції для реалізації ігрової механіки, а точніше:"
              },
              {
                type: "list",
                items: [
                  "**newGame()** – яка відповідає за запуск нового сеансу гри",
                  "**move(n)** – функція для «руху» поточного елементу, де **n** – номер цього елементу в рамках загально-ігрової логіки",
                  "**newGameTimer(startTime)** – функція, яка буде активувати таймер **stopTimer** на задану у змінній **startTime** кількість часу",
                  "**stop()** – функція, яка буде зупиняти роботу таймеру **stopTimer**"
                ]
              },
              {
                type: "paragraph",
                text: "Програмний код кожної розглянемо окремо."
              },
              {
                type: "subheading",
                text: "Функція newGame()"
              },
              {
                type: "paragraph",
                text: "Мета цієї функції – зробити розстановку елементів гри псевдовипадковою, спинити попередній таймер та запустити новий. Для цього створимо три об’єкти класу Image розстановки пластинок (елементи гри) псевдовипадково. Потім ініціалізуємо кількість ходів – нулем, спинимо таймер і запустимо новий:"
              },
              {
                type: "code",
                code: "var p1 = new Image();\nvar p2 = new Image();\nvar img1 = new Image();\n\nvar name;\n\nfor (var i=0; i < 50; ++i) {\n\tp1 = Math.floor(Math.random()*16);\n\tp2 = Math.floor(Math.random()*16);\n\n\timg1 = document.images[p1].src;\n\tdocument.images[p1].src = document.images[p2].src;\n\tdocument.images[p2].src = img1;\n\n\tname = document.images[p1].name;\n\tdocument.images[p1].name = document.images[p2].name;\n\tdocument.images[p2].name = name;\n}\n\ndocument.getElementById(\"point\").innerHTML = '0';\nstop();\nnewGameTimer(300);"
              },
              {
                type: "subheading",
                text: "Функція move(n)"
              },
              {
                type: "paragraph",
                text: "Функціонал її наступний:"
              },
              {
                type: "list",
                items: [
                  "1. Перевіряємо чи запущений таймер, якщо ні – то запускаємо нову гру",
                  "2. Шукаємо пусту клітинку.",
                  "3. Перевіряємо чи ця клітинка поблизу нашої клітинки, якщо так – змінюємо їх місця.",
                  "4. Перевіряємо чи не є поточна конфігурація виграшною, якщо виграшна – виводимо сповіщення і запускаємо нову гру."
                ]
              },
              {
                type: "code",
                code: "if (typeof stopTimer === 'undefined') // перевіряємо чи запущений таймер\n\tnewGame(); // запуск нової гри \n\nvar n2 ;\nfor (var i=0; i<16; ++i) { //Шукаємо пусту клітинку\n\n\tif (document.images[i].name==0) {\n\t\tn2 = i;\n\t}\n}\n\nif ((n - n2 == 4) || (n2 - n == 4) || (n - n2==1) || (n2 - n==1)){\n\tdocument.images[n2].src = \"level1/\" + document.images[n].name + \".png\";\n\tdocument.images[n].src = \"level1/0.jpg\";\n\tdocument.images[n2].name = document.images[n].name;\n\tdocument.images[n].name = \"0\";\n\tdocument.getElementById(\"point\").innerHTML++;\n}\n\nn2 = 0;\n\nfor ( var i=0; i<13; ++i ){\n\tif (document.images[i].name==i+1){\n\t\t++n2;\n\t}\n}\n\nif ((n2==13) && (document.images[15].name == 0)){\n\talert(\"Ви виграли!!!\");\n\tnewGame();\n}"
              },
              {
                type: "subheading",
                text: "Функція newGameTimer(startTime)"
              },
              {
                type: "paragraph",
                text: "Ця функція вираховує кількість часу до заданого, оновлює відповідне значення у HTML документі, а також слідкує чи не вийшов ігровий час сеансу, якщо вийшов – виводить відповідне повідомлення:"
              },
              {
                type: "code",
                code: "var time = startTime;\nvar minute = parseInt(time/60);\nif(minute < 1) minute = 0;\n\ntime = parseInt(time - minute*60);\nif(minute < 10) minute = '0'+minute;\n\nvar second = time;\nif(second < 10) second = '0'+second;\n\ndocument.getElementById(\"id\").innerHTML = minute+\":\"+second;\nstartTime--;\n\nif (startTime>0) {\n\tstopTimer = setTimeout(function(){\n\t\tnewGameTimer(startTime);\n\t}, 1000);\n} else {\n\tdocument.getElementById(\"id\").innerHTML = \"00:00\";\n\talert(\"ви програли: закінчився час!!!\");\n\tnewGame();\n}"
              },
              {
                type: "subheading",
                text: "Функція stop()"
              },
              {
                type: "paragraph",
                text: "Функція забезпечує зупинку відліку ігрового часу сеансу:"
              },
              {
                type: "code",
                code: "clearTimeout(stopTimer);"
              }
            ]
          },
          {
            id: 3,
            title: "JavaScript та доцільність використання бібліотеки jQuery",
            content: [
              {
                type: "heading",
                text: "JavaScript та доцільність використання бібліотеки jQuery"
              },
              {
                type: "paragraph",
                text: "Отже, jQuery – це популярна JavaScript-бібліотека з відкритим сирцевим кодом. Згідно з дослідженням організації W3Teachs, jQuery використовується понад половиною від мільйона найвідвідуваніших сайтів."
              },
              {
                type: "paragraph",
                text: "Синтаксис jQuery розроблений, щоб зробити орієнтування у навігації зручнішим завдяки вибору елементів DOM, створенню анімації, обробки подій і розробки AJAX-застосунків. Більше того, дана бібліотека працює зі всіма браузерами. Це означає, що більше не потрібно турбуватися про кросбраузерну сумісність JS:"
              },
              {
                type: "code",
                language: "javascript",
                code: "$(document).ready(function(){\n\t$(\":button\").click(function(){\n\t\t$(\":button\").hide();\n\t\t$(\"#wrap1\").addClass(\"add\");\n\t\t$(\"#wrap2\").animate({height:280},2000);\n\t});\n});"
              },
              {
                type: "paragraph",
                text: "Якщо порівняти швидкодію кодів, написаних на JS i jQuery в різних браузерах, то можна побачити, що код на чистому JS працює значно повільніше. Тому, якщо вам потрібна програма, яка працює швидше, потрібно використовувати бібліотеку, в іншому разі – JS чудово справляється і сам з тими функціями, які так добре виконує jQuery."
              },
              {
                type: "subheading",
                text: "Порівняння часу виконання операцій. Таблиця 3.3."
              },
              {
                type: "image",
                src: "/images/timeTable.png",
                alt: "Таблиця 3.3. Порівняння часу виконання операцій."
              },
              {
                type: "paragraph",
                text: "Також jQuery варто використовувати, якщо ви робите на сторінці анімацію. Адже анімація – це дуже складний процес, і гарну анімацію на чистому JS робити дуже довго, тоді як на jQuery – це фактично одна стрічка. Наприклад, анімація зникнення:"
              },
              {
                type: "code",
                language: "javascript",
                code: "var alert = $(‘span.alert’);\nalert.show();\nalert.html(‘Time!!!’);\nalert.fadeOut(3000);"
              },
              {
                type: "paragraph",
                text: "В той же час для навіть простої анімації (анімація тексту) на чистому JS потрібно написати значно більше стрічок коду. Більше того, розробники не повинні розраховувати на підтримку JS для доставки контенту або інформації. Наприклад:"
              },
              {
                type: "code",
                language: "javascript",
                code: "<script language=”javascript”>\nvar now = new Date();\nif(now.getHours() < 12) document.write(‘Доброго ранку!’);\nelse  document.write(‘Доброго дня’);\n</script>"
              },
              {
                type: "paragraph",
                text: "Цей фрагмент коду використовується для відображення слів «Доброго ранку» або «Доброго дня» залежно від часу доби. Проте, таке його використання не завжди коректне, оскільки в браузері може бути відключений JS. Тому, за відсутності JS, на сторінці нічого не виведеться – залишиться порожнє місце. Для використання подібного коду потрібно знати, що браузер користувача підтримує JS."
              },
              {
                type: "paragraph",
                text: "Семантично правильний і доступний спосіб виконати це завдання такий:"
              },
              {
                type: "code",
                code: "<p title=”Good Day Message”>Good Morning!</p>\nvar now = new Date();\nif(now.getHours()>=12)\n{ var goodDay = $(‘p[title=”Good Day Message”]’);\ngoodDay.text(‘Good Afternoon!’); }"
              },
              {
                type: "paragraph",
                text: "У цьому варіанті коду сторінка буде відображатися в будь-якому випадку."
              },
              {
                type: "paragraph",
                text: "Цікаво знати, що написання традиційної програми привітання «Hello world» також є кращим на jQuery:"
              },
              {
                type: "code",
                code: "<script language = “javascript”> $(document). ready(function() { alert(‘Hello world’);});\n</script>"
              },
              {
                type: "paragraph",
                text: "Це випливає із того, що jQuery-код розміщується у зовнішньому файлі JS, тому він не впливає на HTML код сторінки. Функція **$(document).ready** приймає іншу функцію як аргумент. Ця функція передається в **$(document).ready** після того, як завершиться завантаження DOM і виконається код всередині цієї функції (в даному випадку це **alert**)."
              },
              {
                type: "paragraph",
                text: "Як бачимо, jQuery є надзвичайно потужною бібліотекою, яка надає всі інструменти, необхідні для створення красивих взаємодій та анімації на веб-сторінках. Проте, якою б потужною не була ця бібліотека, все-одно абсолютно все, що можна зробити на ній, можна зробити і на чистому JS, оскільки сама бібліотека jQuery – це і є JS. Більше того, ця бібліотека навіть у стисненому вигляді важить більше 80 КБ."
              },
              {
                type: "paragraph",
                text: "Тому якщо вам потрібно зробити які-небудь елементарні речі, наприклад, додати пару елементів на сторінку через JS, видалити що-небудь, змінити який-небудь атрибут, то замість підключення бібліотеки краще використовувати DOM – JS має чудові інструменти для маніпуляції нею. Інша справа, якщо потрібно міняти десятки або й сотні елементів, причому абсолютно різних (а вставляти у кожного свій id незручно), тоді вже краще використовувати бібліотеку jQuery."
              }
            ]
          },
          {
            id: 4,
            title: "Завдання для самоконтролю",
            test: true,
            content: [
              {
                type: "heading",
                text: "Завдання для самоконтролю",
              },
              {
                type: "list",
                items: [
                  "1. Дайте загальну характеристику бібліотеки jQuery.",
                  "2. Поясніть на прикладах варіанти використання селекторів доступу до елементів jQuery.",
                  "3. Охарактеризуйте два способи обробки документу.",
                  "4. Приведіть приклад створення елементів DOM.",
                  "5. Приведіть приклад роботи з «обгорнутими» наборами значень.",
                  "6. Приведіть приклад використання моделі подій jQuery.",
                  "7. Напишіть функцію, що вираховує кількість часу до заданого та оновлює відповідне значення у HTML документі.",
                  "8. Розробіть HTML-представлення гри в «хрестики-нулики».",
                  "9. Охарактеризуйте переваги використання бібліотеки jQuery."
                ]
              }
            ]
          }
        ]
      }
    ]
  } 
];

export default content;
